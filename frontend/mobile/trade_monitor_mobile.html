<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trade Monitor Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../styles/global.css">
    <script src="../js/live-data.js"></script>
    <script src="../js/strike-table.js"></script>
    <script src="../js/globals.js"></script>
    <script src="../js/active-trade-supervisor_panel.js"></script>
    <script src="../js/trade-execution-controller.js"></script>
    
    <style>
        /* Mobile-specific styles */
        /* Body styling inherited from global.css */
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
        }

        .mobile-container {
            max-width: 100vw;
            padding: 10px;
            box-sizing: border-box;
        }

        .mobile-panel {
            background-color: #323c4e;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .mobile-panel-header {
            font-size: 12px;
            font-weight: bold;
            color: #c4c4c4;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Price Display */
        .price-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 0;
        }

        .price-info {
            flex: 1;
            text-align: left;
        }

        .current-price {
            font-size: 22px;
            font-weight: bold;
            color: white;
            margin-bottom: 4px;
        }

        .price-change {
            font-size: 10px;
            color: #c4c4c4;
        }

        .momentum-info {
            text-align: right;
            min-width: 80px;
        }

        .momentum-label {
            font-size: 10px;
            color: #c4c4c4;
            margin-bottom: 2px;
        }

        .momentum-score {
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        /* Control Toggles */
        .control-toggles {
            display: flex;
            gap: 16px;
            margin: 12px 0;
        }

        .toggle-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label {
            font-size: 12px;
            color: #ccc;
        }

        .mobile-toggle {
            width: 44px;
            height: 24px;
            background-color: #444;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mobile-toggle.active {
            background-color: #007bff;
        }

        .mobile-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .mobile-toggle.active::after {
            transform: translateX(20px);
        }

        /* Active Trades */
        .active-trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .active-trades-table th {
            background-color: #1e2733;
            padding: 8px 4px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
        }

        .active-trades-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #444;
        }

        .close-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
        }

        /* Strike Table */
        .strike-table-mobile {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .strike-table-mobile th {
            background-color: #1e2733;
            padding: 6px 2px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
        }

        .strike-table-mobile td {
            padding: 4px 2px;
            text-align: center;
            border: 1px solid #444;
        }

        /* Spanner row styling (same as main trade monitor) */
        .spanner-row {
            background-color: #2c3e50 !important;
        }

        .spanner-row td {
            text-align: center !important;
            background-color: #2c3e50 !important;
            color: #ecf0f1 !important;
            font-weight: bold !important;
            padding: 8px !important;
        }

        /* Risk-based color formatting (same as main trade monitor) */
        .ultra-safe { background-color: #58b558 !important; }
        .safe { background-color: #7ec27e !important; }
        .caution { background-color: #c5ab50 !important; }
        .high-risk { background-color: #a07777 !important; }

        .price-box-mobile {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #ccc;
            min-width: 40px;
            text-align: center;
        }

        .price-box-mobile:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .price-box-mobile.disabled {
            opacity: 0.1;
            pointer-events: none;
        }

        /* Risk colors */
        .ultra-safe { background-color: #58b558 !important; }
        .safe { background-color: #7ec27e !important; }
        .caution { background-color: #c5ab50 !important; }
        .high-risk { background-color: #a07777 !important; }
        .danger-stop { background-color: #ec3434 !important; }



        /* Empty state */
        .empty-state {
            text-align: center;
            color: #888;
            padding: 20px;
            font-size: 14px;
        }

        /* Top Row Layout */
        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
        }

        .market-title {
            flex: 1;
            padding: 8px;
            background-color: #323c4e;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* TTC Clock */
        .ttc-clock {
            background-color: #323c4e;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            min-width: 60px;
            text-align: center;
            white-space: nowrap;
        }

        .ttc-clock.urgent {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }

        .ttc-clock.warning {
            background-color: #ffc107;
            color: #000;
        }

        .ttc-clock.normal {
            background-color: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 375px) {
            .mobile-container {
                padding: 8px;
            }
            
            .top-row {
                gap: 8px;
            }
            
            .market-title {
                font-size: 12px;
                padding: 6px;
            }
            
            .ttc-clock {
                font-size: 10px;
                padding: 6px 8px;
                min-width: 50px;
            }
            
            .current-price {
                font-size: 18px;
              
            }
            
            .price-change {
                font-size: 9px;
                padding-top: 20px;
            }
            
            .momentum-score {
                font-size: 14px;
            }
            
            .momentum-label {
                font-size: 9px;
            }
            
            .strike-table-mobile {
                font-size: 10px;
            }
            
            .strike-table-mobile th,
            .strike-table-mobile td {
                padding: 3px 1px;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- Top Row: Market Title and TTC Clock -->
        <div class="top-row">
            <div class="market-title">BTC Price Today</div>
            <div class="ttc-clock" id="ttc-clock">--:--</div>
        </div>

        <!-- Price and Momentum Panel -->
        <div class="mobile-panel">
      
            <div class="price-display">
                <div class="price-info">
                    <div class="current-price" id="btc-price-value">$—</div>
                    <div class="price-change" id="btc-changes-cell" style="padding-top: 10px;">
                        1h <span id="change-1h">—</span> • 3h <span id="change-3h">—</span> • 1d <span id="change-1d">—</span>
                    </div>
                </div>
                <div class="momentum-info">
                    <div class="momentum-label">Momentum</div>
                    <div class="momentum-score" id="momentum-score-display">—</div>
                </div>
            </div>
        </div>

        <!-- Control Toggles -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Trading Controls</span>
            </div>
            <div class="control-toggles">
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoEntryToggle"></div>
                    <span class="toggle-label">Auto Entry</span>
                </div>
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoStopToggle"></div>
                    <span class="toggle-label">Auto Stop</span>
                </div>
            </div>
        </div>

        <!-- Active Trades -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Active Trades</span>
            </div>
            <table id="activeTradeSupervisorTable" class="active-trades-table">
                <thead>
                    <tr>
                        <th>Strike</th>
                        <th>Side</th>
                        <th>Buy</th>
                        <th>Pos</th>
                        <th>Close</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="5" class="empty-state">No active trades</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Strike Table -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Market</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 10px; color: #ccc;">+/-</span>
                    <div class="mobile-toggle" id="plusMinusToggle"></div>
                </div>
            </div>
            <table id="strike-table" class="strike-table-mobile">
                <thead>
                    <tr>
                        <th>STRIKE</th>
                        <th>BUFFER</th>
                        <th>%</th>
                        <th>Prob</th>
                        <th>YES</th>
                        <th>NO</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="6" class="empty-state">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Mobile-specific initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Mobile trade monitor initialized');
            
            // Initialize toggle controls
            initializeMobileToggles();
            
            // Start TTC clock
            startTTCClock();
            
            // Initial data fetches (same as main trade monitor)
            fetch('/core').then(response => response.json()).then(data => {
                // Update BTC price display
                if ('btc_price' in data) {
                    const price = Number(data.btc_price);
                    const priceEl = document.getElementById('btc-price-value');
                    if (priceEl) {
                        priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    }
                }
                
                // Update momentum score
                if (data.weighted_momentum_score !== undefined) {
                    const momentumEl = document.getElementById('momentum-score-display');
                    if (momentumEl) {
                        const score = data.weighted_momentum_score;
                        const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                        momentumEl.textContent = formatted;
                    }
                }
            }).catch(console.error);
            
            // Initial BTC price changes fetch
            fetch('/btc_price_changes').then(response => response.json()).then(data => {
                // Update price change displays
                if ('change1h' in data) {
                    const el = document.getElementById('change-1h');
                    if (el) {
                        const num = parseFloat(data.change1h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change3h' in data) {
                    const el = document.getElementById('change-3h');
                    if (el) {
                        const num = parseFloat(data.change3h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change1d' in data) {
                    const el = document.getElementById('change-1d');
                    if (el) {
                        const num = parseFloat(data.change1d);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
            }).catch(console.error);
            
            // Start data polling
            startMobileDataPolling();
        });

        function initializeMobileToggles() {
            // Auto Entry Toggle
            const autoEntryToggle = document.getElementById('autoEntryToggle');
            if (autoEntryToggle) {
                autoEntryToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_entry', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto entry setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto entry:', error);
                    }
                });
            }

            // Auto Stop Toggle
            const autoStopToggle = document.getElementById('autoStopToggle');
            if (autoStopToggle) {
                autoStopToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_stop', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto stop setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto stop:', error);
                    }
                });
            }

            // Plus/Minus Toggle
            const plusMinusToggle = document.getElementById('plusMinusToggle');
            if (plusMinusToggle) {
                plusMinusToggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const enabled = this.classList.contains('active');
                    
                    // Update backend
                    fetch('/api/set_diff_mode', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled })
                    }).catch(console.error);
                });
            }

            // Load initial toggle states
            loadToggleStates();
        }

        function startTTCClock() {
            async function updateTTCClock() {
                try {
                    // Use the same endpoint as the main trade monitor
                    const response = await fetch('/api/unified_ttc/btc');
                    if (!response.ok) {
                        throw new Error('Failed to fetch TTC data');
                    }
                    
                    const data = await response.json();
                    const ttcSeconds = data.ttc_seconds || 0;
                    
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        // Use the same formatTTC function as the main trade monitor
                        const formatTTC = (seconds) => {
                            if (seconds === null || seconds === undefined || isNaN(seconds)) {
                                return '--:--';
                            }
                            
                            const totalMinutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            
                            if (totalMinutes >= 60) {
                                const hours = Math.floor(totalMinutes / 60);
                                const minutes = totalMinutes % 60;
                                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            } else {
                                return `${totalMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            }
                        };
                        
                        ttcClock.textContent = formatTTC(ttcSeconds);
                        
                        // Apply the same color coding as the main trade monitor
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                        
                        if (ttcSeconds >= 0 && ttcSeconds <= 180) {
                            ttcClock.style.backgroundColor = '#d2372b';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 300) {
                            ttcClock.style.backgroundColor = '#ffc107';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 720) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 900) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        }
                    }
                } catch (error) {
                    console.error('Error updating TTC clock:', error);
                    // Fallback to show --:-- if API fails
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        ttcClock.textContent = '--:--';
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                    }
                }
            }
            
            // Update immediately and then every second (same as main trade monitor)
            updateTTCClock();
            setInterval(updateTTCClock, 1000);
        }

        async function loadToggleStates() {
            try {
                const response = await fetch('/api/get_preferences');
                const data = await response.json();
                
                // Set Auto Entry toggle
                const autoEntryToggle = document.getElementById('autoEntryToggle');
                if (autoEntryToggle) {
                    autoEntryToggle.classList.remove('active');
                    if (data.auto_entry === true) {
                        autoEntryToggle.classList.add('active');
                    }
                }
                
                // Set Auto Stop toggle
                const autoStopToggle = document.getElementById('autoStopToggle');
                if (autoStopToggle) {
                    autoStopToggle.classList.remove('active');
                    if (data.auto_stop === true) {
                        autoStopToggle.classList.add('active');
                    }
                }
                
                // Set Plus/Minus toggle
                const plusMinusToggle = document.getElementById('plusMinusToggle');
                if (plusMinusToggle) {
                    plusMinusToggle.classList.remove('active');
                    if (data.diff_mode === true) {
                        plusMinusToggle.classList.add('active');
                    }
                }
            } catch (error) {
                console.error('Error loading toggle states:', error);
            }
        }

        function startMobileDataPolling() {
            // Poll for core data (same as main trade monitor)
            setInterval(async () => {
                try {
                    // Fetch core data (BTC price + momentum) - same as main trade monitor
                    const coreResponse = await fetch('/core');
                    if (coreResponse.ok) {
                        const coreData = await coreResponse.json();
                        
                        // Update market title (same as main trade monitor)
                        const marketTitleEl = document.querySelector('.market-title');
                        if (marketTitleEl) {
                            // Fetch strike table data for market title (same as main trade monitor)
                            try {
                                const strikeResponse = await fetch('/api/strike_tables/btc');
                                if (strikeResponse.ok) {
                                    const strikeData = await strikeResponse.json();
                                    
                                    // Extract time from market_title (same logic as main trade monitor)
                                    const marketTitle = strikeData.market_title || '';
                                    const timeMatch = marketTitle.match(/at\s+(.+?)\s+(?:EDT|EST)\?/i);
                                    const timeStr = timeMatch ? timeMatch[1].trim() : '11pm';
                                    
                                    // Format as "<symbol> price today at <time>?" (same as main trade monitor)
                                    const symbol = strikeData.symbol || 'BTC';
                                    const formattedTitle = `${symbol} price today at ${timeStr}?`;
                                    
                                    marketTitleEl.textContent = formattedTitle;
                                }
                            } catch (error) {
                                console.error('Error updating market title:', error);
                                marketTitleEl.textContent = 'BTC Price Today';
                            }
                        }
                        
                        // Update BTC price display
                        if ('btc_price' in coreData) {
                            const price = Number(coreData.btc_price);
                            const priceEl = document.getElementById('btc-price-value');
                            if (priceEl) {
                                priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                            }
                        }
                        
                        // Update momentum score
                        if (coreData.weighted_momentum_score !== undefined) {
                            const momentumEl = document.getElementById('momentum-score-display');
                            if (momentumEl) {
                                const score = coreData.weighted_momentum_score;
                                const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                                momentumEl.textContent = formatted;
                            }
                        }
                    }

                    // Update active trades
                    await updateMobileActiveTrades();
                    
                    // Update strike table
                    await updateMobileStrikeTable();
                    
                } catch (error) {
                    console.error('Error in mobile data polling:', error);
                }
            }, 1000); // Poll every second (same as main trade monitor)

            // Poll for BTC price changes (same as main trade monitor)
            setInterval(async () => {
                try {
                    const res = await fetch('/btc_price_changes');
                    if (res.ok) {
                        const data = await res.json();
                        
                        // Update price change displays
                        if ('change1h' in data) {
                            const el = document.getElementById('change-1h');
                            if (el) {
                                const num = parseFloat(data.change1h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change3h' in data) {
                            const el = document.getElementById('change-3h');
                            if (el) {
                                const num = parseFloat(data.change3h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change1d' in data) {
                            const el = document.getElementById('change-1d');
                            if (el) {
                                const num = parseFloat(data.change1d);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching BTC price changes:', error);
                }
            }, 60000); // Poll every minute (same as main trade monitor)

            // Poll for toggle states every 5 seconds
            setInterval(async () => {
                try {
                    await loadToggleStates();
                } catch (error) {
                    console.error('Error refreshing toggle states:', error);
                }
            }, 5000); // Poll every 5 seconds
        }

        async function updateMobileActiveTrades() {
            try {
                // Use the same endpoint as the main trade monitor for active trades
                const response = await fetch('/api/active_trades');
                if (!response.ok) return;
                
                const trades = await response.json();
                const tbody = document.querySelector('#activeTradeSupervisorTable tbody');
                
                if (!tbody) return;
                
                if (!Array.isArray(trades) || trades.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="5" class="empty-state">No active trades</td></tr>';
                    return;
                }
                
                tbody.innerHTML = '';
                
                trades.forEach(trade => {
                    const row = document.createElement('tr');
                    const buyPrice = trade.buy_price ? (trade.buy_price / 100).toFixed(2) : '—';
                    const position = trade.position || '—';
                    const strike = trade.strike ? `$${parseFloat(trade.strike).toLocaleString()}` : '—';
                    const side = trade.side || '—';
                    
                    row.innerHTML = `
                        <td>${strike}</td>
                        <td>${side}</td>
                        <td>${buyPrice}</td>
                        <td>${position}</td>
                        <td><button class="close-btn" onclick="closeTrade(${trade.id}, event)">Close</button></td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
            } catch (error) {
                console.error('Error updating mobile active trades:', error);
            }
        }

        async function updateMobileStrikeTable() {
            try {
                // Use same endpoint as main trade monitor
                const response = await fetch('/api/strike_tables/btc');
                if (!response.ok) return;
                
                const data = await response.json();
                const tbody = document.querySelector('#strike-table tbody');
                
                if (!tbody || !data.strikes) return;
                
                tbody.innerHTML = '';
                
                // Sort strikes by value (lowest to highest)
                const sortedStrikes = data.strikes.sort((a, b) => parseFloat(a.strike) - parseFloat(b.strike));
                
                // Get current price
                const currentPrice = data.current_price || 0;
                const currentPriceFloat = parseFloat(currentPrice);
                
                // Filter strikes to show only 5 above and 5 below current price
                const filteredStrikes = [];
                
                // Find strikes below current price (up to 5)
                const strikesBelow = sortedStrikes
                    .filter(strike => parseFloat(strike.strike) < currentPriceFloat)
                    .slice(-5); // Take last 5 (closest to current price)
                
                // Find strikes above current price (up to 5)
                const strikesAbove = sortedStrikes
                    .filter(strike => parseFloat(strike.strike) > currentPriceFloat)
                    .slice(0, 5); // Take first 5 (closest to current price)
                
                // Combine and sort
                filteredStrikes.push(...strikesBelow, ...strikesAbove);
                filteredStrikes.sort((a, b) => parseFloat(a.strike) - parseFloat(b.strike));
                
                // Create data rows first
                const dataRows = [];
                filteredStrikes.forEach(strike => {
                    const row = document.createElement('tr');
                    const strikePrice = `$${parseFloat(strike.strike).toLocaleString()}`;
                    const buffer = strike.buffer ? Math.round(strike.buffer).toLocaleString() : '—';
                    const bufferPct = strike.buffer_pct ? strike.buffer_pct.toFixed(2) : '—';
                    const probability = strike.probability ? strike.probability.toFixed(1) : '—';
                    const yesPrice = strike.yes_ask ? strike.yes_ask.toString() : '—';
                    const noPrice = strike.no_ask ? strike.no_ask.toString() : '—';
                    
                    row.innerHTML = `
                        <td>${strikePrice}</td>
                        <td>${buffer}</td>
                        <td>${bufferPct}</td>
                        <td>${probability}</td>
                        <td><span class="price-box-mobile" onclick="openTrade(this, '${strike.strike}', 'Y', ${strike.yes_ask})">${yesPrice}</span></td>
                        <td><span class="price-box-mobile" onclick="openTrade(this, '${strike.strike}', 'N', ${strike.no_ask})">${noPrice}</span></td>
                    `;
                    
                    // Add risk-based color formatting (same as main trade monitor)
                    const prob = strike.probability;
                    if (prob) {
                        row.classList.remove('ultra-safe', 'safe', 'caution', 'high-risk', 'danger-stop');
                        let riskClass = '';
                        if (prob >= 98) riskClass = 'ultra-safe';
                        else if (prob >= 95) riskClass = 'safe';
                        else if (prob >= 80) riskClass = 'caution';
                        else riskClass = 'high-risk';
                        row.classList.add(riskClass);
                    }
                    
                    dataRows.push(row);
                });
                
                // Create spanner row with momentum arrows (same as main trade monitor)
                const spannerRow = document.createElement('tr');
                spannerRow.className = 'spanner-row';
                const spannerTd = document.createElement('td');
                spannerTd.colSpan = 6;
                
                // Get momentum score for arrows
                const momentumEl = document.getElementById('momentum-score-value');
                let momentumScore = 0;
                if (momentumEl && momentumEl.textContent) {
                    const val = parseFloat(momentumEl.textContent.replace(/[^\d\.\-]/g, ''));
                    momentumScore = isNaN(val) ? 0 : val;
                }
                
                // Create momentum arrows (same as main trade monitor)
                const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                
                let arrowBlock = '';
                const absMomentum = Math.abs(momentumScore);
                if (absMomentum < 5) {
                    arrowBlock = '-';
                } else if (absMomentum < 10) {
                    arrowBlock = momentumScore > 0 ? svgDown : svgUp;
                } else if (absMomentum < 20) {
                    arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(2);
                } else {
                    arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(3);
                }
                
                spannerTd.innerHTML = `<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>Current Price: $${Math.round(currentPrice).toLocaleString()}<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>`;
                spannerRow.appendChild(spannerTd);
                
                // Add data rows first
                dataRows.forEach(row => {
                    tbody.appendChild(row);
                });
                
                // Position spanner row correctly (same logic as main trade monitor)
                const allRows = Array.from(tbody.children).filter(row => !row.classList.contains('spanner-row'));
                let insertIndex = allRows.length; // default to end
                
                for (let i = 0; i < allRows.length; i++) {
                    const row = allRows[i];
                    const strikeCell = row.querySelector('td');
                    if (strikeCell && strikeCell.textContent) {
                        const strikeText = strikeCell.textContent.replace(/[\$,]/g, '');
                        const strike = parseFloat(strikeText);
                        if (!isNaN(strike) && currentPrice < strike) {
                            insertIndex = i;
                            break;
                        }
                    }
                }
                
                // Remove spanner row from current position and insert at correct position
                if (spannerRow.parentNode) {
                    spannerRow.remove();
                }
                
                if (insertIndex < allRows.length) {
                    tbody.insertBefore(spannerRow, allRows[insertIndex]);
                } else {
                    tbody.appendChild(spannerRow);
                }
                
            } catch (error) {
                console.error('Error updating mobile strike table:', error);
            }
        }

        // Trade execution functions
        function openTrade(element, strike, side, price) {
            if (element.disabled) return;
            
            element.disabled = true;
            
            // Visual feedback
            element.style.backgroundColor = '#007bff';
            element.style.color = 'white';
            
            setTimeout(() => {
                element.style.backgroundColor = '';
                element.style.color = '';
                element.disabled = false;
            }, 500);
            
            // Execute trade
            fetch('/api/trigger_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    strike: strike,
                    side: side,
                    price: price,
                    type: 'market'
                })
            }).catch(console.error);
        }

        function closeTrade(tradeId, event) {
            const btn = event.target;
            if (btn.disabled) return;
            
            btn.disabled = true;
            btn.textContent = 'Closing...';
            
            fetch('/api/trigger_close_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    trade_id: tradeId
                })
            }).then(() => {
                updateMobileActiveTrades();
            }).catch(console.error).finally(() => {
                btn.disabled = false;
                btn.textContent = 'Close';
            });
        }
    </script>
</body>
</html> 