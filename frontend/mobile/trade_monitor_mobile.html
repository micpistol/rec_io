<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trade Monitor Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../styles/global.css">
    <script src="../js/live-data.js"></script>
    <script src="../js/globals.js"></script>

    <script src="../js/trade-execution-controller.js"></script>
    

    
    <style>
        /* Mobile-specific styles */
        /* Body styling inherited from global.css */
        body {
            margin: 0;
            padding: 0;
            -webkit-text-size-adjust: 100%;
        }

        .mobile-container {
            max-width: 100vw;
            padding: 10px;
            box-sizing: border-box;
        }

        .mobile-panel {
            background-color: #323c4e;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .mobile-panel-header {
            font-size: 12px;
            font-weight: bold;
            color: #c4c4c4;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Price Display */
        .price-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0px 0;
        }

        .price-info {
            flex: 1;
            text-align: left;
        }

        .current-price {
            font-size: 22px;
            font-weight: bold;
            color: white;
            margin-bottom: 4px;
        }

        .price-change {
            font-size: 10px;
            color: #c4c4c4;
        }

        .momentum-info {
            text-align: right;
            min-width: 80px;
        }

        .momentum-label {
            font-size: 10px;
            color: #c4c4c4;
            margin-bottom: 2px;
        }

        .momentum-score {
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        /* Control Toggles */
        .control-toggles {
            display: flex;
            gap: 16px;
            margin: 12px 0;
        }

        .toggle-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label {
            font-size: 12px;
            color: #ccc;
        }

        .mobile-toggle {
            width: 44px;
            height: 24px;
            background-color: #444;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mobile-toggle.active {
            background-color: #007bff;
        }

        .mobile-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .mobile-toggle.active::after {
            transform: translateX(20px);
        }

        /* Active Trades */
        .active-trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .active-trades-table th {
            background-color: #1e2733;
            padding: 8px 4px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
        }

        .active-trades-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #444;
        }

        .close-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
        }

        /* Strike Table */
        .strike-table-mobile {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .strike-table-mobile th {
            background-color: #1e2733;
            padding: 6px 2px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
        }

        .strike-table-mobile td {
            padding: 4px 2px;
            text-align: center;
            border: 1px solid #444;
        }

        /* Active Trade Supervisor Table */
        .active-trade-supervisor-table-mobile {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .active-trade-supervisor-table-mobile th {
            background-color: #1e2733;
            padding: 6px 2px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
        }

        .active-trade-supervisor-table-mobile td {
            padding: 4px 2px;
            text-align: center;
            border: 1px solid #444;
        }

        /* Unified price button styling for both market and active trade supervisor */
        .price-box-mobile {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #ccc;
            min-width: 40px;
            text-align: center;
            background-color: transparent;
            transition: background-color 0.2s ease;
        }

        .price-box-mobile:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .price-box-mobile.disabled {
            opacity: 0.1;
            pointer-events: none;
        }

        /* Close button styling - identical to price buttons */
        .close-btn-mobile {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #ccc;
            min-width: 40px;
            text-align: center;
            background-color: transparent;
            transition: background-color 0.2s ease;
            color: white;
        }

        .close-btn-mobile:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .close-btn-mobile.disabled {
            opacity: 0.1;
            pointer-events: none;
        }

        /* Spanner row styling (exact match from desktop trade monitor) */
        tr.spanner-row td {
            background-color: #535668 !important;
            color: #c0c0c0 !important;
            text-align: center !important;
            font-size: 12px !important;
            font-style: italic !important;
            height: 25px !important;
            padding: 2px 4px !important;
        }

        /* Risk-based color formatting (same as main trade monitor) */
        .ultra-safe { background-color: #58b558 !important; }
        .safe { background-color: #7ec27e !important; }
        .caution { background-color: #c5ab50 !important; }
        .high-risk { background-color: #a07777 !important; }
        .danger-stop { background-color: #ec3434 !important; }

        /* Blue background for closing trades */
        .active-trade-supervisor-table-mobile tr.closing-trade {
            background-color: #1e3a8a !important;
        }
        .active-trade-supervisor-table-mobile tr.closing-trade td {
            background-color: #1e3a8a !important;
            color: #ffffff !important;
        }

        /* Active Trade Indicator for Strike Table */
        .strike-table-mobile td.has-active-trade {
            background-color: #1a2a1a !important; /* Very subtle green tint */
            border-left: 3px solid #45d34a !important; /* Green left border */
        }

        /* Multiplier Button Styles */
        .multiplier-btn {
            background-color: transparent;
            border: 1px solid #ccc;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-size: 10px;
        }
        .multiplier-btn.active {
            background-color: #007bff;
            border-color: #0056b3;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 6px rgba(0, 123, 255, 0.7);
        }
        .multiplier-btn:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            color: #888;
            padding: 20px;
            font-size: 14px;
        }

        /* Top Row Layout */
        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
        }

        .market-title {
            flex: 1;
            padding: 8px;
            background-color: #323c4e;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* TTC Clock */
        .ttc-clock {
            background-color: #323c4e;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            min-width: 60px;
            text-align: center;
            white-space: nowrap;
        }

        .ttc-clock.urgent {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }

        .ttc-clock.warning {
            background-color: #ffc107;
            color: #000;
        }

        .ttc-clock.normal {
            background-color: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 375px) {
            .mobile-container {
                padding: 8px;
            }
            
            .top-row {
                gap: 8px;
            }
            
            .market-title {
                font-size: 12px;
                padding: 6px;
            }
            
            .ttc-clock {
                font-size: 10px;
                padding: 6px 8px;
                min-width: 50px;
            }
            
            .current-price {
                font-size: 18px;
              
            }
            
            .price-change {
                font-size: 9px;
                padding-top: 10px;
            }
            
            .momentum-score {
                font-size: 14px;
            }
            
            .momentum-label {
                font-size: 9px;
            }
            
            .strike-table-mobile {
                font-size: 10px;
            }
            
            .strike-table-mobile th,
            .strike-table-mobile td {
                padding: 3px 1px;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- Top Row: Market Title and TTC Clock -->
        <div class="top-row">
            <div class="market-title">BTC Price Today</div>
            <div class="ttc-clock" id="ttc-clock">--:--</div>
        </div>

        <!-- Price and Momentum Panel -->
        <div class="mobile-panel">
      
            <div class="price-display">
                <div class="price-info">
                    <div class="current-price" id="btc-price-value">$—</div>
                    <div class="price-change" id="btc-changes-cell" style="padding-top: 10px;">
                        1h <span id="change-1h">—</span> • 3h <span id="change-3h">—</span> • 1d <span id="change-1d">—</span>
                    </div>
                </div>
                <div class="momentum-info">
                    <div class="momentum-label">Momentum</div>
                    <div class="momentum-score" id="momentum-score-display">—</div>
                </div>
            </div>
        </div>

        <!-- Control Toggles -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Trading Controls</span>
            </div>
            <div class="control-toggles">
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoEntryToggle"></div>
                    <span class="toggle-label">Auto Entry</span>
                </div>
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoStopToggle"></div>
                    <span class="toggle-label">Auto Stop</span>
                </div>
                <div class="toggle-group">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <input type="number" id="position-size" min="1" style="width: 45px; padding: 3px; text-align: right; font-size: 11px; border-radius: 3px; border: 1px solid #ccc; background-color: #323c4e; color: white;" />
                            <div style="display: flex; gap: 2px;">
                                <button class="multiplier-btn" data-multiplier="1">1x</button>
                                <button class="multiplier-btn" data-multiplier="2">2x</button>
                                <button class="multiplier-btn" data-multiplier="3">3x</button>
                            </div>
                        </div>
                        <div id="position-display" style="font-size: 10px; color: #ccc;">100 contracts</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Trade Supervisor Panel -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Active Trade Supervisor</span>
            </div>
            <table id="active-trade-supervisor-table" class="active-trade-supervisor-table-mobile">
                <thead>
                    <tr>
                        <th>Strike</th>
                        <th>Side</th>
                        <th>Buy</th>
                        <th>Pos</th>
                        <th>Buffer</th>
                        <th>Prob</th>
                        <th>Close</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="7" class="empty-state">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Strike Table -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Market</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 10px; color: #ccc;">+/-</span>
                    <div class="mobile-toggle" id="plusMinusToggle"></div>
                </div>
            </div>
            <table id="strike-table" class="strike-table-mobile">
                <thead>
                    <tr>
                        <th>STRIKE</th>
                        <th>BUFFER</th>
                        <th>%</th>
                        <th>Prob</th>
                        <th>YES</th>
                        <th>NO</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="6" class="empty-state">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Mobile-specific initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Mobile trade monitor initialized');
            
            // Initialize toggle controls
            initializeMobileToggles();
            
            // Initialize position controls
            initializePositionControls();
            
            // Start TTC clock
            startTTCClock();
            
            // Initial data fetches (same as main trade monitor)
            fetch('/core').then(response => response.json()).then(data => {
                // Update BTC price display
                if ('btc_price' in data) {
                    const price = Number(data.btc_price);
                    const priceEl = document.getElementById('btc-price-value');
                    if (priceEl) {
                        priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    }
                }
                
                // Update momentum score
                if (data.weighted_momentum_score !== undefined) {
                    const momentumEl = document.getElementById('momentum-score-display');
                    if (momentumEl) {
                        const score = data.weighted_momentum_score;
                        const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                        momentumEl.textContent = formatted;
                    }
                }
            }).catch(console.error);
            
            // Initial BTC price changes fetch
            fetch('/btc_price_changes').then(response => response.json()).then(data => {
                // Update price change displays
                if ('change1h' in data) {
                    const el = document.getElementById('change-1h');
                    if (el) {
                        const num = parseFloat(data.change1h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change3h' in data) {
                    const el = document.getElementById('change-3h');
                    if (el) {
                        const num = parseFloat(data.change3h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change1d' in data) {
                    const el = document.getElementById('change-1d');
                    if (el) {
                        const num = parseFloat(data.change1d);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
            }).catch(console.error);
            
            // Start data polling
            startMobileDataPolling();
            
            // Start Active Trade Supervisor polling
            startActiveTradeSupervisorPolling();
            
            // Start position indicator updates (separate from table redraws)
            setInterval(() => {
                updatePositionIndicatorsOnly();
            }, 2000); // Update every 2 seconds to reduce flashing
        });

        function initializeMobileToggles() {
            // Auto Entry Toggle
            const autoEntryToggle = document.getElementById('autoEntryToggle');
            if (autoEntryToggle) {
                autoEntryToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_entry', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto entry setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto entry:', error);
                    }
                });
            }

            // Auto Stop Toggle
            const autoStopToggle = document.getElementById('autoStopToggle');
            if (autoStopToggle) {
                autoStopToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_stop', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto stop setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto stop:', error);
                    }
                });
            }

            // Plus/Minus Toggle
            const plusMinusToggle = document.getElementById('plusMinusToggle');
            if (plusMinusToggle) {
                plusMinusToggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const enabled = this.classList.contains('active');
                    
                    // Update backend
                    fetch('/api/set_diff_mode', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled })
                    }).catch(console.error);
                });
            }

            // Load initial toggle states
            loadToggleStates();
        }

        function startTTCClock() {
            async function updateTTCClock() {
                try {
                    // Use the same endpoint as the main trade monitor
                    const response = await fetch('/api/unified_ttc/btc');
                    if (!response.ok) {
                        throw new Error('Failed to fetch TTC data');
                    }
                    
                    const data = await response.json();
                    const ttcSeconds = data.ttc_seconds || 0;
                    
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        // Use the same formatTTC function as the main trade monitor
                        const formatTTC = (seconds) => {
                            if (seconds === null || seconds === undefined || isNaN(seconds)) {
                                return '--:--';
                            }
                            
                            const totalMinutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            
                            if (totalMinutes >= 60) {
                                const hours = Math.floor(totalMinutes / 60);
                                const minutes = totalMinutes % 60;
                                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            } else {
                                return `${totalMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            }
                        };
                        
                        ttcClock.textContent = formatTTC(ttcSeconds);
                        
                        // Apply the same color coding as the main trade monitor
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                        
                        if (ttcSeconds >= 0 && ttcSeconds <= 180) {
                            ttcClock.style.backgroundColor = '#d2372b';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 300) {
                            ttcClock.style.backgroundColor = '#ffc107';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 720) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 900) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        }
                    }
                } catch (error) {
                    console.error('Error updating TTC clock:', error);
                    // Fallback to show --:-- if API fails
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        ttcClock.textContent = '--:--';
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                    }
                }
            }
            
            // Update immediately and then every second (same as main trade monitor)
            updateTTCClock();
            setInterval(updateTTCClock, 1000);
        }

        async function loadToggleStates() {
            try {
                const response = await fetch('/api/get_preferences');
                const data = await response.json();
                
                // Set Auto Entry toggle
                const autoEntryToggle = document.getElementById('autoEntryToggle');
                if (autoEntryToggle) {
                    autoEntryToggle.classList.remove('active');
                    if (data.auto_entry === true) {
                        autoEntryToggle.classList.add('active');
                    }
                }
                
                // Set Auto Stop toggle
                const autoStopToggle = document.getElementById('autoStopToggle');
                if (autoStopToggle) {
                    autoStopToggle.classList.remove('active');
                    if (data.auto_stop === true) {
                        autoStopToggle.classList.add('active');
                    }
                }
                
                // Set Plus/Minus toggle
                const plusMinusToggle = document.getElementById('plusMinusToggle');
                if (plusMinusToggle) {
                    plusMinusToggle.classList.remove('active');
                    if (data.diff_mode === true) {
                        plusMinusToggle.classList.add('active');
                    }
                }
                
                // Set Position Size and Multiplier
                const positionInput = document.getElementById('position-size');
                const multiplierButtons = document.querySelectorAll('.multiplier-btn');
                
                if (positionInput && data.position_size !== undefined) {
                    positionInput.value = data.position_size;
                }
                
                if (multiplierButtons.length && data.multiplier !== undefined) {
                    multiplierButtons.forEach(btn => {
                        if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
                
                updatePositionDisplay();
            } catch (error) {
                console.error('Error loading toggle states:', error);
            }
        }

        function updatePositionDisplay() {
            const positionInput = document.getElementById('position-size');
            const multiplierButtons = document.querySelectorAll('.multiplier-btn');
            const positionDisplay = document.getElementById('position-display');
            
            if (positionInput && positionDisplay) {
                const baseValue = parseInt(positionInput.value, 10) || 0;
                const activeMultiplier = Array.from(multiplierButtons).find(btn => btn.classList.contains('active'));
                const multiplier = activeMultiplier ? parseInt(activeMultiplier.dataset.multiplier, 10) : 1;
                const total = baseValue * multiplier;
                positionDisplay.textContent = `${total} contracts`;
            }
        }

        function initializePositionControls() {
            const positionInput = document.getElementById('position-size');
            const multiplierButtons = document.querySelectorAll('.multiplier-btn');
            
            // Position size input handler
            if (positionInput) {
                positionInput.addEventListener('change', async function() {
                    const value = parseInt(this.value, 10) || 100;
                    console.log('Position size changed to:', value);
                    
                    try {
                        const response = await fetch('/api/set_position_size', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ position_size: value })
                        });
                        
                        if (response.ok) {
                            updatePositionDisplay();
                        } else {
                            console.error('Failed to update position size');
                        }
                    } catch (error) {
                        console.error('Error updating position size:', error);
                    }
                });
            }
            
            // Multiplier button handlers
            multiplierButtons.forEach(btn => {
                btn.addEventListener('click', async function() {
                    const multiplier = parseInt(this.dataset.multiplier, 10);
                    console.log('Multiplier button clicked:', multiplier);
                    
                    // Update UI
                    multiplierButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    updatePositionDisplay();
                    
                    try {
                        const response = await fetch('/api/set_multiplier', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ multiplier })
                        });
                        
                        if (!response.ok) {
                            console.error('Failed to update multiplier');
                        }
                    } catch (error) {
                        console.error('Error updating multiplier:', error);
                    }
                });
            });
        }

        function startMobileDataPolling() {
            // Poll for core data (same as main trade monitor)
            setInterval(async () => {
                try {
                    // Fetch core data (BTC price + momentum) - same as main trade monitor
                    const coreResponse = await fetch('/core');
                    if (coreResponse.ok) {
                        const coreData = await coreResponse.json();
                        
                        // Update market title (same as main trade monitor)
                        const marketTitleEl = document.querySelector('.market-title');
                        if (marketTitleEl) {
                            // Fetch strike table data for market title (same as main trade monitor)
                            try {
                                const strikeResponse = await fetch('/api/strike_tables/btc');
                                if (strikeResponse.ok) {
                                    const strikeData = await strikeResponse.json();
                                    
                                    // Extract time from market_title (same logic as main trade monitor)
                                    const marketTitle = strikeData.market_title || '';
                                    const timeMatch = marketTitle.match(/at\s+(.+?)\s+(?:EDT|EST)\?/i);
                                    const timeStr = timeMatch ? timeMatch[1].trim() : '11pm';
                                    
                                    // Format as "<symbol> price today at <time>?" (same as main trade monitor)
                                    const symbol = strikeData.symbol || 'BTC';
                                    const formattedTitle = `${symbol} price today at ${timeStr}?`;
                                    
                                    marketTitleEl.textContent = formattedTitle;
                                }
                            } catch (error) {
                                console.error('Error updating market title:', error);
                                marketTitleEl.textContent = 'BTC Price Today';
                            }
                        }
                        
                        // Update BTC price display
                        if ('btc_price' in coreData) {
                            const price = Number(coreData.btc_price);
                            const priceEl = document.getElementById('btc-price-value');
                            if (priceEl) {
                                priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                            }
                        }
                        
                        // Update momentum score
                        if (coreData.weighted_momentum_score !== undefined) {
                            const momentumEl = document.getElementById('momentum-score-display');
                            if (momentumEl) {
                                const score = coreData.weighted_momentum_score;
                                const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                                momentumEl.textContent = formatted;
                            }
                        }
                    }


                    
                    // Update strike table
                    await updateMobileStrikeTable();
                    
                } catch (error) {
                    console.error('Error in mobile data polling:', error);
                }
            }, 1000); // Poll every second (same as main trade monitor)

            // Poll for BTC price changes (same as main trade monitor)
            setInterval(async () => {
                try {
                    const res = await fetch('/btc_price_changes');
                    if (res.ok) {
                        const data = await res.json();
                        
                        // Update price change displays
                        if ('change1h' in data) {
                            const el = document.getElementById('change-1h');
                            if (el) {
                                const num = parseFloat(data.change1h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change3h' in data) {
                            const el = document.getElementById('change-3h');
                            if (el) {
                                const num = parseFloat(data.change3h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change1d' in data) {
                            const el = document.getElementById('change-1d');
                            if (el) {
                                const num = parseFloat(data.change1d);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching BTC price changes:', error);
                }
            }, 60000); // Poll every minute (same as main trade monitor)

            // Poll for toggle states every 5 seconds
            setInterval(async () => {
                try {
                    await loadToggleStates();
                } catch (error) {
                    console.error('Error refreshing toggle states:', error);
                }
            }, 5000); // Poll every 5 seconds
        }



        // Mobile Strike Table - Using same efficient logic as desktop
        let mobileStrikeRowsMap = new Map(); // Track row elements like desktop version
        
        // Initialize mobile strike table once (like desktop)
        function initializeMobileStrikeTable(basePrice) {
            const strikeTableBody = document.querySelector('#strike-table tbody');
            if (!strikeTableBody) return;
            
            // Clear existing table
            strikeTableBody.innerHTML = '';
            mobileStrikeRowsMap.clear();
            
            // Build strikes around current price (5 above, 5 below)
            const strikes = [];
            for (let i = -5; i <= 5; i++) {
                strikes.push(basePrice + (i * 250));
            }
            
            strikes.forEach((strike, idx) => {
                const row = document.createElement('tr');
                
                // Strike cell
                const strikeTd = document.createElement('td');
                strikeTd.textContent = '$' + strike.toLocaleString();
                row.appendChild(strikeTd);
                
                // Buffer cell
                const bufferTd = document.createElement('td');
                row.appendChild(bufferTd);
                
                // Buffer % cell
                const bufferPctTd = document.createElement('td');
                row.appendChild(bufferPctTd);
                
                // Probability cell
                const probTd = document.createElement('td');
                row.appendChild(probTd);
                
                // Yes button cell and span
                const yesTd = document.createElement('td');
                const yesSpan = document.createElement('span');
                yesTd.appendChild(yesSpan);
                row.appendChild(yesTd);
                
                // No button cell and span
                const noTd = document.createElement('td');
                const noSpan = document.createElement('span');
                noTd.appendChild(noSpan);
                row.appendChild(noTd);
                
                strikeTableBody.appendChild(row);
                
                // Store row references (like desktop version)
                mobileStrikeRowsMap.set(strike, {
                    row,
                    bufferTd,
                    bufferPctTd,
                    probTd,
                    yesSpan,
                    noSpan
                });
            });
            
            // Add spanner row
            const spannerRow = createMobileSpannerRow();
            strikeTableBody.appendChild(spannerRow);
        }
        
        // Create spanner row for mobile
        function createMobileSpannerRow() {
            const spannerRow = document.createElement('tr');
            spannerRow.className = 'spanner-row';
            const spannerTd = document.createElement('td');
            spannerTd.colSpan = 6;
            spannerTd.textContent = 'Loading...';
            spannerRow.appendChild(spannerTd);
            return spannerRow;
        }
        
        // Update mobile strike table efficiently (like desktop)
        async function updateMobileStrikeTable() {
            try {
                const response = await fetch('/api/strike_tables/btc');
                if (!response.ok) return;
                
                const data = await response.json();
                if (!data.strikes) return;
                
                const currentPrice = data.current_price || 0;
                const currentPriceFloat = parseFloat(currentPrice);
                
                // Initialize table if needed
                if (mobileStrikeRowsMap.size === 0) {
                    const base = Math.round(currentPriceFloat / 250) * 250;
                    initializeMobileStrikeTable(base);
                }
                
                // Update each strike row with data (like desktop)
                mobileStrikeRowsMap.forEach((cells, strike) => {
                    const { row, bufferTd, bufferPctTd, probTd, yesSpan, noSpan } = cells;
                    
                    // Find matching strike data
                    const strikeData = data.strikes.find(s => parseFloat(s.strike) === strike);
                    
                    if (strikeData) {
                        // Update buffer
                        const buffer = strikeData.buffer ? Math.round(strikeData.buffer).toLocaleString() : '—';
                        bufferTd.textContent = buffer;
                        
                        // Update buffer %
                        const bufferPct = strikeData.buffer_pct ? strikeData.buffer_pct.toFixed(2) : '—';
                        bufferPctTd.textContent = bufferPct;
                        
                        // Update probability
                        const probability = strikeData.probability ? strikeData.probability.toFixed(1) : '—';
                        probTd.textContent = probability;
                        
                        // Risk-based color formatting
                        const prob = strikeData.probability;
                        if (prob) {
                            row.classList.remove('ultra-safe', 'safe', 'caution', 'high-risk', 'danger-stop');
                            let riskClass = '';
                            if (prob >= 98) riskClass = 'ultra-safe';
                            else if (prob >= 95) riskClass = 'safe';
                            else if (prob >= 80) riskClass = 'caution';
                            else riskClass = 'high-risk';
                            row.classList.add(riskClass);
                        }
                        
                        // Update Yes/No buttons
                        const yesAsk = strikeData.yes_ask;
                        const noAsk = strikeData.no_ask;
                        const volume = strikeData.volume;
                        
                        // Check if DIFF MODE is enabled
                        const plusMinusToggle = document.getElementById('plusMinusToggle');
                        const isDiffMode = plusMinusToggle && plusMinusToggle.classList.contains('active');
                        
                        // Determine display values
                        let yesPrice = '—';
                        let noPrice = '—';
                        
                        if (yesAsk && yesAsk !== '—' && yesAsk !== 0) {
                            if (isDiffMode && strikeData.yes_diff !== null && strikeData.yes_diff !== undefined) {
                                yesPrice = strikeData.yes_diff > 0 ? `+${Math.round(strikeData.yes_diff)}` : `${Math.round(strikeData.yes_diff)}`;
                            } else {
                                yesPrice = yesAsk.toString();
                            }
                        }
                        
                        if (noAsk && noAsk !== '—' && noAsk !== 0) {
                            if (isDiffMode && strikeData.no_diff !== null && strikeData.no_diff !== undefined) {
                                noPrice = strikeData.no_diff > 0 ? `+${Math.round(strikeData.no_diff)}` : `${Math.round(strikeData.no_diff)}`;
                            } else {
                                noPrice = noAsk.toString();
                            }
                        }
                        
                        // Apply enable/disable logic
                        const volumeNum = parseInt(volume) || 0;
                        const volumeOk = volumeNum >= 1000;
                        const yesPriceOk = yesAsk && yesAsk <= 98;
                        const noPriceOk = noAsk && noAsk <= 98;
                        const isAboveMoneyLine = strike > currentPriceFloat;
                        
                        let yesEnabled = false;
                        let noEnabled = false;
                        
                        if (volumeOk) {
                            if (isAboveMoneyLine) {
                                noEnabled = noPriceOk;
                                yesEnabled = false;
                            } else {
                                yesEnabled = yesPriceOk;
                                noEnabled = false;
                            }
                        }
                        
                        // Update button classes and content
                        yesSpan.className = yesEnabled ? 'price-box-mobile' : 'price-box-mobile disabled';
                        noSpan.className = noEnabled ? 'price-box-mobile' : 'price-box-mobile disabled';
                        yesSpan.textContent = yesPrice;
                        noSpan.textContent = noPrice;
                        
                        // Set data attributes (SAME AS DESKTOP)
                        const ticker = strikeData.ticker || 'BTC-USD'; // Get ticker from strike data
                        
                        // Set data-ticker on the YES/NO cell's parent td (for reference, if needed)
                        if (yesSpan.parentElement && ticker) {
                            yesSpan.parentElement.setAttribute('data-ticker', ticker);
                        }
                        if (noSpan.parentElement && ticker) {
                            noSpan.parentElement.setAttribute('data-ticker', ticker);
                        }
                        
                        // Also set data-ticker directly on spanEl for easier access in openTrade
                        if (ticker) {
                            yesSpan.setAttribute('data-ticker', ticker);
                            noSpan.setAttribute('data-ticker', ticker);
                        }
                        
                        // Set data-strike and data-side for easier retrieval in openTrade
                        yesSpan.setAttribute('data-strike', strike);
                        noSpan.setAttribute('data-strike', strike);
                        yesSpan.setAttribute('data-side', 'Y');
                        noSpan.setAttribute('data-side', 'N');
                        
                        // Store the actual ask price for trade execution (not the display value)
                        if (yesAsk && yesAsk !== '—' && yesAsk !== 0) {
                            yesSpan.setAttribute('data-ask-price', yesAsk);
                        } else {
                            yesSpan.removeAttribute('data-ask-price');
                        }
                        
                        if (noAsk && noAsk !== '—' && noAsk !== 0) {
                            noSpan.setAttribute('data-ask-price', noAsk);
                        } else {
                            noSpan.removeAttribute('data-ask-price');
                        }
                        
                        // Add click handlers
                        if (yesEnabled) {
                            yesSpan.onclick = () => handleStrikeTableButtonClick(yesSpan);
                        } else {
                            yesSpan.onclick = null;
                        }
                        
                        if (noEnabled) {
                            noSpan.onclick = () => handleStrikeTableButtonClick(noSpan);
                        } else {
                            noSpan.onclick = null;
                        }
                        
                        // Update position indicator
                        const strikeCell = row.querySelector('td:first-child');
                        if (strikeCell) {
                            updatePositionIndicator(strikeCell, strike);
                        }
                    } else {
                        // No data for this strike, show placeholders
                        bufferTd.textContent = '—';
                        bufferPctTd.textContent = '—';
                        probTd.textContent = '—';
                        yesSpan.textContent = '—';
                        noSpan.textContent = '—';
                        yesSpan.className = 'price-box-mobile disabled';
                        noSpan.className = 'price-box-mobile disabled';
                    }
                });
                
                // Update spanner row with current price and momentum
                updateMobileSpannerRow(currentPriceFloat);
                
            } catch (error) {
                console.error('Error updating mobile strike table:', error);
            }
        }
        
        // Update spanner row with current price and momentum
        function updateMobileSpannerRow(currentPrice) {
            const spannerRow = document.querySelector('#strike-table tbody .spanner-row');
            if (!spannerRow) return;
            
            const spannerTd = spannerRow.querySelector('td');
            if (!spannerTd) return;
            
            // Get momentum score for arrows
            const momentumEl = document.getElementById('momentum-score-display');
            let momentumScore = 0;
            if (momentumEl && momentumEl.textContent) {
                const val = parseFloat(momentumEl.textContent.replace(/[^\d\.\-]/g, ''));
                momentumScore = isNaN(val) ? 0 : val;
            }
            
            // Create momentum arrows
            const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            
            let arrowBlock = '';
            const absMomentum = Math.abs(momentumScore);
            if (absMomentum < 5) {
                arrowBlock = '-';
            } else if (absMomentum < 10) {
                arrowBlock = momentumScore > 0 ? svgDown : svgUp;
            } else if (absMomentum < 20) {
                arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(2);
            } else {
                arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(3);
            }
            
            spannerTd.innerHTML = `<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>Current Price: $${Math.round(currentPrice).toLocaleString()}<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>`;
            
            // Position spanner row correctly
            const allRows = Array.from(document.querySelector('#strike-table tbody').children).filter(row => !row.classList.contains('spanner-row'));
            let insertIndex = allRows.length;
            
            for (let i = 0; i < allRows.length; i++) {
                const row = allRows[i];
                const strikeCell = row.querySelector('td');
                if (strikeCell && strikeCell.textContent) {
                    const strikeText = strikeCell.textContent.replace(/[\$,]/g, '');
                    const strike = parseFloat(strikeText);
                    if (!isNaN(strike) && currentPrice < strike) {
                        insertIndex = i;
                        break;
                    }
                }
            }
            
            // Remove spanner row from current position and insert at correct position
            if (spannerRow.parentNode) {
                spannerRow.remove();
            }
            
            if (insertIndex < allRows.length) {
                document.querySelector('#strike-table tbody').insertBefore(spannerRow, allRows[insertIndex]);
            } else {
                document.querySelector('#strike-table tbody').appendChild(spannerRow);
            }
        }

        // Trade execution functions
        function openTrade(element, strike, side, price) {
            if (element.disabled) return;
            
            element.disabled = true;
            
            // Visual feedback
            element.style.backgroundColor = '#007bff';
            element.style.color = 'white';
            
            setTimeout(() => {
                element.style.backgroundColor = '';
                element.style.color = '';
                element.disabled = false;
            }, 500);
            
            // Execute trade
            fetch('/api/trigger_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    strike: strike,
                    side: side,
                    price: price,
                    type: 'market'
                })
            }).catch(console.error);
        }

        // === EXACT SAME TRADE EXECUTION AS DESKTOP ===
        // This replicates the desktop strike table button behavior exactly
        
        async function prepareTradeData(target) {
            // 🎧 Sound confirmation - IMMEDIATE
            if (typeof playSound === 'function') {
                playSound('open');
            }
            
            // ✅ Add UI popup
            if (typeof showTradeOpenedPopup === 'function') {
                showTradeOpenedPopup();
            }
            
            if (target?.disabled) {
                return null;
            }
            
            // Get the actual ask price from data attribute (not the display text)
            const askPrice = target?.dataset?.askPrice;
            
            let buy_price = 0;
            if (askPrice) {
                // Convert from cents to dollars (e.g., "96" becomes 0.96)
                buy_price = parseFloat(askPrice) / 100;
            }
            
            // Get position size from mobile controls
            const posInput = document.getElementById('position-size');
            const rawBasePos = posInput ? parseInt(posInput.value, 10) : NaN;
            const validBase = Number.isFinite(rawBasePos) && rawBasePos > 0 ? rawBasePos : null;
            
            const multiplierBtn = document.querySelector('.multiplier-btn.active');
            const multiplier = multiplierBtn ? parseInt(multiplierBtn.dataset.multiplier, 10) : 1;
            
            const position = validBase !== null ? validBase * multiplier : null;
            
            const contract = 'BTC Market'; // Mobile uses simplified market title
            
            // Get strike and side from button context
            let strike = null;
            let side = null;
            let row = target.closest('tr');
            
            if (row) {
                const strikeCell = row.querySelector('td');
                if (strikeCell) {
                    strike = parseFloat(strikeCell.textContent.replace(/\$|,/g, ''));
                }
                
                // Determine side based on which button was clicked
                if (target.classList.contains('yes-button') || target.textContent.includes('YES')) {
                    side = 'Y';
                } else if (target.classList.contains('no-button') || target.textContent.includes('NO')) {
                    side = 'N';
                } else {
                    // Fallback: determine from button position in row
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 6) {
                        const yesCell = cells[4]; // YES column
                        const noCell = cells[5];  // NO column
                        if (target.closest('td') === yesCell) {
                            side = 'Y';
                        } else if (target.closest('td') === noCell) {
                            side = 'N';
                        }
                    }
                }
            }
            
            if (!strike || !side) {
                console.error('Could not determine strike or side from button context');
                return null;
            }
            
            // Get ticker from strike table data (SAME AS DESKTOP)
            let kalshiTicker = null;
            if (strike) {
                // Get ticker from the strike table data for this specific strike
                const strikeFormatted = '$' + Number(strike).toLocaleString();
                const strikeTableRows = document.querySelectorAll('#strike-table tbody tr');
                
                for (const row of strikeTableRows) {
                    const firstTd = row.querySelector('td');
                    if (!firstTd) continue;
                    const firstTdText = firstTd.textContent.trim();
                    
                    if (firstTdText === strikeFormatted) {
                        // Get ticker from the button's data attribute
                        const yesButton = row.querySelector('.price-box-mobile:not(.disabled)');
                        if (yesButton && yesButton.dataset.ticker) {
                            kalshiTicker = yesButton.dataset.ticker;
                        } else {
                            const noButton = row.querySelector('.price-box-mobile:not(.disabled)');
                            if (noButton && noButton.dataset.ticker) {
                                kalshiTicker = noButton.dataset.ticker;
                            }
                        }
                        break;
                    }
                }
            }
            
            // Fallback to default if no ticker found
            if (!kalshiTicker) {
                kalshiTicker = 'BTC-USD';
            }
            
            // Get current BTC price
            const symbol_open = typeof getCurrentBTCTickerPrice === 'function' ? getCurrentBTCTickerPrice() : null;
            
            // Get momentum from API
            let momentum = null;
            try {
                const momentumResponse = await fetch('/api/momentum');
                if (momentumResponse.ok) {
                    const momentumData = await momentumResponse.json();
                    momentum = momentumData.momentum_score;
                }
            } catch (error) {
                console.error('Failed to fetch momentum from API:', error);
            }
            
            // Get probability from the strike table
            let prob = null;
            if (strike) {
                const strikeFormatted = '$' + Number(strike).toLocaleString();
                const strikeTableRows = document.querySelectorAll('#strike-table tbody tr');
                
                for (const row of strikeTableRows) {
                    const firstTd = row.querySelector('td');
                    if (!firstTd) continue;
                    const firstTdText = firstTd.textContent.trim();
                    
                    if (firstTdText === strikeFormatted) {
                        const tds = row.querySelectorAll('td');
                        if (tds.length > 3) {
                            const probText = tds[3].textContent.trim(); // Prob column
                            if (probText && probText !== '—') {
                                prob = probText;
                            }
                        }
                        break;
                    }
                }
            }
            
            if (!prob) {
                console.error('Could not determine probability for strike:', strike);
                return null;
            }
            
            const tradeData = {
                symbol: 'BTC',
                contract: contract,
                strike: `$${Number(strike).toLocaleString()}`,
                side: side,
                ticker: kalshiTicker,
                buy_price: buy_price,
                position: position,
                symbol_open: symbol_open,
                momentum: momentum,
                prob: prob,
                trade_strategy: "Hourly HTC",
                entry_method: "manual"
            };
            
            return tradeData;
        }
        
        // === EXACT SAME BUTTON CLICK HANDLER AS DESKTOP ===
        async function handleStrikeTableButtonClick(spanEl) {
            try {
                const tradeData = await prepareTradeData(spanEl); // Use the same function as desktop
                
                if (!tradeData) {
                    console.error('Missing trade data for strike table button after prepareTradeData');
                    return;
                }
                
                // Call the EXACT SAME endpoint as desktop
                const response = await fetch('/api/trigger_open_trade', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        strike: tradeData.strike,
                        side: tradeData.side,
                        ticker: tradeData.ticker,
                        buy_price: tradeData.buy_price,
                        prob: tradeData.prob,
                        symbol_open: tradeData.symbol_open,
                        momentum: tradeData.momentum,
                        contract: tradeData.contract,
                        symbol: tradeData.symbol,
                        position: tradeData.position,
                        trade_strategy: tradeData.trade_strategy
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Strike table trade initiated successfully:', result);
                    
                    // Refresh panels to show new trade (same as desktop)
                    if (typeof fetchAndRenderActiveTradeSupervisorTrades === 'function') {
                        fetchAndRenderActiveTradeSupervisorTrades();
                    }
                } else {
                    console.error('Strike table trade initiation failed:', response.status);
                }
            } catch (error) {
                console.error('Error initiating strike table trade:', error);
            }
        }

        // === UPDATED CLOSE TRADE FUNCTION FOR MOBILE ===
        async function closeActiveTrade(tradeId, ticketId) {
            try {
                console.log('[ACTIVE TRADE SUPERVISOR] Attempting to close trade:', tradeId);
                
                // 🎧 Sound confirmation - IMMEDIATE (same as desktop)
                if (typeof playSound === 'function') {
                    playSound('close');
                }
                
                // ✅ Add UI popup (same as desktop)
                if (typeof showTradeClosedPopup === 'function') {
                    showTradeClosedPopup();
                }
                
                // Get current BTC price for sell price (same as desktop)
                const currentPrice = typeof getCurrentBTCTickerPrice === 'function' ? getCurrentBTCTickerPrice() : 0.5;
                console.log('[ACTIVE TRADE SUPERVISOR] Current price for close:', currentPrice);
                
                // Use the EXACT SAME endpoint as desktop
                const response = await fetch('/api/trigger_close_trade', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        trade_id: tradeId,
                        sell_price: currentPrice
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('[ACTIVE TRADE SUPERVISOR] Close trade completed successfully:', result);
                    
                    // Refresh panels (same as desktop)
                    if (typeof fetchAndRenderActiveTradeSupervisorTrades === 'function') {
                        fetchAndRenderActiveTradeSupervisorTrades();
                    }
                } else {
                    console.error('[ACTIVE TRADE SUPERVISOR] Close trade failed:', response.status);
                }
            } catch (error) {
                console.error(`[ACTIVE TRADE SUPERVISOR] Error closing trade ${tradeId}:`, error);
            }
        }

        // Active Trade Supervisor functionality
        let activeTradeSupervisorRowsMap = new Map();

        // Active Trade Indicator for Strike Table
        let lastActiveTrades = new Set(); // Track last known active trades to avoid unnecessary updates
        
        // Separate function to update only position indicators without redrawing table
        async function updatePositionIndicatorsOnly() {
            try {
                // Fetch active trades to check for positions
                const tradesRes = await fetch('/trades', { cache: 'no-store' });
                if (!tradesRes.ok) return;
                
                const trades = await tradesRes.json();
                const activeTrades = trades.filter(trade => 
                    trade.status !== "closed" && 
                    trade.status !== "expired"
                );
                
                // Create a set of current active trade strikes
                const currentActiveStrikes = new Set();
                activeTrades.forEach(trade => {
                    const tradeStrike = parseFloat(trade.strike.replace(/[^\d.-]/g, ''));
                    currentActiveStrikes.add(tradeStrike);
                });
                
                // Check if active trades have changed
                const tradesChanged = !setsAreEqual(lastActiveTrades, currentActiveStrikes);
                if (!tradesChanged) return; // No change, skip update
                
                // Update all strike cells
                const strikeCells = document.querySelectorAll('#strike-table tbody tr td:first-child');
                strikeCells.forEach(cell => {
                    const strikeText = cell.textContent.replace(/[\$,]/g, '');
                    const strike = parseFloat(strikeText);
                    if (!isNaN(strike)) {
                        const hasPosition = currentActiveStrikes.has(strike);
                        const currentlyHasIndicator = cell.classList.contains('has-active-trade');
                        
                        if (hasPosition !== currentlyHasIndicator) {
                            if (hasPosition) {
                                cell.classList.add('has-active-trade');
                            } else {
                                cell.classList.remove('has-active-trade');
                            }
                        }
                    }
                });
                
                // Update last known state
                lastActiveTrades = currentActiveStrikes;
            } catch (e) {
                console.error('Error updating position indicators:', e);
            }
        }
        
        // Helper function to compare sets
        function setsAreEqual(set1, set2) {
            if (set1.size !== set2.size) return false;
            for (const item of set1) {
                if (!set2.has(item)) return false;
            }
            return true;
        }
        
        async function updatePositionIndicator(strikeCell, strike) {
            try {
                // Fetch active trades to check for positions at this strike
                const tradesRes = await fetch('/trades', { cache: 'no-store' });
                if (!tradesRes.ok) return;
                
                const trades = await tradesRes.json();
                const activeTrades = trades.filter(trade => 
                    trade.status !== "closed" && 
                    trade.status !== "expired"
                );
                
                // Create a set of current active trade strikes for comparison
                const currentActiveStrikes = new Set();
                activeTrades.forEach(trade => {
                    const tradeStrike = parseFloat(trade.strike.replace(/[^\d.-]/g, ''));
                    currentActiveStrikes.add(tradeStrike);
                });
                
                // Check if any active trade has this strike
                const hasPosition = currentActiveStrikes.has(strike);
                
                // Only update if the state has actually changed
                const currentlyHasIndicator = strikeCell.classList.contains('has-active-trade');
                if (hasPosition !== currentlyHasIndicator) {
                    if (hasPosition) {
                        strikeCell.classList.add('has-active-trade');
                    } else {
                        strikeCell.classList.remove('has-active-trade');
                    }
                }
                
                // Update last known state
                lastActiveTrades = currentActiveStrikes;
            } catch (e) {
                strikeCell.classList.remove('has-active-trade');
            }
        }

        async function fetchAndRenderActiveTradeSupervisorTrades() {
            try {
                // Get the active trade supervisor service URL
                let activeTradeSupervisorUrl;
                try {
                    // Try to use the same port configuration as desktop
                    if (typeof getActiveTradeSupervisorUrl === 'function') {
                        activeTradeSupervisorUrl = getActiveTradeSupervisorUrl('/api/active_trades');
                    } else {
                        // Fallback to hardcoded URL
                        activeTradeSupervisorUrl = `http://${window.location.hostname}:6000/api/active_trades`;
                    }
                } catch (error) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Port configuration error:', error);
                    // Fallback to hardcoded URL
                    activeTradeSupervisorUrl = `http://${window.location.hostname}:6000/api/active_trades`;
                }
                
                // Fetch active trades from the supervisor service
                const response = await fetch(activeTradeSupervisorUrl, { cache: 'no-store' });
                
                if (!response.ok) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Failed to fetch active trades:', response.status);
                    return;
                }
                
                const data = await response.json();
                
                if (!data.active_trades || !Array.isArray(data.active_trades)) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Invalid data format:', data);
                    return;
                }
                
                // Render the trades
                renderActiveTradeSupervisorTrades(data.active_trades);
                
            } catch (error) {
                console.error('[ACTIVE TRADE SUPERVISOR] Error fetching trades:', error);
            }
        }

        function renderActiveTradeSupervisorTrades(activeTrades) {
            const tableBody = document.querySelector('#active-trade-supervisor-table tbody');
            if (!tableBody) {
                console.error('[ACTIVE TRADE SUPERVISOR] Table body not found!');
                return;
            }
            
            // Clear any existing "Loading..." or empty state rows first
            const loadingRows = tableBody.querySelectorAll('tr');
            loadingRows.forEach(row => {
                const firstCell = row.querySelector('td');
                if (firstCell && (firstCell.textContent === 'Loading...' || firstCell.textContent === 'No active trades')) {
                    row.remove();
                }
            });
            
            // Sort trades by strike price in ascending order
            activeTrades.sort((a, b) => {
                const strikeA = parseFloat(a.strike.toString().replace(/[\$,]/g, ''));
                const strikeB = parseFloat(b.strike.toString().replace(/[\$,]/g, ''));
                return strikeA - strikeB;
            });
            
            // Remove rows for trades that no longer exist
            const activeTradeIds = new Set(activeTrades.map(trade => trade.trade_id));
            
            for (const [tradeId, rowObj] of activeTradeSupervisorRowsMap.entries()) {
                if (!activeTradeIds.has(tradeId)) {
                    if (rowObj.tr && rowObj.tr.parentNode === tableBody) {
                        tableBody.removeChild(rowObj.tr);
                    }
                    activeTradeSupervisorRowsMap.delete(tradeId);
                }
            }

            // Remove all existing spanner rows before rendering trade rows
            tableBody.querySelectorAll('.spanner-row').forEach(row => row.remove());

            // Render each active trade
            activeTrades.forEach((trade, idx) => {
                const tradeId = trade.trade_id;
                
                // Check if we already have a row for this trade
                let rowObj = activeTradeSupervisorRowsMap.get(tradeId);
                
                if (!rowObj) {
                    const row = document.createElement("tr");
                    
                    // Strike
                    const strikeCell = document.createElement("td");
                    strikeCell.textContent = trade.strike;
                    row.appendChild(strikeCell);
                    
                    // Side
                    const sideCell = document.createElement("td");
                    sideCell.textContent = trade.side;
                    row.appendChild(sideCell);
                    
                    // Buy (price)
                    const priceCell = document.createElement("td");
                    priceCell.textContent = (typeof trade.buy_price === "number")
                        ? trade.buy_price.toFixed(2)
                        : trade.buy_price;
                    row.appendChild(priceCell);
                    
                    // Position
                    const posCell = document.createElement("td");
                    posCell.textContent = trade.position ?? "";
                    row.appendChild(posCell);
                    
                    // Buffer (from active_trades.db)
                    const bufferCell = document.createElement("td");
                    if (trade.buffer_from_entry !== null) {
                        const buffer = trade.buffer_from_entry;
                        bufferCell.textContent = buffer.toLocaleString(undefined, {maximumFractionDigits: 0});
                        
                        // Apply risk color classes based on probability
                        if (trade.current_probability !== null && trade.current_probability !== undefined) {
                            const prob = trade.current_probability;
                            if (prob >= 95) row.classList.add('ultra-safe');
                            else if (prob >= 80) row.classList.add('safe');
                            else if (prob >= 50) row.classList.add('caution');
                            else if (prob >= 25) row.classList.add('high-risk');
                            else row.classList.add('danger-stop');
                        }
                    } else {
                        bufferCell.textContent = "N/A";
                    }
                    row.appendChild(bufferCell);
                    
                    // Probability (from active_trades.db)
                    const probCell = document.createElement("td");
                    if (trade.current_probability !== null) {
                        probCell.textContent = trade.current_probability.toFixed(1);
                    } else {
                        probCell.textContent = "N/A";
                    }
                    row.appendChild(probCell);
                    
                    // Close button with PnL display - using same styling as price buttons
                    const closeCell = document.createElement("td");
                    closeCell.style.textAlign = "center";
                    const closeSpan = document.createElement("span");
                    closeSpan.className = "close-btn-mobile";
                    closeSpan.dataset.tradeId = trade.trade_id;
                    closeSpan.dataset.action = "close";
                    closeSpan.style.cursor = "pointer";
                    closeSpan.onclick = () => closeActiveTrade(trade.trade_id, trade.ticket_id);
                    
                    // Display PnL if available, otherwise show "Close"
                    if (trade.current_pnl !== null && trade.current_pnl !== undefined) {
                        const pnl = parseFloat(trade.current_pnl);
                        if (!isNaN(pnl)) {
                            // Format PnL with white text
                            const pnlText = pnl >= 0 ? `+${pnl.toFixed(2)}` : pnl.toFixed(2);
                            closeSpan.textContent = pnlText;
                            closeSpan.style.color = "white";
                        } else {
                            closeSpan.textContent = "Close";
                            closeSpan.style.color = "white";
                        }
                    } else {
                        closeSpan.textContent = "Close";
                        closeSpan.style.color = "white";
                    }
                    
                    closeCell.appendChild(closeSpan);
                    row.appendChild(closeCell);
                    
                    // Store the row object
                    rowObj = { tr: row };
                    activeTradeSupervisorRowsMap.set(tradeId, rowObj);
                    
                    // Apply status-based styling
                    if (trade.status === 'closing') {
                        row.classList.add('closing-trade');
                    }
                    
                    // Add the row to the table
                    tableBody.appendChild(row);
                } else {
                    // Update existing row with new data
                    const row = rowObj.tr;
                    const cells = row.querySelectorAll('td');
                    
                    // Update buffer
                    if (cells.length > 4 && trade.buffer_from_entry !== null) {
                        const buffer = trade.buffer_from_entry;
                        cells[4].textContent = buffer.toLocaleString(undefined, {maximumFractionDigits: 0});
                        
                        // Update risk color classes based on probability
                        row.classList.remove('ultra-safe', 'safe', 'caution', 'high-risk', 'danger-stop');
                        if (trade.current_probability !== null && trade.current_probability !== undefined) {
                            const prob = trade.current_probability;
                            if (prob >= 95) row.classList.add('ultra-safe');
                            else if (prob >= 80) row.classList.add('safe');
                            else if (prob >= 50) row.classList.add('caution');
                            else if (prob >= 25) row.classList.add('high-risk');
                            else row.classList.add('danger-stop');
                        }
                    }
                    
                    // Update probability
                    if (cells.length > 5 && trade.current_probability !== null) {
                        cells[5].textContent = trade.current_probability.toFixed(1);
                    }
                    
                    // Update status-based styling
                    row.classList.remove('closing-trade');
                    if (trade.status === 'closing') {
                        row.classList.add('closing-trade');
                    }
                    
                    // Update PnL on close button
                    if (cells.length > 6 && trade.current_pnl !== null && trade.current_pnl !== undefined) {
                        const closeButton = cells[6].querySelector('.close-btn-mobile');
                        if (closeButton) {
                            const pnl = parseFloat(trade.current_pnl);
                            if (!isNaN(pnl)) {
                                const pnlText = pnl >= 0 ? `+${pnl.toFixed(2)}` : pnl.toFixed(2);
                                closeButton.textContent = pnlText;
                                closeButton.style.color = "white";
                            } else {
                                closeButton.textContent = "Close";
                                closeButton.style.color = "white";
                            }
                        }
                    }
                }
            });

            // Add spanner row logic
            if (activeTrades.length === 0) {
                // No active trades - show "No active trades" message
                const spannerRow = document.createElement("tr");
                spannerRow.className = "spanner-row";
                const spannerCell = document.createElement("td");
                spannerCell.colSpan = 7;
                spannerCell.textContent = "No active trades";
                spannerRow.appendChild(spannerCell);
                tableBody.appendChild(spannerRow);
            } else {
                // There are active trades - add current price spanner row
                // Try to get current BTC price, with fallback
                let currentBTCPrice = null;
                
                // Try to get current price from the market strike table's spanner row
                const marketSpannerRow = document.querySelector('#strike-table .spanner-row');
                if (marketSpannerRow) {
                    const spannerText = marketSpannerRow.textContent;
                    const priceMatch = spannerText.match(/Current Price: \$([\d,]+)/);
                    if (priceMatch) {
                        currentBTCPrice = parseFloat(priceMatch[1].replace(/,/g, ''));
                    }
                }
                
                // If we don't have a current price, try to get it from the first trade's strike as a fallback
                if (currentBTCPrice === null || currentBTCPrice === "" || isNaN(currentBTCPrice)) {
                    if (activeTrades.length > 0 && activeTrades[0].strike) {
                        // Use the first trade's strike as a rough estimate
                        currentBTCPrice = parseFloat(activeTrades[0].strike.toString().replace(/[\$,]/g, ''));
                    }
                }
                
                if (currentBTCPrice !== null && currentBTCPrice !== "" && !isNaN(currentBTCPrice)) {
                    const spannerRow = createActiveTradeSupervisorSpannerRow(currentBTCPrice);
                    
                    // Find the correct position to insert the spanner row
                    const allRows = Array.from(tableBody.children);
                    let insertIndex = allRows.length; // default to end
                    
                    for (let i = 0; i < allRows.length; i++) {
                        const row = allRows[i];
                        if (row.classList.contains('spanner-row')) continue;
                        const strikeCell = row.querySelector('td');
                        if (strikeCell) {
                            const strike = parseFloat(strikeCell.textContent.replace(/[\$,]/g, ''));
                            if (currentBTCPrice < strike) {
                                insertIndex = i;
                                break;
                            }
                        }
                    }
                    
                    if (insertIndex < allRows.length) {
                        tableBody.insertBefore(spannerRow, allRows[insertIndex]);
                    } else {
                        tableBody.appendChild(spannerRow);
                    }
                }
            }
        }

        function startActiveTradeSupervisorPolling() {
            // Initial load
            fetchAndRenderActiveTradeSupervisorTrades();
            
            // Set up periodic refresh (every 1 second - same as desktop)
            setInterval(() => {
                fetchAndRenderActiveTradeSupervisorTrades();
            }, 1000);
        }

        // Spanner Row Helper for Active Trade Supervisor
        function createActiveTradeSupervisorSpannerRow(currentPrice) {
            const spannerRow = document.createElement("tr");
            spannerRow.className = "spanner-row";
            const spannerTd = document.createElement("td");
            spannerTd.colSpan = 7; // Match the number of columns in active trade supervisor table
            
            // SVGs for straight arrows (no margin)
            const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            
            // Helper to get current momentum score from DOM
            function getCurrentMomentumScoreForArrow() {
                const el = document.getElementById('momentum-score-display');
                if (el && el.textContent) {
                    const val = parseFloat(el.textContent.replace(/[^\d\.\-]/g, ''));
                    return isNaN(val) ? 0 : val;
                }
                return 0;
            }
            
            let momentumScore = getCurrentMomentumScoreForArrow();
            let arrowBlock = '';
            const absMomentum = Math.abs(momentumScore);
            if (absMomentum < 5) {
                arrowBlock = '-';
            } else if (absMomentum < 10) {
                arrowBlock = momentumScore > 0 ? svgDown : svgUp;
            } else if (absMomentum < 20) {
                arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(2);
            } else {
                arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(3);
            }
            
            spannerTd.innerHTML = `<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>Current Price: $${Math.round(currentPrice).toLocaleString()}<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>`;
            spannerRow.appendChild(spannerTd);
            return spannerRow;
        }

        // === HELPER FUNCTIONS (SAME AS DESKTOP) ===
        
        // Get current BTC price for trade execution
        function getCurrentBTCTickerPrice() {
            const priceEl = document.getElementById('btc-price-value');
            if (priceEl && priceEl.textContent) {
                const priceText = priceEl.textContent.replace(/[\$,]/g, '');
                const price = parseFloat(priceText);
                return isNaN(price) ? 0.5 : price;
            }
            return 0.5; // Fallback price
        }
        
        // Play sound for trade confirmation
        function playSound(type) {
            if (type === 'open') {
                // Play open trade sound
                const audio = new Audio('../audio/sfx/open_trade_confirmation.wav');
                audio.play().catch(console.error);
            } else if (type === 'close') {
                // Play close trade sound
                const audio = new Audio('../audio/sfx/close_trade_confirmation.wav');
                audio.play().catch(console.error);
            }
        }
        
        // Show trade opened popup (same as desktop)
        function showTradeOpenedPopup() {
            // Create a simple popup notification
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: #28a745;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            popup.textContent = 'Trade Opened!';
            document.body.appendChild(popup);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 3000);
        }
        
        // Show trade closed popup (same as desktop)
        function showTradeClosedPopup() {
            // Create a simple popup notification
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: #dc3545;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            popup.textContent = 'Trade Closed!';
            document.body.appendChild(popup);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 3000);
        }
    </script>
</body>
</html> 