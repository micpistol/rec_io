<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trade Monitor Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="../styles/global.css">
    <script src="../js/live-data.js"></script>
    <script src="../js/globals.js"></script>

    <script src="../js/trade-execution-controller.js"></script>
    

    
    <style>
        /* Mobile-specific styles */
        /* Body styling inherited from global.css */
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            -webkit-text-size-adjust: 100%;
        }

        .mobile-container {
            max-width: 100vw;
            padding: 10px;
            box-sizing: border-box;
        }

        .mobile-panel {
            background-color: #323c4e;
            border-radius: 6px;
            margin-bottom: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .mobile-panel-header {
            font-size: 12px;
            font-weight: bold;
            color: #c4c4c4;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Price Display */
        .price-display {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0px 0;
        }

        .price-info {
            flex: 1;
            text-align: left;
        }

        .current-price {
            font-size: 22px;
            font-weight: bold;
            color: white;
            margin-bottom: 4px;
        }

        .price-change {
            font-size: 10px;
            color: #c4c4c4;
        }

        .momentum-info {
            text-align: right;
            min-width: 80px;
        }

        .momentum-label {
            font-size: 10px;
            color: #c4c4c4;
            margin-bottom: 2px;
        }

        .momentum-score {
            font-size: 16px;
            font-weight: bold;
            color: white;
        }

        /* Control Toggles */
        .control-toggles {
            display: flex;
            gap: 16px;
            margin: 12px 0;
        }

        .toggle-group {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label {
            font-size: 12px;
            color: #ccc;
        }

        .mobile-toggle {
            width: 44px;
            height: 24px;
            background-color: #444;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mobile-toggle.active {
            background-color: #007bff;
        }

        .mobile-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .mobile-toggle.active::after {
            transform: translateX(20px);
        }

        /* Active Trades */
        .active-trades-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .active-trades-table th {
            background-color: #1e2733;
            padding: 8px 4px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
        }

        .active-trades-table td {
            padding: 6px 4px;
            text-align: center;
            border-bottom: 1px solid #444;
        }

        .close-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
        }

        /* Strike Table */
        .strike-table-mobile {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .strike-table-mobile th {
            background-color: #1e2733;
            padding: 6px 2px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
        }

        .strike-table-mobile td {
            padding: 4px 2px;
            text-align: center;
            border: 1px solid #444;
        }

        /* Active Trade Supervisor Table */
        .active-trade-supervisor-table-mobile {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }

        .active-trade-supervisor-table-mobile th {
            background-color: #1e2733;
            padding: 6px 2px;
            text-align: center;
            font-size: 10px;
            font-weight: 600;
        }

        .active-trade-supervisor-table-mobile td {
            padding: 4px 2px;
            text-align: center;
            border: 1px solid #444;
        }

        /* Unified price button styling for both market and active trade supervisor */
        .price-box-mobile {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #ccc;
            min-width: 40px;
            text-align: center;
            background-color: transparent;
            transition: background-color 0.2s ease;
        }

        .price-box-mobile:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .price-box-mobile.disabled {
            opacity: 0.1;
            pointer-events: none;
        }

        /* Close button styling - identical to price buttons */
        .close-btn-mobile {
            display: inline-block;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            border: 1px solid #ccc;
            min-width: 40px;
            text-align: center;
            background-color: transparent;
            transition: background-color 0.2s ease;
            color: white;
        }

        .close-btn-mobile:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .close-btn-mobile.disabled {
            opacity: 0.1;
            pointer-events: none;
        }

        /* Spanner row styling (exact match from desktop trade monitor) */
        tr.spanner-row td {
            background-color: #535668 !important;
            color: #c0c0c0 !important;
            text-align: center !important;
            font-size: 12px !important;
            font-style: italic !important;
            height: 25px !important;
            padding: 2px 4px !important;
        }

        /* Risk-based color formatting (same as main trade monitor) */
        .ultra-safe { background-color: #58b558 !important; }
        .safe { background-color: #7ec27e !important; }
        .caution { background-color: #c5ab50 !important; }
        .high-risk { background-color: #a07777 !important; }
        .danger-stop { background-color: #ec3434 !important; }

        /* Blue background for closing trades */
        .active-trade-supervisor-table-mobile tr.closing-trade {
            background-color: #1e3a8a !important;
        }
        .active-trade-supervisor-table-mobile tr.closing-trade td {
            background-color: #1e3a8a !important;
            color: #ffffff !important;
        }

        /* Multiplier Button Styles */
        .multiplier-btn {
            background-color: transparent;
            border: 1px solid #ccc;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-size: 10px;
        }
        .multiplier-btn.active {
            background-color: #007bff;
            border-color: #0056b3;
            color: white;
            font-weight: bold;
            box-shadow: 0 0 6px rgba(0, 123, 255, 0.7);
        }
        .multiplier-btn:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            color: #888;
            padding: 20px;
            font-size: 14px;
        }

        /* Top Row Layout */
        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
        }

        .market-title {
            flex: 1;
            padding: 8px;
            background-color: #323c4e;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* TTC Clock */
        .ttc-clock {
            background-color: #323c4e;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            min-width: 60px;
            text-align: center;
            white-space: nowrap;
        }

        .ttc-clock.urgent {
            background-color: #dc3545;
            animation: pulse 1s infinite;
        }

        .ttc-clock.warning {
            background-color: #ffc107;
            color: #000;
        }

        .ttc-clock.normal {
            background-color: #28a745;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 375px) {
            .mobile-container {
                padding: 8px;
            }
            
            .top-row {
                gap: 8px;
            }
            
            .market-title {
                font-size: 12px;
                padding: 6px;
            }
            
            .ttc-clock {
                font-size: 10px;
                padding: 6px 8px;
                min-width: 50px;
            }
            
            .current-price {
                font-size: 18px;
              
            }
            
            .price-change {
                font-size: 9px;
                padding-top: 10px;
            }
            
            .momentum-score {
                font-size: 14px;
            }
            
            .momentum-label {
                font-size: 9px;
            }
            
            .strike-table-mobile {
                font-size: 10px;
            }
            
            .strike-table-mobile th,
            .strike-table-mobile td {
                padding: 3px 1px;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- Top Row: Market Title and TTC Clock -->
        <div class="top-row">
            <div class="market-title">BTC Price Today</div>
            <div class="ttc-clock" id="ttc-clock">--:--</div>
        </div>

        <!-- Price and Momentum Panel -->
        <div class="mobile-panel">
      
            <div class="price-display">
                <div class="price-info">
                    <div class="current-price" id="btc-price-value">$—</div>
                    <div class="price-change" id="btc-changes-cell" style="padding-top: 10px;">
                        1h <span id="change-1h">—</span> • 3h <span id="change-3h">—</span> • 1d <span id="change-1d">—</span>
                    </div>
                </div>
                <div class="momentum-info">
                    <div class="momentum-label">Momentum</div>
                    <div class="momentum-score" id="momentum-score-display">—</div>
                </div>
            </div>
        </div>

        <!-- Control Toggles -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Trading Controls</span>
            </div>
            <div class="control-toggles">
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoEntryToggle"></div>
                    <span class="toggle-label">Auto Entry</span>
                </div>
                <div class="toggle-group">
                    <div class="mobile-toggle" id="autoStopToggle"></div>
                    <span class="toggle-label">Auto Stop</span>
                </div>
                <div class="toggle-group">
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <input type="number" id="position-size" min="1" style="width: 45px; padding: 3px; text-align: right; font-size: 11px; border-radius: 3px; border: 1px solid #ccc; background-color: #323c4e; color: white;" />
                            <div style="display: flex; gap: 2px;">
                                <button class="multiplier-btn" data-multiplier="1">1x</button>
                                <button class="multiplier-btn" data-multiplier="2">2x</button>
                                <button class="multiplier-btn" data-multiplier="3">3x</button>
                            </div>
                        </div>
                        <div id="position-display" style="font-size: 10px; color: #ccc;">100 contracts</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Active Trade Supervisor Panel -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Active Trade Supervisor</span>
            </div>
            <table id="active-trade-supervisor-table" class="active-trade-supervisor-table-mobile">
                <thead>
                    <tr>
                        <th>Strike</th>
                        <th>Side</th>
                        <th>Buy</th>
                        <th>Pos</th>
                        <th>Buffer</th>
                        <th>Prob</th>
                        <th>Close</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="7" class="empty-state">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Strike Table -->
        <div class="mobile-panel">
            <div class="mobile-panel-header">
                <span>Market</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 10px; color: #ccc;">+/-</span>
                    <div class="mobile-toggle" id="plusMinusToggle"></div>
                </div>
            </div>
            <table id="strike-table" class="strike-table-mobile">
                <thead>
                    <tr>
                        <th>STRIKE</th>
                        <th>BUFFER</th>
                        <th>%</th>
                        <th>Prob</th>
                        <th>YES</th>
                        <th>NO</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td colspan="6" class="empty-state">Loading...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Mobile-specific initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Mobile trade monitor initialized');
            
            // Initialize toggle controls
            initializeMobileToggles();
            
            // Initialize position controls
            initializePositionControls();
            
            // Start TTC clock
            startTTCClock();
            
            // Initial data fetches (same as main trade monitor)
            fetch('/core').then(response => response.json()).then(data => {
                // Update BTC price display
                if ('btc_price' in data) {
                    const price = Number(data.btc_price);
                    const priceEl = document.getElementById('btc-price-value');
                    if (priceEl) {
                        priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                    }
                }
                
                // Update momentum score
                if (data.weighted_momentum_score !== undefined) {
                    const momentumEl = document.getElementById('momentum-score-display');
                    if (momentumEl) {
                        const score = data.weighted_momentum_score;
                        const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                        momentumEl.textContent = formatted;
                    }
                }
            }).catch(console.error);
            
            // Initial BTC price changes fetch
            fetch('/btc_price_changes').then(response => response.json()).then(data => {
                // Update price change displays
                if ('change1h' in data) {
                    const el = document.getElementById('change-1h');
                    if (el) {
                        const num = parseFloat(data.change1h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change3h' in data) {
                    const el = document.getElementById('change-3h');
                    if (el) {
                        const num = parseFloat(data.change3h);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
                if ('change1d' in data) {
                    const el = document.getElementById('change-1d');
                    if (el) {
                        const num = parseFloat(data.change1d);
                        if (!isNaN(num)) {
                            const triangle = num >= 0 ? " ▲" : " ▼";
                            el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                            el.style.color = "#fff";
                            el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                            el.style.padding = "2px 6px";
                            el.style.borderRadius = "4px";
                            el.style.display = "inline-block";
                        }
                    }
                }
            }).catch(console.error);
            
            // Start data polling
            startMobileDataPolling();
            
            // Start Active Trade Supervisor polling
            startActiveTradeSupervisorPolling();
        });

        function initializeMobileToggles() {
            // Auto Entry Toggle
            const autoEntryToggle = document.getElementById('autoEntryToggle');
            if (autoEntryToggle) {
                autoEntryToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_entry', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto entry setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto entry:', error);
                    }
                });
            }

            // Auto Stop Toggle
            const autoStopToggle = document.getElementById('autoStopToggle');
            if (autoStopToggle) {
                autoStopToggle.addEventListener('click', async function() {
                    const enabled = !this.classList.contains('active');
                    
                    try {
                        const response = await fetch('/api/set_auto_stop', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ enabled })
                        });
                        
                        if (response.ok) {
                            this.classList.toggle('active');
                        } else {
                            console.error('Failed to update auto stop setting');
                        }
                    } catch (error) {
                        console.error('Error updating auto stop:', error);
                    }
                });
            }

            // Plus/Minus Toggle
            const plusMinusToggle = document.getElementById('plusMinusToggle');
            if (plusMinusToggle) {
                plusMinusToggle.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const enabled = this.classList.contains('active');
                    
                    // Update backend
                    fetch('/api/set_diff_mode', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled })
                    }).catch(console.error);
                });
            }

            // Load initial toggle states
            loadToggleStates();
        }

        function startTTCClock() {
            async function updateTTCClock() {
                try {
                    // Use the same endpoint as the main trade monitor
                    const response = await fetch('/api/unified_ttc/btc');
                    if (!response.ok) {
                        throw new Error('Failed to fetch TTC data');
                    }
                    
                    const data = await response.json();
                    const ttcSeconds = data.ttc_seconds || 0;
                    
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        // Use the same formatTTC function as the main trade monitor
                        const formatTTC = (seconds) => {
                            if (seconds === null || seconds === undefined || isNaN(seconds)) {
                                return '--:--';
                            }
                            
                            const totalMinutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            
                            if (totalMinutes >= 60) {
                                const hours = Math.floor(totalMinutes / 60);
                                const minutes = totalMinutes % 60;
                                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            } else {
                                return `${totalMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
                            }
                        };
                        
                        ttcClock.textContent = formatTTC(ttcSeconds);
                        
                        // Apply the same color coding as the main trade monitor
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                        
                        if (ttcSeconds >= 0 && ttcSeconds <= 180) {
                            ttcClock.style.backgroundColor = '#d2372b';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 300) {
                            ttcClock.style.backgroundColor = '#ffc107';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 720) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        } else if (ttcSeconds <= 900) {
                            ttcClock.style.backgroundColor = '#45d34a';
                            ttcClock.style.color = '#fff';
                            ttcClock.style.borderRadius = '6px';
                            ttcClock.style.padding = '0 10px';
                        }
                    }
                } catch (error) {
                    console.error('Error updating TTC clock:', error);
                    // Fallback to show --:-- if API fails
                    const ttcClock = document.getElementById('ttc-clock');
                    if (ttcClock) {
                        ttcClock.textContent = '--:--';
                        ttcClock.style.backgroundColor = '';
                        ttcClock.style.color = '';
                        ttcClock.style.borderRadius = '';
                        ttcClock.style.padding = '';
                    }
                }
            }
            
            // Update immediately and then every second (same as main trade monitor)
            updateTTCClock();
            setInterval(updateTTCClock, 1000);
        }

        async function loadToggleStates() {
            try {
                const response = await fetch('/api/get_preferences');
                const data = await response.json();
                
                // Set Auto Entry toggle
                const autoEntryToggle = document.getElementById('autoEntryToggle');
                if (autoEntryToggle) {
                    autoEntryToggle.classList.remove('active');
                    if (data.auto_entry === true) {
                        autoEntryToggle.classList.add('active');
                    }
                }
                
                // Set Auto Stop toggle
                const autoStopToggle = document.getElementById('autoStopToggle');
                if (autoStopToggle) {
                    autoStopToggle.classList.remove('active');
                    if (data.auto_stop === true) {
                        autoStopToggle.classList.add('active');
                    }
                }
                
                // Set Plus/Minus toggle
                const plusMinusToggle = document.getElementById('plusMinusToggle');
                if (plusMinusToggle) {
                    plusMinusToggle.classList.remove('active');
                    if (data.diff_mode === true) {
                        plusMinusToggle.classList.add('active');
                    }
                }
                
                // Set Position Size and Multiplier
                const positionInput = document.getElementById('position-size');
                const multiplierButtons = document.querySelectorAll('.multiplier-btn');
                
                if (positionInput && data.position_size !== undefined) {
                    positionInput.value = data.position_size;
                }
                
                if (multiplierButtons.length && data.multiplier !== undefined) {
                    multiplierButtons.forEach(btn => {
                        if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                }
                
                updatePositionDisplay();
            } catch (error) {
                console.error('Error loading toggle states:', error);
            }
        }

        function updatePositionDisplay() {
            const positionInput = document.getElementById('position-size');
            const multiplierButtons = document.querySelectorAll('.multiplier-btn');
            const positionDisplay = document.getElementById('position-display');
            
            if (positionInput && positionDisplay) {
                const baseValue = parseInt(positionInput.value, 10) || 0;
                const activeMultiplier = Array.from(multiplierButtons).find(btn => btn.classList.contains('active'));
                const multiplier = activeMultiplier ? parseInt(activeMultiplier.dataset.multiplier, 10) : 1;
                const total = baseValue * multiplier;
                positionDisplay.textContent = `${total} contracts`;
            }
        }

        function initializePositionControls() {
            const positionInput = document.getElementById('position-size');
            const multiplierButtons = document.querySelectorAll('.multiplier-btn');
            
            // Position size input handler
            if (positionInput) {
                positionInput.addEventListener('change', async function() {
                    const value = parseInt(this.value, 10) || 100;
                    console.log('Position size changed to:', value);
                    
                    try {
                        const response = await fetch('/api/set_position_size', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ position_size: value })
                        });
                        
                        if (response.ok) {
                            updatePositionDisplay();
                        } else {
                            console.error('Failed to update position size');
                        }
                    } catch (error) {
                        console.error('Error updating position size:', error);
                    }
                });
            }
            
            // Multiplier button handlers
            multiplierButtons.forEach(btn => {
                btn.addEventListener('click', async function() {
                    const multiplier = parseInt(this.dataset.multiplier, 10);
                    console.log('Multiplier button clicked:', multiplier);
                    
                    // Update UI
                    multiplierButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    updatePositionDisplay();
                    
                    try {
                        const response = await fetch('/api/set_multiplier', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ multiplier })
                        });
                        
                        if (!response.ok) {
                            console.error('Failed to update multiplier');
                        }
                    } catch (error) {
                        console.error('Error updating multiplier:', error);
                    }
                });
            });
        }

        function startMobileDataPolling() {
            // Poll for core data (same as main trade monitor)
            setInterval(async () => {
                try {
                    // Fetch core data (BTC price + momentum) - same as main trade monitor
                    const coreResponse = await fetch('/core');
                    if (coreResponse.ok) {
                        const coreData = await coreResponse.json();
                        
                        // Update market title (same as main trade monitor)
                        const marketTitleEl = document.querySelector('.market-title');
                        if (marketTitleEl) {
                            // Fetch strike table data for market title (same as main trade monitor)
                            try {
                                const strikeResponse = await fetch('/api/strike_tables/btc');
                                if (strikeResponse.ok) {
                                    const strikeData = await strikeResponse.json();
                                    
                                    // Extract time from market_title (same logic as main trade monitor)
                                    const marketTitle = strikeData.market_title || '';
                                    const timeMatch = marketTitle.match(/at\s+(.+?)\s+(?:EDT|EST)\?/i);
                                    const timeStr = timeMatch ? timeMatch[1].trim() : '11pm';
                                    
                                    // Format as "<symbol> price today at <time>?" (same as main trade monitor)
                                    const symbol = strikeData.symbol || 'BTC';
                                    const formattedTitle = `${symbol} price today at ${timeStr}?`;
                                    
                                    marketTitleEl.textContent = formattedTitle;
                                }
                            } catch (error) {
                                console.error('Error updating market title:', error);
                                marketTitleEl.textContent = 'BTC Price Today';
                            }
                        }
                        
                        // Update BTC price display
                        if ('btc_price' in coreData) {
                            const price = Number(coreData.btc_price);
                            const priceEl = document.getElementById('btc-price-value');
                            if (priceEl) {
                                priceEl.textContent = `$${price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                            }
                        }
                        
                        // Update momentum score
                        if (coreData.weighted_momentum_score !== undefined) {
                            const momentumEl = document.getElementById('momentum-score-display');
                            if (momentumEl) {
                                const score = coreData.weighted_momentum_score;
                                const formatted = score >= 0 ? `+${(score * 100).toFixed(0)}` : `${(score * 100).toFixed(0)}`;
                                momentumEl.textContent = formatted;
                            }
                        }
                    }


                    
                    // Update strike table
                    await updateMobileStrikeTable();
                    
                } catch (error) {
                    console.error('Error in mobile data polling:', error);
                }
            }, 1000); // Poll every second (same as main trade monitor)

            // Poll for BTC price changes (same as main trade monitor)
            setInterval(async () => {
                try {
                    const res = await fetch('/btc_price_changes');
                    if (res.ok) {
                        const data = await res.json();
                        
                        // Update price change displays
                        if ('change1h' in data) {
                            const el = document.getElementById('change-1h');
                            if (el) {
                                const num = parseFloat(data.change1h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change3h' in data) {
                            const el = document.getElementById('change-3h');
                            if (el) {
                                const num = parseFloat(data.change3h);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                        if ('change1d' in data) {
                            const el = document.getElementById('change-1d');
                            if (el) {
                                const num = parseFloat(data.change1d);
                                if (!isNaN(num)) {
                                    const triangle = num >= 0 ? " ▲" : " ▼";
                                    el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
                                    el.style.color = "#fff";
                                    el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
                                    el.style.padding = "2px 6px";
                                    el.style.borderRadius = "4px";
                                    el.style.display = "inline-block";
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching BTC price changes:', error);
                }
            }, 60000); // Poll every minute (same as main trade monitor)

            // Poll for toggle states every 5 seconds
            setInterval(async () => {
                try {
                    await loadToggleStates();
                } catch (error) {
                    console.error('Error refreshing toggle states:', error);
                }
            }, 5000); // Poll every 5 seconds
        }



        async function updateMobileStrikeTable() {
            try {
                // Use same endpoint as main trade monitor
                const response = await fetch('/api/strike_tables/btc');
                if (!response.ok) return;
                
                const data = await response.json();
                const tbody = document.querySelector('#strike-table tbody');
                
                if (!tbody || !data.strikes) return;
                
                tbody.innerHTML = '';
                
                // Sort strikes by value (lowest to highest)
                const sortedStrikes = data.strikes.sort((a, b) => parseFloat(a.strike) - parseFloat(b.strike));
                
                // Get current price
                const currentPrice = data.current_price || 0;
                const currentPriceFloat = parseFloat(currentPrice);
                
                // Filter strikes to show only 5 above and 5 below current price
                const filteredStrikes = [];
                
                // Find strikes below current price (up to 5)
                const strikesBelow = sortedStrikes
                    .filter(strike => parseFloat(strike.strike) < currentPriceFloat)
                    .slice(-5); // Take last 5 (closest to current price)
                
                // Find strikes above current price (up to 5)
                const strikesAbove = sortedStrikes
                    .filter(strike => parseFloat(strike.strike) > currentPriceFloat)
                    .slice(0, 5); // Take first 5 (closest to current price)
                
                // Combine and sort
                filteredStrikes.push(...strikesBelow, ...strikesAbove);
                filteredStrikes.sort((a, b) => parseFloat(a.strike) - parseFloat(b.strike));
                
                // Create data rows first
                const dataRows = [];
                filteredStrikes.forEach(strike => {
                    const row = document.createElement('tr');
                    const strikePrice = `$${parseFloat(strike.strike).toLocaleString()}`;
                    const buffer = strike.buffer ? Math.round(strike.buffer).toLocaleString() : '—';
                    const bufferPct = strike.buffer_pct ? strike.buffer_pct.toFixed(2) : '—';
                    const probability = strike.probability ? strike.probability.toFixed(1) : '—';
                    // Check if DIFF MODE is enabled
                    const plusMinusToggle = document.getElementById('plusMinusToggle');
                    const isDiffMode = plusMinusToggle && plusMinusToggle.classList.contains('active');
                    
                    // Determine display values based on mode (same logic as desktop)
                    let yesPrice = '—';
                    let noPrice = '—';
                    
                    if (strike.yes_ask && strike.yes_ask !== '—' && strike.yes_ask !== 0) {
                        if (isDiffMode && strike.yes_diff !== null && strike.yes_diff !== undefined) {
                            // DIFF MODE: Show pre-calculated diff value (no decimals)
                            yesPrice = strike.yes_diff > 0 ? `+${Math.round(strike.yes_diff)}` : `${Math.round(strike.yes_diff)}`;
                        } else {
                            // PRICE MODE: Show actual ask price
                            yesPrice = strike.yes_ask.toString();
                        }
                    }
                    
                    if (strike.no_ask && strike.no_ask !== '—' && strike.no_ask !== 0) {
                        if (isDiffMode && strike.no_diff !== null && strike.no_diff !== undefined) {
                            // DIFF MODE: Show pre-calculated diff value (no decimals)
                            noPrice = strike.no_diff > 0 ? `+${Math.round(strike.no_diff)}` : `${Math.round(strike.no_diff)}`;
                        } else {
                            // PRICE MODE: Show actual ask price
                            noPrice = strike.no_ask.toString();
                        }
                    }
                    
                    // Apply same enable/disable rules as desktop
                    const volumeNum = parseInt(strike.volume) || 0;
                    const volumeOk = volumeNum >= 1000;
                    const yesPriceOk = strike.yes_ask && strike.yes_ask <= 98;
                    const noPriceOk = strike.no_ask && strike.no_ask <= 98;
                    const currentPriceFloat = parseFloat(currentPrice);
                    const strikeFloat = parseFloat(strike.strike);
                    const isAboveMoneyLine = strikeFloat > currentPriceFloat;
                    
                    // Determine which button should be enabled (same logic as desktop)
                    let yesEnabled = false;
                    let noEnabled = false;
                    
                    if (volumeOk) {
                        if (isAboveMoneyLine) {
                            // Above money line: Only enable NO button if price is good
                            noEnabled = noPriceOk;
                            yesEnabled = false; // Never enable YES above money line
                        } else {
                            // Below money line: Only enable YES button if price is good
                            yesEnabled = yesPriceOk;
                            noEnabled = false; // Never enable NO below money line
                        }
                    }
                    
                    // Create buttons with proper enable/disable state
                    const yesButtonClass = yesEnabled ? 'price-box-mobile' : 'price-box-mobile disabled';
                    const noButtonClass = noEnabled ? 'price-box-mobile' : 'price-box-mobile disabled';
                    const yesOnClick = yesEnabled ? `onclick="openTrade(this, '${strike.strike}', 'Y', ${strike.yes_ask})"` : '';
                    const noOnClick = noEnabled ? `onclick="openTrade(this, '${strike.strike}', 'N', ${strike.no_ask})"` : '';
                    
                    row.innerHTML = `
                        <td>${strikePrice}</td>
                        <td>${buffer}</td>
                        <td>${bufferPct}</td>
                        <td>${probability}</td>
                        <td><span class="${yesButtonClass}" ${yesOnClick}>${yesPrice}</span></td>
                        <td><span class="${noButtonClass}" ${noOnClick}>${noPrice}</span></td>
                    `;
                    
                    // Add risk-based color formatting (same as main trade monitor)
                    const prob = strike.probability;
                    if (prob) {
                        row.classList.remove('ultra-safe', 'safe', 'caution', 'high-risk', 'danger-stop');
                        let riskClass = '';
                        if (prob >= 98) riskClass = 'ultra-safe';
                        else if (prob >= 95) riskClass = 'safe';
                        else if (prob >= 80) riskClass = 'caution';
                        else riskClass = 'high-risk';
                        row.classList.add(riskClass);
                    }
                    
                    dataRows.push(row);
                });
                
                // Create spanner row with momentum arrows (same as main trade monitor)
                const spannerRow = document.createElement('tr');
                spannerRow.className = 'spanner-row';
                const spannerTd = document.createElement('td');
                spannerTd.colSpan = 6;
                
                // Get momentum score for arrows (CORRECT ELEMENT ID)
                const momentumEl = document.getElementById('momentum-score-display');
                let momentumScore = 0;
                if (momentumEl && momentumEl.textContent) {
                    const val = parseFloat(momentumEl.textContent.replace(/[^\d\.\-]/g, ''));
                    momentumScore = isNaN(val) ? 0 : val;
                }
                
                // Create momentum arrows (same as main trade monitor)
                const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                
                let arrowBlock = '';
                const absMomentum = Math.abs(momentumScore);
                if (absMomentum < 5) {
                    arrowBlock = '-';
                } else if (absMomentum < 10) {
                    arrowBlock = momentumScore > 0 ? svgDown : svgUp;
                } else if (absMomentum < 20) {
                    arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(2);
                } else {
                    arrowBlock = (momentumScore > 0 ? svgDown : svgUp).repeat(3);
                }
                
                spannerTd.innerHTML = `<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>Current Price: $${Math.round(currentPrice).toLocaleString()}<span style="margin:0 12px;display:inline-block;">${arrowBlock}</span>`;
                spannerRow.appendChild(spannerTd);
                
                // Add data rows first
                dataRows.forEach(row => {
                    tbody.appendChild(row);
                });
                
                // Position spanner row correctly (same logic as main trade monitor)
                const allRows = Array.from(tbody.children).filter(row => !row.classList.contains('spanner-row'));
                let insertIndex = allRows.length; // default to end
                
                for (let i = 0; i < allRows.length; i++) {
                    const row = allRows[i];
                    const strikeCell = row.querySelector('td');
                    if (strikeCell && strikeCell.textContent) {
                        const strikeText = strikeCell.textContent.replace(/[\$,]/g, '');
                        const strike = parseFloat(strikeText);
                        if (!isNaN(strike) && currentPrice < strike) {
                            insertIndex = i;
                            break;
                        }
                    }
                }
                
                // Remove spanner row from current position and insert at correct position
                if (spannerRow.parentNode) {
                    spannerRow.remove();
                }
                
                if (insertIndex < allRows.length) {
                    tbody.insertBefore(spannerRow, allRows[insertIndex]);
                } else {
                    tbody.appendChild(spannerRow);
                }
                
            } catch (error) {
                console.error('Error updating mobile strike table:', error);
            }
        }

        // Trade execution functions
        function openTrade(element, strike, side, price) {
            if (element.disabled) return;
            
            element.disabled = true;
            
            // Visual feedback
            element.style.backgroundColor = '#007bff';
            element.style.color = 'white';
            
            setTimeout(() => {
                element.style.backgroundColor = '';
                element.style.color = '';
                element.disabled = false;
            }, 500);
            
            // Execute trade
            fetch('/api/trigger_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    strike: strike,
                    side: side,
                    price: price,
                    type: 'market'
                })
            }).catch(console.error);
        }

        function closeTrade(tradeId, event) {
            const btn = event.target;
            if (btn.disabled) return;
            
            btn.disabled = true;
            btn.textContent = 'Closing...';
            
            fetch('/api/trigger_close_trade', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    trade_id: tradeId
                })
            }).catch(console.error).finally(() => {
                btn.disabled = false;
                btn.textContent = 'Close';
            });
        }

        // Active Trade Supervisor functionality
        let activeTradeSupervisorRowsMap = new Map();

        async function fetchAndRenderActiveTradeSupervisorTrades() {
            try {
                // Get the active trade supervisor service URL
                let activeTradeSupervisorUrl;
                try {
                    // Try to use the same port configuration as desktop
                    if (typeof getActiveTradeSupervisorUrl === 'function') {
                        activeTradeSupervisorUrl = getActiveTradeSupervisorUrl('/api/active_trades');
                    } else {
                        // Fallback to hardcoded URL
                        activeTradeSupervisorUrl = `http://${window.location.hostname}:6000/api/active_trades`;
                    }
                } catch (error) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Port configuration error:', error);
                    // Fallback to hardcoded URL
                    activeTradeSupervisorUrl = `http://${window.location.hostname}:6000/api/active_trades`;
                }
                
                // Fetch active trades from the supervisor service
                const response = await fetch(activeTradeSupervisorUrl, { cache: 'no-store' });
                
                if (!response.ok) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Failed to fetch active trades:', response.status);
                    return;
                }
                
                const data = await response.json();
                
                if (!data.active_trades || !Array.isArray(data.active_trades)) {
                    console.error('[ACTIVE TRADE SUPERVISOR] Invalid data format:', data);
                    return;
                }
                
                // Render the trades
                renderActiveTradeSupervisorTrades(data.active_trades);
                
            } catch (error) {
                console.error('[ACTIVE TRADE SUPERVISOR] Error fetching trades:', error);
            }
        }

        function renderActiveTradeSupervisorTrades(activeTrades) {
            const tableBody = document.querySelector('#active-trade-supervisor-table tbody');
            if (!tableBody) {
                console.error('[ACTIVE TRADE SUPERVISOR] Table body not found!');
                return;
            }
            
            // Sort trades by strike price in ascending order
            activeTrades.sort((a, b) => {
                const strikeA = parseFloat(a.strike.toString().replace(/[\$,]/g, ''));
                const strikeB = parseFloat(b.strike.toString().replace(/[\$,]/g, ''));
                return strikeA - strikeB;
            });
            
            // Remove rows for trades that no longer exist
            const activeTradeIds = new Set(activeTrades.map(trade => trade.trade_id));
            
            for (const [tradeId, rowObj] of activeTradeSupervisorRowsMap.entries()) {
                if (!activeTradeIds.has(tradeId)) {
                    if (rowObj.tr && rowObj.tr.parentNode === tableBody) {
                        tableBody.removeChild(rowObj.tr);
                    }
                    activeTradeSupervisorRowsMap.delete(tradeId);
                }
            }

            // Remove all existing spanner rows before rendering trade rows
            tableBody.querySelectorAll('.spanner-row').forEach(row => row.remove());

            // Render each active trade
            activeTrades.forEach((trade, idx) => {
                const tradeId = trade.trade_id;
                
                // Check if we already have a row for this trade
                let rowObj = activeTradeSupervisorRowsMap.get(tradeId);
                
                if (!rowObj) {
                    const row = document.createElement("tr");
                    
                    // Strike
                    const strikeCell = document.createElement("td");
                    strikeCell.textContent = trade.strike;
                    row.appendChild(strikeCell);
                    
                    // Side
                    const sideCell = document.createElement("td");
                    sideCell.textContent = trade.side;
                    row.appendChild(sideCell);
                    
                    // Buy (price)
                    const priceCell = document.createElement("td");
                    priceCell.textContent = (typeof trade.buy_price === "number")
                        ? trade.buy_price.toFixed(2)
                        : trade.buy_price;
                    row.appendChild(priceCell);
                    
                    // Position
                    const posCell = document.createElement("td");
                    posCell.textContent = trade.position ?? "";
                    row.appendChild(posCell);
                    
                    // Buffer (from active_trades.db)
                    const bufferCell = document.createElement("td");
                    if (trade.buffer_from_entry !== null) {
                        const buffer = trade.buffer_from_entry;
                        bufferCell.textContent = buffer.toLocaleString(undefined, {maximumFractionDigits: 0});
                        
                        // Apply risk color classes based on probability
                        if (trade.current_probability !== null && trade.current_probability !== undefined) {
                            const prob = trade.current_probability;
                            if (prob >= 95) row.classList.add('ultra-safe');
                            else if (prob >= 80) row.classList.add('safe');
                            else if (prob >= 50) row.classList.add('caution');
                            else if (prob >= 25) row.classList.add('high-risk');
                            else row.classList.add('danger-stop');
                        }
                    } else {
                        bufferCell.textContent = "N/A";
                    }
                    row.appendChild(bufferCell);
                    
                    // Probability (from active_trades.db)
                    const probCell = document.createElement("td");
                    if (trade.current_probability !== null) {
                        probCell.textContent = trade.current_probability.toFixed(1);
                    } else {
                        probCell.textContent = "N/A";
                    }
                    row.appendChild(probCell);
                    
                    // Close button with PnL display - using same styling as price buttons
                    const closeCell = document.createElement("td");
                    closeCell.style.textAlign = "center";
                    const closeSpan = document.createElement("span");
                    closeSpan.className = "close-btn-mobile";
                    closeSpan.dataset.tradeId = trade.trade_id;
                    closeSpan.dataset.action = "close";
                    closeSpan.style.cursor = "pointer";
                    closeSpan.onclick = () => closeActiveTrade(trade.trade_id, trade.ticket_id);
                    
                    // Display PnL if available, otherwise show "Close"
                    if (trade.current_pnl !== null && trade.current_pnl !== undefined) {
                        const pnl = parseFloat(trade.current_pnl);
                        if (!isNaN(pnl)) {
                            // Format PnL with white text
                            const pnlText = pnl >= 0 ? `+${pnl.toFixed(2)}` : pnl.toFixed(2);
                            closeSpan.textContent = pnlText;
                            closeSpan.style.color = "white";
                        } else {
                            closeSpan.textContent = "Close";
                            closeSpan.style.color = "white";
                        }
                    } else {
                        closeSpan.textContent = "Close";
                        closeSpan.style.color = "white";
                    }
                    
                    closeCell.appendChild(closeSpan);
                    row.appendChild(closeCell);
                    
                    // Store the row object
                    rowObj = { tr: row };
                    activeTradeSupervisorRowsMap.set(tradeId, rowObj);
                    
                    // Apply status-based styling
                    if (trade.status === 'closing') {
                        row.classList.add('closing-trade');
                    }
                    
                    // Add the row to the table
                    tableBody.appendChild(row);
                } else {
                    // Update existing row with new data
                    const row = rowObj.tr;
                    const cells = row.querySelectorAll('td');
                    
                    // Update buffer
                    if (cells.length > 4 && trade.buffer_from_entry !== null) {
                        const buffer = trade.buffer_from_entry;
                        cells[4].textContent = buffer.toLocaleString(undefined, {maximumFractionDigits: 0});
                        
                        // Update risk color classes based on probability
                        row.classList.remove('ultra-safe', 'safe', 'caution', 'high-risk', 'danger-stop');
                        if (trade.current_probability !== null && trade.current_probability !== undefined) {
                            const prob = trade.current_probability;
                            if (prob >= 95) row.classList.add('ultra-safe');
                            else if (prob >= 80) row.classList.add('safe');
                            else if (prob >= 50) row.classList.add('caution');
                            else if (prob >= 25) row.classList.add('high-risk');
                            else row.classList.add('danger-stop');
                        }
                    }
                    
                    // Update probability
                    if (cells.length > 5 && trade.current_probability !== null) {
                        cells[5].textContent = trade.current_probability.toFixed(1);
                    }
                    
                    // Update status-based styling
                    row.classList.remove('closing-trade');
                    if (trade.status === 'closing') {
                        row.classList.add('closing-trade');
                    }
                    
                    // Update PnL on close button
                    if (cells.length > 6 && trade.current_pnl !== null && trade.current_pnl !== undefined) {
                        const closeButton = cells[6].querySelector('.close-btn-mobile');
                        if (closeButton) {
                            const pnl = parseFloat(trade.current_pnl);
                            if (!isNaN(pnl)) {
                                const pnlText = pnl >= 0 ? `+${pnl.toFixed(2)}` : pnl.toFixed(2);
                                closeButton.textContent = pnlText;
                                closeButton.style.color = "white";
                            } else {
                                closeButton.textContent = "Close";
                                closeButton.style.color = "white";
                            }
                        }
                    }
                }
            });

            // Add spanner row logic
            if (activeTrades.length === 0) {
                // No active trades - show "No active trades" message
                const spannerRow = document.createElement("tr");
                spannerRow.className = "spanner-row";
                const spannerCell = document.createElement("td");
                spannerCell.colSpan = 7;
                spannerCell.textContent = "No active trades";
                spannerRow.appendChild(spannerCell);
                tableBody.appendChild(spannerRow);
            }
        }

        async function closeActiveTrade(tradeId, ticketId) {
            try {
                console.log('[ACTIVE TRADE SUPERVISOR] Attempting to close trade:', tradeId);
                
                // Use the centralized closeTrade function from the trade execution controller
                if (typeof window.closeTrade === 'function') {
                    // Get current BTC price for sell price
                    const currentPrice = typeof getCurrentBTCTickerPrice === 'function' ? getCurrentBTCTickerPrice() : 0.5;
                    console.log('[ACTIVE TRADE SUPERVISOR] Current price for close:', currentPrice);
                    
                    // Create a mock event object since we don't have the actual event
                    const mockEvent = {
                        target: document.createElement('button'),
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    };
                    
                    // Call the centralized close trade function - let it handle all notifications
                    console.log('[ACTIVE TRADE SUPERVISOR] Calling window.closeTrade with:', { tradeId, currentPrice });
                    await window.closeTrade(tradeId, currentPrice, mockEvent);
                    console.log('[ACTIVE TRADE SUPERVISOR] Close trade call completed');
                } else {
                    console.error('[ACTIVE TRADE SUPERVISOR] Centralized closeTrade function not available');
                }
            } catch (error) {
                console.error(`[ACTIVE TRADE SUPERVISOR] Error closing trade ${tradeId}:`, error);
            }
        }

        function startActiveTradeSupervisorPolling() {
            // Initial load
            fetchAndRenderActiveTradeSupervisorTrades();
            
            // Set up periodic refresh (every 1 second - same as desktop)
            setInterval(() => {
                fetchAndRenderActiveTradeSupervisorTrades();
            }, 1000);
        }
    </script>
</body>
</html> 