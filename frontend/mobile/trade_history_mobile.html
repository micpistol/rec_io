<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trade History Mobile</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/global.css">
    <script src="../js/globals.js"></script>
    <script>
        // Mobile-specific port configuration
        function getMainAppUrl() {
            // For mobile, use the same host as the current page
            return window.location.origin;
        }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'IBM Plex Sans', sans-serif;
            background-color: #101018;
            color: white;
            overflow-x: hidden;
        }

        .mobile-container {
            padding: 10px;
            max-width: 100vw;
        }

        /* Search Section */
        .search-section {
            margin-bottom: 10px;
        }

        .filter-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 6px 10px;
            border: 1px solid #787878;
            background-color: #1f2530;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        /* Summary Section */
        .summary-section {
            margin-bottom: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            text-align: center;
        }

        .summary-item {
            padding: 10px;
            background-color: #1f2530;
            border-radius: 4px;
        }

        .summary-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 5px;
        }

        .summary-value {
            font-size: 18px;
            font-weight: bold;
            color: white;
        }

        /* Results Section */
        .results-section {
            height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .results-table th,
        .results-table td {
            border: 1px solid #787878;
            padding: 6px 10px;
            text-align: center;
        }

        .results-table th {
            background-color: #1f2530;
            font-weight: bold;
            font-size: 0.7rem;
            cursor: pointer;
            position: relative;
        }

        /* Remove default alternating row colors to allow group-based coloring */
        .results-table tbody tr {
            background-color: transparent;
        }

        .results-table tbody tr:hover {
            background-color: #4d586f !important;
            cursor: pointer;
        }

        /* Group-based coloring - these should override the transparent background */
        .results-table tbody tr.group-odd {
            background-color: #394559;
        }

        .results-table tbody tr.group-even {
            background-color: #1f2633;
        }

        .no-results {
            text-align: center;
            padding: 20px;
            color: #ccc;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .summary-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .results-table {
                font-size: 0.6rem;
            }
            
            .results-table th,
            .results-table td {
                padding: 4px 6px;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- Search Section -->
        <div class="search-section">
            <div class="filter-row">
                <select id="date-filter-picker" class="filter-select">
                    <option value="ALL">All</option>
                    <option value="TODAY">Today</option>
                    <option value="THIS_WEEK">This Week</option>
                    <option value="SUNDAY">- Sunday</option>
                    <option value="MONDAY">- Monday</option>
                    <option value="TUESDAY">- Tuesday</option>
                    <option value="WEDNESDAY">- Wednesday</option>
                    <option value="THURSDAY">- Thursday</option>
                    <option value="FRIDAY">- Friday</option>
                    <option value="SATURDAY">- Saturday</option>
                    <option value="LAST_WEEK">Last Week</option>
                    <option value="MONTH">This Month</option>
                    <option value="PREV_30">Prev 30</option>
                    <option value="YTD">YTD</option>
                    <option value="PREV_YEAR">Prev Year</option>
                    <option value="CUSTOM">Custom</option>
                </select>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filter-win" checked style="width: 14px; height: 14px;">
                    Win
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filter-loss" checked style="width: 14px; height: 14px;">
                    Loss
                </label>
            </div>
        </div>

        <!-- Summary Section -->
        <div class="summary-section">
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="summary-label">Trades</div>
                    <div class="summary-value" id="trade-count">0</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">PnL</div>
                    <div class="summary-value" id="total-pnl">$0.00</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">Avg Prob</div>
                    <div class="summary-value" id="avg-prob">0.00</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">W/L %</div>
                    <div class="summary-value" id="win-loss-percentage">0%</div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div class="results-section">
            <table id="trade-log-table" class="results-table">
                <thead>
                    <tr>
                        <th data-key="id">ID</th>
                        <th data-key="status">Status</th>
                        <th data-key="date">Date</th>
                        <th data-key="time">Time</th>
                        <th data-key="symbol">Symbol</th>
                        <th data-key="trade_strategy">Strategy</th>
                        <th data-key="contract">Contract</th>
                        <th data-key="strike">Strike</th>
                        <th data-key="side">Side</th>
                        <th data-key="prob">Prob</th>
                        <th data-key="diff">Diff</th>
                        <th data-key="buy_price">Buy</th>
                        <th data-key="sell_price">Sell</th>
                        <th data-key="position">Position</th>
                        <th data-key="fees">Fees</th>
                        <th data-key="pnl">PnL</th>
                        <th data-key="closed_at">Closed</th>
                        <th data-key="symbol_open">Symbol Open</th>
                        <th data-key="symbol_close">Symbol Close</th>
                        <th data-key="momentum">Mom</th>
                        <th data-key="win_loss">W/L</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td colspan="22">Loading...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let currentSort = { key: 'id', asc: false };
        let trades = [];
        let filteredTrades = [];

        function displayPnL(trade) {
            if (trade.pnl !== null && trade.pnl !== undefined) {
                return Number(trade.pnl).toFixed(2);
            }
            return '';
        }

        // === DATE FILTER LOGIC ===
        function filterTradesByDate(trades, filter) {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const today = `${year}-${month}-${day}`;
            
            // Helper to get the date string for a given day of week in this week
            function getDateOfThisWeek(dayOfWeek) {
                const curr = new Date(now);
                const currDay = curr.getDay();
                const diff = dayOfWeek - currDay;
                curr.setDate(curr.getDate() + diff);
                return formatDate(curr);
            }
            
            // Helper to get the date string for a given day of week in last week
            function getDateOfLastWeek(dayOfWeek) {
                const curr = new Date(now);
                const currDay = curr.getDay();
                // Go to previous Sunday, then add dayOfWeek
                curr.setDate(curr.getDate() - currDay - 7 + dayOfWeek);
                return formatDate(curr);
            }
            
            // Helper to get the latest Sunday (start of this week)
            function getLatestSunday() {
                const curr = new Date(now);
                curr.setDate(curr.getDate() - curr.getDay());
                return formatDate(curr);
            }
            
            // Helper to get previous Sunday (start of last week)
            function getPrevSunday() {
                const curr = new Date(now);
                curr.setDate(curr.getDate() - curr.getDay() - 7);
                return formatDate(curr);
            }
            
            // Helper to get following Saturday (end of last week)
            function getNextSaturdayOfPrevWeek() {
                const curr = new Date(now);
                curr.setDate(curr.getDate() - curr.getDay() - 1); // previous Saturday
                return formatDate(curr);
            }
            
            return trades.filter(trade => {
                if (!trade.date) return false;
                switch (filter) {
                    case 'TODAY':
                        return trade.date === today;
                    case 'THIS_WEEK': {
                        const sunday = getLatestSunday();
                        return trade.date >= sunday && trade.date <= today;
                    }
                    case 'SUNDAY':
                        return trade.date === getDateOfThisWeek(0);
                    case 'MONDAY':
                        return trade.date === getDateOfThisWeek(1);
                    case 'TUESDAY':
                        return trade.date === getDateOfThisWeek(2);
                    case 'WEDNESDAY':
                        return trade.date === getDateOfThisWeek(3);
                    case 'THURSDAY':
                        return trade.date === getDateOfThisWeek(4);
                    case 'FRIDAY':
                        return trade.date === getDateOfThisWeek(5);
                    case 'SATURDAY':
                        return trade.date === getDateOfThisWeek(6);
                    case 'LAST_WEEK': {
                        const prevSunday = getPrevSunday();
                        const nextSaturday = getNextSaturdayOfPrevWeek();
                        return trade.date >= prevSunday && trade.date <= nextSaturday;
                    }
                    case 'MONTH': {
                        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                        const monthStartStr = formatDate(monthStart);
                        return trade.date >= monthStartStr && trade.date <= today;
                    }
                    case 'PREV_30': {
                        const prev30 = new Date(now);
                        prev30.setDate(now.getDate() - 30);
                        const prev30Str = formatDate(prev30);
                        return trade.date >= prev30Str && trade.date <= today;
                    }
                    case 'YTD': {
                        const ytdStr = `${year}-01-01`;
                        return trade.date >= ytdStr && trade.date <= today;
                    }
                    case 'PREV_YEAR': {
                        const prevYear = new Date(now);
                        prevYear.setFullYear(now.getFullYear() - 1);
                        const prevYearStr = formatDate(prevYear);
                        return trade.date >= prevYearStr && trade.date <= today;
                    }
                    case 'CUSTOM':
                        return true;
                    default:
                        return true;
                }
            });
        }
        
        // === WIN/LOSS FILTER LOGIC ===
        function filterTradesByWinLoss(trades) {
            const showWin = document.getElementById('filter-win').checked;
            const showLoss = document.getElementById('filter-loss').checked;
            
            return trades.filter(trade => {
                const winLoss = trade.win_loss;
                if (winLoss === 'W' || winLoss === 'Win') {
                    return showWin;
                } else if (winLoss === 'L' || winLoss === 'Loss') {
                    return showLoss;
                }
                // If win_loss is null/undefined/empty, show it regardless of filters
                return true;
            });
        }
        
        // Helper function to format date as YYYY-MM-DD
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function applyCurrentSort() {
            if (currentSort.key === null) return;

            filteredTrades.sort((a, b) => {
                let valA = a[currentSort.key];
                let valB = b[currentSort.key];

                // Normalize side values for sorting
                if (currentSort.key === 'side') {
                    const mapSide = v => (v === 'Yes' || v === 'Y' ? 'Y' : v === 'No' || v === 'N' ? 'N' : '');
                    valA = mapSide(valA);
                    valB = mapSide(valB);
                }

                // Normalize null/undefined to empty string
                if (valA === null || valA === undefined) valA = '';
                if (valB === null || valB === undefined) valB = '';

                // Try to parse as numbers for numeric fields
                const numericKeys = ['id', 'strike', 'buy_price', 'sell_price', 'position', 'symbol_open', 'symbol_close', 'momentum', 'win_loss', 'pnl', 'prob', 'diff'];
                if (numericKeys.includes(currentSort.key)) {
                    valA = Number(valA);
                    valB = Number(valB);
                    if (isNaN(valA)) valA = -Infinity;
                    if (isNaN(valB)) valB = -Infinity;
                }

                // For date and time, compare as strings (assuming ISO or consistent format)
                // For other strings, localeCompare
                if (typeof valA === 'string' && typeof valB === 'string') {
                    const cmp = valA.localeCompare(valB);
                    return currentSort.asc ? cmp : -cmp;
                } else {
                    if (valA < valB) return currentSort.asc ? -1 : 1;
                    if (valA > valB) return currentSort.asc ? 1 : -1;
                    return 0;
                }
            });
        }

        function sortTrades(key) {
            if (currentSort.key === key) {
                currentSort.asc = !currentSort.asc;
            } else {
                currentSort.key = key;
                currentSort.asc = true;
            }
            applyCurrentSort();
            renderTrades(filteredTrades);
        }

        function updateSummary(trades) {
            const tradeCountEl = document.getElementById('trade-count');
            const avgProbEl = document.getElementById('avg-prob');
            const winLossEl = document.getElementById('win-loss-percentage');
            const totalPnlEl = document.getElementById('total-pnl');
            
            if (!Array.isArray(trades) || trades.length === 0) {
                tradeCountEl.textContent = '0';
                avgProbEl.textContent = '0.00';
                winLossEl.textContent = '0%';
                totalPnlEl.textContent = '$0.00';
                return;
            }
            
            // Count total trades
            const tradeCount = trades.length;
            
            // Calculate average probability
            let totalProb = 0;
            let probCount = 0;
            trades.forEach(trade => {
                if (trade.prob !== null && trade.prob !== undefined && trade.prob !== '') {
                    const prob = Number(trade.prob);
                    if (!isNaN(prob)) {
                        totalProb += prob;
                        probCount++;
                    }
                }
            });
            const avgProb = probCount > 0 ? (totalProb / probCount) : 0; // Keep as percentage
            
            // Calculate win/loss percentage
            let winCount = 0;
            let totalTrades = 0;
            
            trades.forEach(trade => {
                if (trade.win_loss !== null && trade.win_loss !== undefined && trade.win_loss !== '') {
                    // win_loss is stored as 'W' for win, 'L' for loss
                    if (trade.win_loss === 'W' || trade.win_loss === 'L') {
                        totalTrades++;
                        if (trade.win_loss === 'W') winCount++;
                    }
                }
            });
            
            const winPercentage = totalTrades > 0 ? ((winCount / totalTrades) * 100) : 0;
            
            // Calculate total PnL
            let totalPnlDisplay = 0;
            trades.forEach(trade => {
                if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '') {
                    const pnl = Number(trade.pnl);
                    if (!isNaN(pnl)) {
                        totalPnlDisplay += pnl;
                    }
                }
            });
            
            // Update the display
            tradeCountEl.textContent = tradeCount.toString();
            avgProbEl.textContent = `${avgProb.toFixed(1)}%`;
            winLossEl.textContent = `${winPercentage.toFixed(1)}%`;
            totalPnlEl.textContent = `$${totalPnlDisplay.toFixed(2)}`;
            
            // Color coding for PnL
            if (totalPnlDisplay > 0) {
                totalPnlEl.style.color = '#28a745'; // Green for positive
            } else if (totalPnlDisplay < 0) {
                totalPnlEl.style.color = '#dc3545'; // Red for negative
            } else {
                totalPnlEl.style.color = 'white'; // White for zero
            }
        }

        function renderTrades(tradesToRender) {
            const tbody = document.querySelector('#trade-log-table tbody');
            tbody.innerHTML = '';
            if (!Array.isArray(tradesToRender) || tradesToRender.length === 0) {
                tbody.innerHTML = '<tr><td colspan="22">No trades found.</td></tr>';
                updateSummary(tradesToRender); // Update summary even when no trades
                return;
            }

            let lastContract = null;
            let groupIndex = 0;
            for (const trade of tradesToRender) {
                const isNewGroup = trade.contract !== lastContract;
                if (isNewGroup) {
                    groupIndex++;
                }
                lastContract = trade.contract;
                const tr = document.createElement('tr');
                tr.style.borderTop = isNewGroup ? '2px solid #666' : '';
                // Assign group-odd or group-even class based on groupIndex
                tr.classList.add(groupIndex % 2 === 1 ? 'group-odd' : 'group-even');
                // Helper to format numbers with + sign for positive values, no decimals
                function plusSign(val) {
                    if (val === null || val === undefined || val === '') return '';
                    const num = Number(val);
                    if (isNaN(num)) return val;
                    return (num > 0 ? '+' : '') + Math.round(num);
                }
                tr.innerHTML = `
                    <td>${trade.id !== null ? trade.id : ''}</td>
                    <td>${trade.status !== null ? trade.status : ''}</td>
                    <td>${trade.date !== null ? trade.date : ''}</td>
                    <td>${trade.time !== null ? trade.time : ''}</td>
                    <td>${trade.symbol !== null ? trade.symbol : ''}</td>
                    <td>${trade.trade_strategy !== null ? trade.trade_strategy : ''}</td>
                    <td>${trade.contract !== null ? trade.contract : ''}</td>
                    <td>${trade.strike !== null ? trade.strike : ''}</td>
                    <td>${trade.side === 'Yes' || trade.side === 'Y' ? 'Y' : trade.side === 'No' || trade.side === 'N' ? 'N' : ''}</td>
                    <td>${trade.prob !== null && trade.prob !== undefined && trade.prob !== '' ? (Number(trade.prob) / 100).toFixed(2) : ''}</td>
                    <td>${plusSign(trade.diff)}</td>
                    <td>${trade.buy_price !== null ? Number(trade.buy_price).toFixed(2) : ''}</td>
                    <td>${trade.sell_price !== null ? Number(trade.sell_price).toFixed(2) : ''}</td>
                    <td>${trade.position !== null ? trade.position : ''}</td>
                    <td>${trade.fees !== null ? Number(trade.fees).toFixed(2) : ''}</td>
                    <td>${trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '' ? Number(trade.pnl).toFixed(2) : ''}</td>
                    <td>${trade.closed_at !== null ? trade.closed_at : ''}</td>
                    <td>${trade.symbol_open !== null ? '$' + Math.round(trade.symbol_open).toLocaleString() : ''}</td>
                    <td>${trade.symbol_close !== null ? '$' + Math.round(trade.symbol_close).toLocaleString() : ''}</td>
                    <td>${plusSign(trade.momentum)}</td>
                    <td>${plusSign(trade.win_loss)}</td>
                `;
                tbody.appendChild(tr);
            }
            
            // Update summary statistics
            updateSummary(tradesToRender);
        }

        function applyFilters() {
            const dateFilterPicker = document.getElementById('date-filter-picker');
            
            // Filter out test trades (where test_filter is TRUE)
            let filtered = trades.filter(trade => !trade.test_filter);
            
            filtered = filterTradesByDate(filtered, dateFilterPicker ? dateFilterPicker.value : 'TODAY');
            filtered = filterTradesByWinLoss(filtered);
            
            filteredTrades = [...filtered];
            applyCurrentSort();
            renderTrades(filteredTrades);
        }

        async function fetchAllTrades() {
            console.log('Fetching trades at', new Date().toLocaleTimeString());
            try {
                // Wait for port configuration to be loaded
                let retries = 0;
                const maxRetries = 10;
                while (retries < maxRetries) {
                    try {
                        // Use the centralized port system
                        const apiBaseUrl = getMainAppUrl();
                        
                        const res = await fetch(`${apiBaseUrl}/trades`, { cache: 'no-store' });
                        if (!res.ok) throw new Error('Network response was not ok');
                        trades = await res.json();
                        applyFilters();
                        return; // Success, exit the function
                    } catch (portError) {
                        if (portError.message.includes('Port configuration not loaded')) {
                            console.log(`Waiting for port configuration... (attempt ${retries + 1}/${maxRetries})`);
                            retries++;
                            if (retries < maxRetries) {
                                await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
                                continue;
                            }
                        }
                        throw portError; // Re-throw if it's not a port config error or we've exhausted retries
                    }
                }
                throw new Error('Port configuration failed to load after multiple attempts');
            } catch (error) {
                const tbody = document.querySelector('#trade-log-table tbody');
                tbody.innerHTML = `<tr><td colspan="22" style="color:red;">Failed to load trades: ${error.message}</td></tr>`;
                console.error('Error fetching trades:', error);
            }
        }

        // Event listeners
        document.getElementById('date-filter-picker').addEventListener('change', applyFilters);
        document.getElementById('filter-win').addEventListener('change', applyFilters);
        document.getElementById('filter-loss').addEventListener('change', applyFilters);

        // Add sort functionality to table headers
        document.querySelectorAll('#trade-log-table th[data-key]').forEach(th => {
            th.addEventListener('click', () => sortTrades(th.dataset.key));
        });

        // Initial load
        fetchAllTrades();

        // Auto-refresh every 30 seconds
        setInterval(fetchAllTrades, 10000); // Reduced from 30 seconds to 10 seconds for more responsive updates
        
        // Add WebSocket connection for real-time trade updates
        function setupTradeHistoryWebSocket() {
            const ws = new WebSocket(`ws://${window.location.host}/ws/db_changes`);
            
            ws.onopen = function() {
                console.log('ðŸ”— Connected to trade history WebSocket (mobile)');
            };
            
            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    console.log('ðŸ“¡ Received database change notification (trade history mobile):', data);
                    
                    // Refresh trades immediately on any database change
                    if (data.database === 'trades' || data.database === 'fills' || data.database === 'positions') {
                        console.log('ðŸ”„ Refreshing trade history due to database change (mobile)');
                        fetchAllTrades();
                    }
                } catch (error) {
                    console.error('âŒ Error parsing WebSocket message (trade history mobile):', error);
                }
            };
            
            ws.onerror = function(error) {
                console.error('âŒ WebSocket error (trade history mobile):', error);
            };
            
            ws.onclose = function() {
                console.log('ðŸ”Œ Trade history WebSocket connection closed (mobile)');
                // Attempt to reconnect after a delay
                setTimeout(() => {
                    console.log('ðŸ”„ Attempting to reconnect trade history WebSocket (mobile)...');
                    setupTradeHistoryWebSocket();
                }, 5000);
            };
        }
        
        // Set up WebSocket for real-time trade updates
        setupTradeHistoryWebSocket();
        
        // Mobile iframe coordination message handling
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'refresh_data') {
                console.log('ðŸ“± Trade history mobile received refresh request');
                // Trigger immediate data refresh
                fetchAllTrades();
                // Notify parent of data update
                window.parent.postMessage({
                    type: 'data_updated',
                    source: 'trade_history_mobile',
                    timestamp: Date.now()
                }, '*');
            }
        });
    </script>
</body>
</html> 