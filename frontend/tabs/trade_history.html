<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trade History</title>
  <link rel="stylesheet" href="/styles/global.css" />
  <script src="/js/globals.js"></script>
  <style>
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.7rem;
    }
    th, td {
      border: 1px solid #787878;
      padding: 6px 10px;
      text-align: center;
    }
    th {
      background-color: #1f2530;
      font-weight: bold;
      font-size: 0.7rem;
      cursor: pointer;
      position: relative;
    }
    th .sort-indicator {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }
    tbody tr:nth-child(even) {
      /* background-color: #323c4e; */
    }
    caption {
      font-size: 1.2rem;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .group-odd {
      background-color: #394559;
    }
    .group-even {
      background-color: #1f2633;
    }
    tbody tr:hover {
      background-color: #4d586f !important;
      cursor: pointer;
    }

    th.sortable::after {
      content: '';
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 5px;
      border: 4px solid transparent;
      border-top-color: #ccc;
      vertical-align: middle;
      opacity: 0;
      transition: opacity 0.2s;
    }

    th.sortable:hover::after {
      opacity: 1;
    }
  </style>
</head>
<body>

  <div style="display: flex; gap: 10px;">
    <div class="panel-container" style="width: 50%; height: 110px;">
      <div class="panel-header">Search</div>
      <div style="margin-top: 10px; display: flex; gap: 20px; align-items: flex-start;">
        <div>
          <select id="date-filter-picker" class="dropdown-picker" style="width: 180px;">
            <option value="ALL">All</option>
            <option value="TODAY">Today</option>
            <option value="THIS_WEEK">This Week</option>
            <option value="SUNDAY">- Sunday</option>
            <option value="MONDAY">- Monday</option>
            <option value="TUESDAY">- Tuesday</option>
            <option value="WEDNESDAY">- Wednesday</option>
            <option value="THURSDAY">- Thursday</option>
            <option value="FRIDAY">- Friday</option>
            <option value="SATURDAY">- Saturday</option>
            <option value="LAST_WEEK">Last Week</option>
            <option value="MONTH">This Month</option>
            <option value="PREV_30">Prev 30</option>
            <option value="YTD">YTD</option>
            <option value="PREV_YEAR">Prev Year</option>
            <option value="CUSTOM">Custom</option>
          </select>
          <div id="date-range-display" style="margin-top: 10px; margin-left: 10px;font-size: 12px; color: #ccc;"></div>
        </div>
        <div>
          <div style="margin-bottom: 5px;">
            <span id="select-all-filters" style="font-size: 12px; color: #ccc; cursor: pointer;  margin-right: 15px;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#ccc'">All</span>
            <span id="select-none-filters" style="font-size: 12px; color: #ccc; cursor: pointer;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#ccc'">None</span>
          </div>
          <div style="display: flex; gap: 15px;">
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;  cursor: pointer;">
              <input type="checkbox" id="filter-win" checked style="width: 14px; height: 14px;">
              Win
            </label>
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; cursor: pointer;">
              <input type="checkbox" id="filter-loss" checked style="width: 14px; height: 14px;">
              Loss
            </label>
          </div>
        </div>
      </div>
    </div>

    <div class="panel-container" style="width: 50%; height: 110px;">
      <div class="panel-header">Summary</div>
      <div class="panel-content" id="summary-content" style="display: flex; justify-content: space-around; padding: 10px;">
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Trades</div>
          <div id="trade-count" style="font-size: 18px; font-weight: bold; color: white;">0</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Avg Prob</div>
          <div id="avg-prob" style="font-size: 18px; font-weight: bold; color: white;">0.00</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">W/L %</div>
          <div id="win-loss-percentage" style="font-size: 18px; font-weight: bold; color: white;">0%</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Ret %</div>
          <div id="ret-percentage" style="font-size: 18px; font-weight: bold; color: white;">0.00%</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">PnL</div>
          <div id="total-pnl" style="font-size: 18px; font-weight: bold; color: white;">$0.00</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel-container" style="height: calc(100vh - 140px); display: flex; flex-direction: column;">
    <div class="panel-header">Results</div>
    <div style="flex: 1; overflow-y: auto;">
      <table id="trade-log-table" aria-label="Trade Log Table" style="position: relative;">
        <thead>
          <tr class="th">
            <th data-key="id">ID</th>
            <th data-key="status">Status</th>
            <th data-key="date">Date</th>
            <th data-key="time">Time</th>
            <th data-key="symbol">Symbol</th>
            <th data-key="trade_strategy">Strategy</th>
            <th data-key="contract">Contract</th>
            <th data-key="strike">Strike</th>
            <th data-key="side">Side</th>
            <th data-key="prob">Prob</th>
            <th data-key="diff">Diff</th>
            <th data-key="buy_price">Buy</th>
            <th data-key="sell_price">Sell</th>
            <th data-key="position">Position</th>
            <th data-key="fees">Fees</th>
            <th data-key="pnl">PnL</th>
            <th data-key="closed_at">Closed</th>
            <th data-key="symbol_open">Symbol Open</th>
            <th data-key="symbol_close">Symbol Close</th>
            <th data-key="momentum">Mom</th>
            
            <th data-key="win_loss">W/L</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    let currentSort = { key: null, asc: true };
    let trades = [];
    let filteredTrades = [];

    function displayPnL(trade) {
      if (trade.pnl !== null && trade.pnl !== undefined) {
        return Number(trade.pnl).toFixed(2);
      }
      return '';
    }

    // === DATE FILTER LOGIC ===
    function filterTradesByDate(trades, filter) {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const today = `${year}-${month}-${day}`;
      // Helper to get the date string for a given day of week in this week
      function getDateOfThisWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        const diff = dayOfWeek - currDay;
        curr.setDate(curr.getDate() + diff);
        return formatDate(curr);
      }
      // Helper to get the date string for a given day of week in last week
      function getDateOfLastWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        // Go to previous Sunday, then add dayOfWeek
        curr.setDate(curr.getDate() - currDay - 7 + dayOfWeek);
        return formatDate(curr);
      }
      // Helper to get the latest Sunday (start of this week)
      function getLatestSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay());
        return formatDate(curr);
      }
      // Helper to get previous Sunday (start of last week)
      function getPrevSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 7);
        return formatDate(curr);
      }
      // Helper to get following Saturday (end of last week)
      function getNextSaturdayOfPrevWeek() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 1); // previous Saturday
        return formatDate(curr);
      }
      return trades.filter(trade => {
        if (!trade.date) return false;
        switch (filter) {
          case 'TODAY':
            return trade.date === today;
          case 'THIS_WEEK': {
            const sunday = getLatestSunday();
            return trade.date >= sunday && trade.date <= today;
          }
          case 'SUNDAY':
            return trade.date === getDateOfThisWeek(0);
          case 'MONDAY':
            return trade.date === getDateOfThisWeek(1);
          case 'TUESDAY':
            return trade.date === getDateOfThisWeek(2);
          case 'WEDNESDAY':
            return trade.date === getDateOfThisWeek(3);
          case 'THURSDAY':
            return trade.date === getDateOfThisWeek(4);
          case 'FRIDAY':
            return trade.date === getDateOfThisWeek(5);
          case 'SATURDAY':
            return trade.date === getDateOfThisWeek(6);
          case 'LAST_WEEK': {
            const prevSunday = getPrevSunday();
            const nextSaturday = getNextSaturdayOfPrevWeek();
            return trade.date >= prevSunday && trade.date <= nextSaturday;
          }
          case 'MONTH': {
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthStartStr = formatDate(monthStart);
            return trade.date >= monthStartStr && trade.date <= today;
          }
          case 'PREV_30': {
            const prev30 = new Date(now);
            prev30.setDate(now.getDate() - 30);
            const prev30Str = formatDate(prev30);
            return trade.date >= prev30Str && trade.date <= today;
          }
          case 'YTD': {
            const ytdStr = `${year}-01-01`;
            return trade.date >= ytdStr && trade.date <= today;
          }
          case 'PREV_YEAR': {
            const prevYear = new Date(now);
            prevYear.setFullYear(now.getFullYear() - 1);
            const prevYearStr = formatDate(prevYear);
            return trade.date >= prevYearStr && trade.date <= today;
          }
          case 'CUSTOM':
            return true;
          default:
            return true;
        }
      });
    }
    
    // === WIN/LOSS FILTER LOGIC ===
    function filterTradesByWinLoss(trades) {
      const showWin = document.getElementById('filter-win').checked;
      const showLoss = document.getElementById('filter-loss').checked;
      
      return trades.filter(trade => {
        const winLoss = trade.win_loss;
        if (winLoss === 'W' || winLoss === 'Win') {
          return showWin;
        } else if (winLoss === 'L' || winLoss === 'Loss') {
          return showLoss;
        }
        // If win_loss is null/undefined/empty, show it regardless of filters
        return true;
      });
    }
    
    // Helper function to format date as YYYY-MM-DD
    function formatDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function applyCurrentSort() {
      if (currentSort.key === null) return;

      filteredTrades.sort((a, b) => {
        let valA = a[currentSort.key];
        let valB = b[currentSort.key];

        // Normalize side values for sorting
        if (currentSort.key === 'side') {
          const mapSide = v => (v === 'Yes' || v === 'Y' ? 'Y' : v === 'No' || v === 'N' ? 'N' : '');
          valA = mapSide(valA);
          valB = mapSide(valB);
        }

        // Normalize null/undefined to empty string
        if (valA === null || valA === undefined) valA = '';
        if (valB === null || valB === undefined) valB = '';

        // Try to parse as numbers for numeric fields
        const numericKeys = ['id', 'strike', 'buy_price', 'sell_price', 'position', 'symbol_open', 'symbol_close', 'momentum', 'win_loss', 'pnl', 'prob', 'diff'];
        if (numericKeys.includes(currentSort.key)) {
          valA = Number(valA);
          valB = Number(valB);
          if (isNaN(valA)) valA = -Infinity;
          if (isNaN(valB)) valB = -Infinity;
        }

        // For date and time, compare as strings (assuming ISO or consistent format)
        // For other strings, localeCompare
        if (typeof valA === 'string' && typeof valB === 'string') {
          const cmp = valA.localeCompare(valB);
          return currentSort.asc ? cmp : -cmp;
        } else {
          if (valA < valB) return currentSort.asc ? -1 : 1;
          if (valA > valB) return currentSort.asc ? 1 : -1;
          return 0;
        }
      });
    }

    function sortTrades(key) {
      if (currentSort.key === key) {
        currentSort.asc = !currentSort.asc;
      } else {
        currentSort.key = key;
        currentSort.asc = true;
      }
      applyCurrentSort();
      renderTrades(filteredTrades);
    }

    function updateSummary(trades) {
      const tradeCountEl = document.getElementById('trade-count');
      const avgProbEl = document.getElementById('avg-prob');
      const winLossEl = document.getElementById('win-loss-percentage');
      const retPercentageEl = document.getElementById('ret-percentage');
      const totalPnlEl = document.getElementById('total-pnl');
      
      if (!Array.isArray(trades) || trades.length === 0) {
        tradeCountEl.textContent = '0';
        avgProbEl.textContent = '0.00';
        winLossEl.textContent = '0%';
        retPercentageEl.textContent = '0.00%';
        totalPnlEl.textContent = '$0.00';
        return;
      }
      
      // Count total trades
      const tradeCount = trades.length;
      
      // Calculate average probability
      let totalProb = 0;
      let probCount = 0;
      trades.forEach(trade => {
        if (trade.prob !== null && trade.prob !== undefined && trade.prob !== '') {
          const prob = Number(trade.prob);
          if (!isNaN(prob)) {
            totalProb += prob;
            probCount++;
          }
        }
      });
      const avgProb = probCount > 0 ? (totalProb / probCount) : 0; // Keep as percentage
      
      // Calculate win/loss percentage
      let winCount = 0;
      let totalTrades = 0;
      
      trades.forEach(trade => {
        if (trade.win_loss !== null && trade.win_loss !== undefined && trade.win_loss !== '') {
          // win_loss is stored as 'W' for win, 'L' for loss
          if (trade.win_loss === 'W' || trade.win_loss === 'L') {
            totalTrades++;
            if (trade.win_loss === 'W') winCount++;
          }
        }
      });
      
      const winPercentage = totalTrades > 0 ? ((winCount / totalTrades) * 100) : 0;
      
      // Calculate Ret %: total PNL + FEES PAID, display as percent (e.g., $5.00 is 5.00%)
      let totalPnl = 0;
      let totalFees = 0;
      trades.forEach(trade => {
        if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '') {
          const pnl = Number(trade.pnl);
          if (!isNaN(pnl)) {
            totalPnl += pnl;
          }
        }
        if (trade.fees !== null && trade.fees !== undefined && trade.fees !== '') {
          const fees = Number(trade.fees);
          if (!isNaN(fees)) {
            totalFees += fees;
          }
        }
      });
      const retValue = totalPnl + totalFees;
      const retPercentage = retValue.toFixed(2) + '%';
      
      // Calculate total PnL and total investment (for display only)
      let totalPnlDisplay = 0;
      trades.forEach(trade => {
        if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '') {
          const pnl = Number(trade.pnl);
          if (!isNaN(pnl)) {
            totalPnlDisplay += pnl;
          }
        }
      });
      
      // Update the display
      tradeCountEl.textContent = tradeCount.toString();
      avgProbEl.textContent = `${avgProb.toFixed(1)}%`;
      winLossEl.textContent = `${winPercentage.toFixed(1)}%`;
      retPercentageEl.textContent = retPercentage;
      totalPnlEl.textContent = `$${totalPnlDisplay.toFixed(2)}`;
      
      // Color coding for Ret %
      if (retValue > 0) {
        retPercentageEl.style.color = '#28a745'; // Green for positive
      } else if (retValue < 0) {
        retPercentageEl.style.color = '#dc3545'; // Red for negative
      } else {
        retPercentageEl.style.color = 'white'; // White for zero
      }
      // Color coding for PnL
      if (totalPnlDisplay > 0) {
        totalPnlEl.style.color = '#28a745'; // Green for positive
      } else if (totalPnlDisplay < 0) {
        totalPnlEl.style.color = '#dc3545'; // Red for negative
      } else {
        totalPnlEl.style.color = 'white'; // White for zero
      }
    }

    function renderTrades(tradesToRender) {
      const tbody = document.querySelector('#trade-log-table tbody');
      tbody.innerHTML = '';
      if (!Array.isArray(tradesToRender) || tradesToRender.length === 0) {
        tbody.innerHTML = '<tr><td colspan="22">No trades found.</td></tr>';
        updateSummary(tradesToRender); // Update summary even when no trades
        return;
      }

      let lastContract = null;
      let groupIndex = 0;
      for (const trade of tradesToRender) {
        const isNewGroup = trade.contract !== lastContract;
        if (isNewGroup) {
          groupIndex++;
        }
        lastContract = trade.contract;
        const tr = document.createElement('tr');
        tr.style.borderTop = isNewGroup ? '2px solid #666' : '';
        // Assign group-odd or group-even class based on groupIndex
        tr.classList.add(groupIndex % 2 === 1 ? 'group-odd' : 'group-even');
        // Helper to format numbers with + sign for positive values, no decimals
        function plusSign(val) {
          if (val === null || val === undefined || val === '') return '';
          const num = Number(val);
          if (isNaN(num)) return val;
          return (num > 0 ? '+' : '') + Math.round(num);
        }
        tr.innerHTML = `
          <td>${trade.id !== null ? trade.id : ''}</td>
          <td>${trade.status !== null ? trade.status : ''}</td>
          <td>${trade.date !== null ? trade.date : ''}</td>
          <td>${trade.time !== null ? trade.time : ''}</td>
          <td>${trade.symbol !== null ? trade.symbol : ''}</td>
          <td>${trade.trade_strategy !== null ? trade.trade_strategy : ''}</td>
          <td>${trade.contract !== null ? trade.contract : ''}</td>
          <td>${trade.strike !== null ? trade.strike : ''}</td>
          <td>${trade.side === 'Yes' || trade.side === 'Y' ? 'Y' : trade.side === 'No' || trade.side === 'N' ? 'N' : ''}</td>
          <td>${trade.prob !== null && trade.prob !== undefined && trade.prob !== '' ? (Number(trade.prob) / 100).toFixed(2) : ''}</td>
          <td>${plusSign(trade.diff)}</td>
          <td>${trade.buy_price !== null ? Number(trade.buy_price).toFixed(2) : ''}</td>
          <td>${trade.sell_price !== null ? Number(trade.sell_price).toFixed(2) : ''}</td>
          <td>${trade.position !== null ? trade.position : ''}</td>
          <td>${trade.fees !== null ? Number(trade.fees).toFixed(2) : ''}</td>
          <td>${trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '' ? Number(trade.pnl).toFixed(2) : ''}</td>
          <td>${trade.closed_at !== null ? trade.closed_at : ''}</td>
          <td>${trade.symbol_open !== null ? '$' + Math.round(trade.symbol_open).toLocaleString() : ''}</td>
          <td>${trade.symbol_close !== null ? '$' + Math.round(trade.symbol_close).toLocaleString() : ''}</td>
          <td>${plusSign(trade.momentum)}</td>
          
          <td>${plusSign(trade.win_loss)}</td>
        `;
        tbody.appendChild(tr);
      }
      
      // Update summary statistics
      updateSummary(tradesToRender);
    }

    function applyFilters() {
      const dateFilterPicker = document.getElementById('date-filter-picker');
      let filtered = filterTradesByDate(trades, dateFilterPicker ? dateFilterPicker.value : 'TODAY');
      filtered = filterTradesByWinLoss(filtered);
      
      if (currentSort.key !== null) {
        filteredTrades = [...filtered];
        applyCurrentSort();
      } else {
        filteredTrades = filtered;
      }
      renderTrades(filteredTrades);
    }

    async function fetchAllTrades() {
      console.log('Fetching trades at', new Date().toLocaleTimeString());
      try {
        // Use the centralized port system
        const apiBaseUrl = getMainAppUrl();
        
        const res = await fetch(`${apiBaseUrl}/trades`, { cache: 'no-store' });
        if (!res.ok) throw new Error('Network response was not ok');
        trades = await res.json();
        applyFilters();
      } catch (error) {
        const tbody = document.querySelector('#trade-log-table tbody');
        tbody.innerHTML = `<tr><td colspan="22" style="color:red;">Failed to load trades: ${error.message}</td></tr>`;
        console.error('Error fetching trades:', error);
      }
    }

    // Hook up the filter to the dropdown
    const dateFilterPicker = document.getElementById('date-filter-picker');
    if (dateFilterPicker) {
      dateFilterPicker.addEventListener('change', applyFilters);
    }



    // Update day names in dropdown based on current date (no longer needed, so comment out)
    // function updateDayNames() {
    //   const dayOptions = document.querySelectorAll('#date-filter-picker option[value^="DAY-"]');
    //   const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      
    //   dayOptions.forEach((option, index) => {
    //     const daysAgo = index + 1;
    //     const date = new Date();
    //     date.setDate(date.getDate() - daysAgo);
    //     const dayName = dayNames[date.getDay()];
    //     option.textContent = `- ${dayName}`;
    //   });
    // }
    
    // Update date range display
    async function updateDateRangeDisplay() {
      const filterPicker = document.getElementById('date-filter-picker');
      const display = document.getElementById('date-range-display');
      if (!filterPicker || !display) return;
      const selectedValue = filterPicker.value;
      const now = new Date();
      let rangeText = '';
      function getDateOfThisWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        const diff = dayOfWeek - currDay;
        curr.setDate(curr.getDate() + diff);
        return formatDate(curr);
      }
      function getDateOfLastWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        curr.setDate(curr.getDate() - currDay - 7 + dayOfWeek);
        return formatDate(curr);
      }
      function getLatestSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay());
        return formatDate(curr);
      }
      function getPrevSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 7);
        return formatDate(curr);
      }
      function getNextSaturdayOfPrevWeek() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 1);
        return formatDate(curr);
      }
      switch (selectedValue) {
        case 'ALL':
          try {
            const apiBaseUrl = getMainAppUrl();
            const response = await fetch(`${apiBaseUrl}/api/earliest_trade_date`);
            if (response.ok) {
              const data = await response.json();
              if (data.earliest_date) {
                const todayStr = formatDate(now);
                rangeText = `${data.earliest_date} to ${todayStr}`;
              } else {
                rangeText = '';
              }
            } else {
              rangeText = '';
            }
          } catch (error) {
            console.error('Error fetching earliest trade date:', error);
            rangeText = '';
          }
          break;
        case 'TODAY':
          rangeText = formatDate(now);
          break;
        case 'THIS_WEEK': {
          const sunday = getLatestSunday();
          const todayStr = formatDate(now);
          rangeText = `${sunday} to ${todayStr}`;
          break;
        }
        case 'SUNDAY':
          rangeText = getDateOfThisWeek(0);
          break;
        case 'MONDAY':
          rangeText = getDateOfThisWeek(1);
          break;
        case 'TUESDAY':
          rangeText = getDateOfThisWeek(2);
          break;
        case 'WEDNESDAY':
          rangeText = getDateOfThisWeek(3);
          break;
        case 'THURSDAY':
          rangeText = getDateOfThisWeek(4);
          break;
        case 'FRIDAY':
          rangeText = getDateOfThisWeek(5);
          break;
        case 'SATURDAY':
          rangeText = getDateOfThisWeek(6);
          break;
        case 'LAST_WEEK': {
          const prevSunday = getPrevSunday();
          const nextSaturday = getNextSaturdayOfPrevWeek();
          rangeText = `${prevSunday} to ${nextSaturday}`;
          break;
        }
        case 'MONTH': {
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const monthStartStr = formatDate(monthStart);
          const todayStr2 = formatDate(now);
          rangeText = `${monthStartStr} to ${todayStr2}`;
          break;
        }
        case 'PREV_30': {
          const prev30 = new Date(now);
          prev30.setDate(now.getDate() - 30);
          const prev30Str = formatDate(prev30);
          const todayStr3 = formatDate(now);
          rangeText = `${prev30Str} to ${todayStr3}`;
          break;
        }
        case 'YTD': {
          const ytdStart = `${now.getFullYear()}-01-01`;
          const todayStr4 = formatDate(now);
          rangeText = `${ytdStart} to ${todayStr4}`;
          break;
        }
        case 'PREV_YEAR': {
          const prevYear = new Date(now);
          prevYear.setFullYear(now.getFullYear() - 1);
          const prevYearStr = formatDate(prevYear);
          const todayStr5 = formatDate(now);
          rangeText = `${prevYearStr} to ${todayStr5}`;
          break;
        }
        case 'CUSTOM':
          rangeText = '';
          break;
        default:
          rangeText = '';
      }
      display.textContent = rangeText;
    }

    // On initial load, show filtered trades
    window.addEventListener('DOMContentLoaded', async () => {
      // updateDayNames(); // Update day names
      await updateDateRangeDisplay(); // Update date range display
      fetchAllTrades();
      setInterval(fetchAllTrades, 1000);

      // Add event listener for dropdown changes
      const filterPicker = document.getElementById('date-filter-picker');
      if (filterPicker) {
        filterPicker.addEventListener('change', () => {
          updateDateRangeDisplay();
        });
      }

      const headers = document.querySelectorAll('#trade-log-table thead th');
      headers.forEach(th => {
        th.classList.add('sortable');
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-key');
          if (key) {
            sortTrades(key);
          }
        });
      });

      // Hook up Win/Loss filter checkboxes
      const filterWin = document.getElementById('filter-win');
      const filterLoss = document.getElementById('filter-loss');
      if (filterWin) {
        filterWin.addEventListener('change', applyFilters);
      }
      if (filterLoss) {
        filterLoss.addEventListener('change', applyFilters);
      }

      // Hook up All/None buttons
      const selectAllBtn = document.getElementById('select-all-filters');
      const selectNoneBtn = document.getElementById('select-none-filters');
      
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
          if (filterWin) filterWin.checked = true;
          if (filterLoss) filterLoss.checked = true;
          applyFilters();
        });
      }
      
      if (selectNoneBtn) {
        selectNoneBtn.addEventListener('click', () => {
          if (filterWin) filterWin.checked = false;
          if (filterLoss) filterLoss.checked = false;
          applyFilters();
        });
      }
    });
  </script>
</body>
</html>