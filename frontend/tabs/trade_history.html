<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trade History</title>
  <link rel="stylesheet" href="/styles/global.css" />
  <script src="/js/globals.js"></script>
  <style>
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.7rem;
    }
    th, td {
      border: 1px solid #787878;
      padding: 6px 10px;
      text-align: center;
    }
    th {
      background-color: #1f2530;
      font-weight: bold;
      font-size: 0.7rem;
      cursor: pointer;
      position: relative;
    }
    th .sort-indicator {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
    }
    tbody tr:nth-child(even) {
      /* background-color: #323c4e; */
    }
    caption {
      font-size: 1.2rem;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .group-odd {
      background-color: #394559;
    }
    .group-even {
      background-color: #1f2633;
    }
    tbody tr:hover {
      background-color: #4d586f !important;
      cursor: pointer;
    }

    th.sortable::after {
      content: '';
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 5px;
      border: 4px solid transparent;
      border-top-color: #ccc;
      vertical-align: middle;
      opacity: 0;
      transition: opacity 0.2s;
    }

    th.sortable:hover::after {
      opacity: 1;
    }
  </style>
</head>
<body>

  <div style="display: flex; gap: 10px;">
    <div class="panel-container" style="width: 50%; height: 110px;">
      <div class="panel-header">Search</div>
      <div style="margin-top: 10px; display: flex; gap: 20px; align-items: flex-start;">
        <div>
          <select id="date-filter-picker" class="dropdown-picker" style="width: 180px;">
            <option value="ALL">All</option>
            <option value="TODAY">Today</option>
            <option value="THIS_WEEK">This Week</option>
            <option value="SUNDAY">- Sunday</option>
            <option value="MONDAY">- Monday</option>
            <option value="TUESDAY">- Tuesday</option>
            <option value="WEDNESDAY">- Wednesday</option>
            <option value="THURSDAY">- Thursday</option>
            <option value="FRIDAY">- Friday</option>
            <option value="SATURDAY">- Saturday</option>
            <option value="LAST_WEEK">Last Week</option>
            <option value="MONTH">This Month</option>
            <option value="PREV_30">Prev 30</option>
            <option value="YTD">YTD</option>
            <option value="PREV_YEAR">Prev Year</option>
            <option value="CUSTOM">Custom</option>
          </select>
          <div id="date-range-display" style="margin-top: 10px; margin-left: 10px;font-size: 12px; color: #ccc;"></div>
        </div>
        <div>
          <div style="margin-bottom: 5px;">
            <span id="select-all-filters" style="font-size: 12px; color: #ccc; cursor: pointer;  margin-right: 15px;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#ccc'">All</span>
            <span id="select-none-filters" style="font-size: 12px; color: #ccc; cursor: pointer;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#ccc'">None</span>
          </div>
          <div style="display: flex; gap: 15px;">
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px;  cursor: pointer;">
              <input type="checkbox" id="filter-win" checked style="width: 14px; height: 14px;">
              Win
            </label>
            <label style="display: flex; align-items: center; gap: 5px; font-size: 12px; cursor: pointer;">
              <input type="checkbox" id="filter-loss" checked style="width: 14px; height: 14px;">
              Loss
            </label>
          </div>
        </div>
        <div>
          <div style="margin-bottom: 5px; font-size: 12px; color: #ccc;">TTC Filter (minutes)</div>
          <input type="number" id="ttc-filter" min="0" max="60" value="60" style="width: 80px; padding: 4px; font-size: 12px; background: #2a3441; border: 1px solid #4a5568; color: white; border-radius: 3px;">
        </div>
      </div>
    </div>

    <div class="panel-container" style="width: 50%; height: 110px;">
      <div class="panel-header">Summary</div>
      <div class="panel-content" id="summary-content" style="display: flex; justify-content: space-around; padding: 10px;">
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Trades</div>
          <div id="trade-count" style="font-size: 18px; font-weight: bold; color: white;">0</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">W/L %</div>
          <div id="win-loss-percentage" style="font-size: 18px; font-weight: bold; color: white;">0%</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Avg Prob</div>
          <div id="avg-prob" style="font-size: 18px; font-weight: bold; color: white;">0.00</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Avg Buy</div>
          <div id="avg-buy" style="font-size: 18px; font-weight: bold; color: white;">0.00</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Avg Diff</div>
          <div id="avg-diff" style="font-size: 18px; font-weight: bold; color: white;">0.00</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Ret %</div>
          <div id="ret-percentage" style="font-size: 18px; font-weight: bold; color: white;">0.00%</div>
        </div>
        <div style="text-align: center;">
          <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">PnL</div>
          <div id="total-pnl" style="font-size: 18px; font-weight: bold; color: white;">$0.00</div>
        </div>
      </div>
    </div>
  </div>

  <div class="panel-container" style="height: calc(100vh - 140px); display: flex; flex-direction: column;">
    <div class="panel-header">Results</div>
    <div style="flex: 1; overflow-y: auto;">
      <table id="trade-log-table" aria-label="Trade Log Table" style="position: relative;">
        <thead>
          <tr class="th">
            <th data-key="id">ID</th>
            <th data-key="status">Status</th>
            <th data-key="date">Date</th>
            <th data-key="time">Time</th>
            <th data-key="symbol">Symbol</th>
            <th data-key="trade_strategy">Strategy</th>
            <th data-key="contract">Contract</th>
            <th data-key="strike">Strike</th>
            <th data-key="side">Side</th>
            <th data-key="prob">Prob</th>
            <th data-key="diff">Diff</th>
            <th data-key="buy_price">Buy</th>
            <th data-key="sell_price">Sell</th>
            <th data-key="position">Position</th>
            <th data-key="fees">Fees</th>
            <th data-key="pnl">PnL</th>
            <th data-key="closed_at">Closed</th>
            <th data-key="symbol_open">Symbol Open</th>
            <th data-key="symbol_close">Symbol Close</th>
            <th data-key="momentum">Mom</th>
            
            <th data-key="win_loss">W/L</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    let currentSort = { key: 'id', asc: false };
    let trades = [];
    let filteredTrades = [];

    function displayPnL(trade) {
      if (trade.pnl !== null && trade.pnl !== undefined) {
        return Number(trade.pnl).toFixed(2);
      }
      return '';
    }

    // === DATE FILTER LOGIC ===
    function filterTradesByDate(trades, filter) {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const today = `${year}-${month}-${day}`;
      // Helper to get the date string for a given day of week in this week
      function getDateOfThisWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        const diff = dayOfWeek - currDay;
        curr.setDate(curr.getDate() + diff);
        return formatDate(curr);
      }
      // Helper to get the date string for a given day of week in last week
      function getDateOfLastWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        // Go to previous Sunday, then add dayOfWeek
        curr.setDate(curr.getDate() - currDay - 7 + dayOfWeek);
        return formatDate(curr);
      }
      // Helper to get the latest Sunday (start of this week)
      function getLatestSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay());
        return formatDate(curr);
      }
      // Helper to get previous Sunday (start of last week)
      function getPrevSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 7);
        return formatDate(curr);
      }
      // Helper to get following Saturday (end of last week)
      function getNextSaturdayOfPrevWeek() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 1); // previous Saturday
        return formatDate(curr);
      }
      return trades.filter(trade => {
        if (!trade.date) return false;
        switch (filter) {
          case 'TODAY':
            return trade.date === today;
          case 'THIS_WEEK': {
            const sunday = getLatestSunday();
            return trade.date >= sunday && trade.date <= today;
          }
          case 'SUNDAY':
            return trade.date === getDateOfThisWeek(0);
          case 'MONDAY':
            return trade.date === getDateOfThisWeek(1);
          case 'TUESDAY':
            return trade.date === getDateOfThisWeek(2);
          case 'WEDNESDAY':
            return trade.date === getDateOfThisWeek(3);
          case 'THURSDAY':
            return trade.date === getDateOfThisWeek(4);
          case 'FRIDAY':
            return trade.date === getDateOfThisWeek(5);
          case 'SATURDAY':
            return trade.date === getDateOfThisWeek(6);
          case 'LAST_WEEK': {
            const prevSunday = getPrevSunday();
            const nextSaturday = getNextSaturdayOfPrevWeek();
            return trade.date >= prevSunday && trade.date <= nextSaturday;
          }
          case 'MONTH': {
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthStartStr = formatDate(monthStart);
            return trade.date >= monthStartStr && trade.date <= today;
          }
          case 'PREV_30': {
            const prev30 = new Date(now);
            prev30.setDate(now.getDate() - 30);
            const prev30Str = formatDate(prev30);
            return trade.date >= prev30Str && trade.date <= today;
          }
          case 'YTD': {
            const ytdStr = `${year}-01-01`;
            return trade.date >= ytdStr && trade.date <= today;
          }
          case 'PREV_YEAR': {
            const prevYear = new Date(now);
            prevYear.setFullYear(now.getFullYear() - 1);
            const prevYearStr = formatDate(prevYear);
            return trade.date >= prevYearStr && trade.date <= today;
          }
          case 'CUSTOM':
            return true;
          default:
            return true;
        }
      });
    }
    
    // === WIN/LOSS FILTER LOGIC ===
    function filterTradesByWinLoss(trades) {
      const showWin = document.getElementById('filter-win').checked;
      const showLoss = document.getElementById('filter-loss').checked;
      
      return trades.filter(trade => {
        const winLoss = trade.win_loss;
        if (winLoss === 'W' || winLoss === 'Win') {
          return showWin;
        } else if (winLoss === 'L' || winLoss === 'Loss') {
          return showLoss;
        }
        // If win_loss is null/undefined/empty, show it regardless of filters
        return true;
      });
    }
    
    // === TTC FILTER LOGIC ===
    function filterTradesByTTC(trades) {
      const ttcFilter = document.getElementById('ttc-filter');
      if (!ttcFilter) return trades;
      
      const maxTTC = parseInt(ttcFilter.value);
      if (isNaN(maxTTC) || maxTTC < 0 || maxTTC > 60) return trades;
      
      return trades.filter(trade => {
        // Check if trade has required data for TTC calculation
        if (!trade.time) {
          return true; // Show trades without time data
        }
        
        try {
          // Parse the trade time (format like "12:50:07")
          const timeParts = trade.time.split(':');
          if (timeParts.length !== 3) return true;
          
          const tradeHour = parseInt(timeParts[0]);
          const tradeMinute = parseInt(timeParts[1]);
          const tradeSecond = parseInt(timeParts[2]);
          
          if (isNaN(tradeHour) || isNaN(tradeMinute) || isNaN(tradeSecond)) {
            return true; // Show trades with invalid time format
          }
          
          // Calculate total minutes from trade time
          const tradeTimeMinutes = tradeHour * 60 + tradeMinute + tradeSecond / 60;
          
          // For hourly contracts, closing time is the next hour
          // So if trade is at 12:50:07, TTC is 9 minutes and 53 seconds
          const nextHour = tradeHour + 1;
          const closeTimeMinutes = nextHour * 60; // Next hour at :00
          
          let ttcMinutes = closeTimeMinutes - tradeTimeMinutes;
          
          // Handle edge case where trade is at 23:xx (next hour would be 0)
          if (nextHour >= 24) {
            ttcMinutes = (24 * 60) - tradeTimeMinutes;
          }
          
          // Convert to total minutes for comparison
          return ttcMinutes <= maxTTC;
        } catch (error) {
          console.warn('Error calculating TTC for trade:', trade.id, error);
          return true; // Show trades with calculation errors
        }
      });
    }
    
    // Helper function to format date as YYYY-MM-DD
    function formatDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function applyCurrentSort() {
      if (currentSort.key === null) return;

      filteredTrades.sort((a, b) => {
        let valA = a[currentSort.key];
        let valB = b[currentSort.key];

        // Normalize side values for sorting
        if (currentSort.key === 'side') {
          const mapSide = v => (v === 'Yes' || v === 'Y' ? 'Y' : v === 'No' || v === 'N' ? 'N' : '');
          valA = mapSide(valA);
          valB = mapSide(valB);
        }

        // Normalize null/undefined to empty string
        if (valA === null || valA === undefined) valA = '';
        if (valB === null || valB === undefined) valB = '';

        // Try to parse as numbers for numeric fields
        const numericKeys = ['id', 'strike', 'buy_price', 'sell_price', 'position', 'symbol_open', 'symbol_close', 'momentum', 'win_loss', 'pnl', 'prob', 'diff'];
        if (numericKeys.includes(currentSort.key)) {
          valA = Number(valA);
          valB = Number(valB);
          if (isNaN(valA)) valA = -Infinity;
          if (isNaN(valB)) valB = -Infinity;
        }

        // For date and time, compare as strings (assuming ISO or consistent format)
        // For other strings, localeCompare
        if (typeof valA === 'string' && typeof valB === 'string') {
          const cmp = valA.localeCompare(valB);
          return currentSort.asc ? cmp : -cmp;
        } else {
          if (valA < valB) return currentSort.asc ? -1 : 1;
          if (valA > valB) return currentSort.asc ? 1 : -1;
          return 0;
        }
      });
    }

    function sortTrades(key) {
      if (currentSort.key === key) {
        currentSort.asc = !currentSort.asc;
      } else {
        currentSort.key = key;
        currentSort.asc = true;
      }
      applyCurrentSort();
      renderTrades(filteredTrades);
    }

    function updateSummary(trades) {
      const tradeCountEl = document.getElementById('trade-count');
      const avgProbEl = document.getElementById('avg-prob');
      const winLossEl = document.getElementById('win-loss-percentage');
      const avgBuyEl = document.getElementById('avg-buy');
      const avgDiffEl = document.getElementById('avg-diff');
      const retPercentageEl = document.getElementById('ret-percentage');
      const totalPnlEl = document.getElementById('total-pnl');
      
      if (!Array.isArray(trades) || trades.length === 0) {
        tradeCountEl.textContent = '0';
        avgProbEl.textContent = '0.00';
        winLossEl.textContent = '0%';
        avgBuyEl.textContent = '0.00';
        avgDiffEl.textContent = '0.00';
        retPercentageEl.textContent = '0.00%';
        totalPnlEl.textContent = '$0.00';
        return;
      }
      
      // Count total trades
      const tradeCount = trades.length;
      
      // Calculate average probability
      let totalProb = 0;
      let probCount = 0;
      trades.forEach(trade => {
        if (trade.prob !== null && trade.prob !== undefined && trade.prob !== '') {
          const prob = Number(trade.prob);
          if (!isNaN(prob)) {
            totalProb += prob;
            probCount++;
          }
        }
      });
      const avgProb = probCount > 0 ? (totalProb / probCount) : 0; // Keep as percentage
      
      // Calculate win/loss percentage
      let winCount = 0;
      let totalTrades = 0;
      
      trades.forEach(trade => {
        if (trade.win_loss !== null && trade.win_loss !== undefined && trade.win_loss !== '') {
          // win_loss is stored as 'W' for win, 'L' for loss
          if (trade.win_loss === 'W' || trade.win_loss === 'L') {
            totalTrades++;
            if (trade.win_loss === 'W') winCount++;
          }
        }
      });
      
      const winPercentage = totalTrades > 0 ? ((winCount / totalTrades) * 100) : 0;
      
      // Calculate average diff
      let totalDiff = 0;
      let diffCount = 0;
      trades.forEach(trade => {
        if (trade.diff !== null && trade.diff !== undefined && trade.diff !== '') {
          const diff = Number(trade.diff);
          if (!isNaN(diff)) {
            totalDiff += diff;
            diffCount++;
          }
        }
      });
      const avgDiff = diffCount > 0 ? (totalDiff / diffCount) : 0;
      
      // Calculate average buy price
      let totalBuy = 0;
      let buyCount = 0;
      trades.forEach(trade => {
        if (trade.buy_price !== null && trade.buy_price !== undefined && trade.buy_price !== '') {
          const buyPrice = Number(trade.buy_price);
          if (!isNaN(buyPrice)) {
            totalBuy += buyPrice;
            buyCount++;
          }
        }
      });
      const avgBuy = buyCount > 0 ? (totalBuy / buyCount) : 0;
      
      // Calculate Ret %: total PNL + FEES PAID, display as percent (e.g., $5.00 is 5.00%)
      let totalPnl = 0;
      let totalFees = 0;
      trades.forEach(trade => {
        if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '') {
          const pnl = Number(trade.pnl);
          if (!isNaN(pnl)) {
            totalPnl += pnl;
          }
        }
        if (trade.fees !== null && trade.fees !== undefined && trade.fees !== '') {
          const fees = Number(trade.fees);
          if (!isNaN(fees)) {
            totalFees += fees;
          }
        }
      });
      const retValue = totalPnl + totalFees;
      const retPercentage = retValue.toFixed(2) + '%';
      
      // Calculate total PnL and total investment (for display only)
      let totalPnlDisplay = 0;
      trades.forEach(trade => {
        if (trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '') {
          const pnl = Number(trade.pnl);
          if (!isNaN(pnl)) {
            totalPnlDisplay += pnl;
          }
        }
      });
      
      // Update the display
      tradeCountEl.textContent = tradeCount.toString();
      avgProbEl.textContent = `${avgProb.toFixed(1)}%`;
      winLossEl.textContent = `${winPercentage.toFixed(1)}%`;
      avgBuyEl.textContent = `${avgBuy.toFixed(2)}`;
      avgDiffEl.textContent = `${avgDiff > 0 ? '+' : ''}${avgDiff.toFixed(1)}`;
      retPercentageEl.textContent = retPercentage;
      totalPnlEl.textContent = `$${totalPnlDisplay.toFixed(2)}`;
      
      // Color coding for Ret %
      if (retValue > 0) {
        retPercentageEl.style.color = '#28a745'; // Green for positive
      } else if (retValue < 0) {
        retPercentageEl.style.color = '#dc3545'; // Red for negative
      } else {
        retPercentageEl.style.color = 'white'; // White for zero
      }
      // Color coding for PnL
      if (totalPnlDisplay > 0) {
        totalPnlEl.style.color = '#28a745'; // Green for positive
      } else if (totalPnlDisplay < 0) {
        totalPnlEl.style.color = '#dc3545'; // Red for negative
      } else {
        totalPnlEl.style.color = 'white'; // White for zero
      }
    }

    function renderTrades(tradesToRender) {
      const tbody = document.querySelector('#trade-log-table tbody');
      tbody.innerHTML = '';
      if (!Array.isArray(tradesToRender) || tradesToRender.length === 0) {
        tbody.innerHTML = '<tr><td colspan="22">No trades found.</td></tr>';
        updateSummary(tradesToRender); // Update summary even when no trades
        return;
      }

      let lastContract = null;
      let groupIndex = 0;
      for (const trade of tradesToRender) {
        const isNewGroup = trade.contract !== lastContract;
        if (isNewGroup) {
          groupIndex++;
        }
        lastContract = trade.contract;
        const tr = document.createElement('tr');
        tr.style.borderTop = isNewGroup ? '2px solid #666' : '';
        // Assign group-odd or group-even class based on groupIndex
        tr.classList.add(groupIndex % 2 === 1 ? 'group-odd' : 'group-even');
        // Helper to format numbers with + sign for positive values, no decimals
        function plusSign(val) {
          if (val === null || val === undefined || val === '') return '';
          const num = Number(val);
          if (isNaN(num)) return val;
          return (num > 0 ? '+' : '') + Math.round(num);
        }
        tr.innerHTML = `
          <td>${trade.id !== null ? trade.id : ''}</td>
          <td>${trade.status !== null ? trade.status : ''}</td>
          <td>${trade.date !== null ? trade.date : ''}</td>
          <td>${trade.time !== null ? trade.time : ''}</td>
          <td>${trade.symbol !== null ? trade.symbol : ''}</td>
          <td>${trade.trade_strategy !== null ? trade.trade_strategy : ''}</td>
          <td>${trade.contract !== null ? trade.contract : ''}</td>
          <td>${trade.strike !== null ? trade.strike : ''}</td>
          <td>${trade.side === 'Yes' || trade.side === 'Y' ? 'Y' : trade.side === 'No' || trade.side === 'N' ? 'N' : ''}</td>
          <td>${trade.prob !== null && trade.prob !== undefined && trade.prob !== '' ? (Number(trade.prob) / 100).toFixed(2) : ''}</td>
          <td>${plusSign(trade.diff)}</td>
          <td>${trade.buy_price !== null ? Number(trade.buy_price).toFixed(2) : ''}</td>
          <td>${trade.sell_price !== null ? Number(trade.sell_price).toFixed(2) : ''}</td>
          <td>${trade.position !== null ? trade.position : ''}</td>
          <td>${trade.fees !== null ? Number(trade.fees).toFixed(2) : ''}</td>
          <td>${trade.pnl !== null && trade.pnl !== undefined && trade.pnl !== '' ? Number(trade.pnl).toFixed(2) : ''}</td>
          <td>${trade.closed_at !== null ? trade.closed_at : ''}</td>
          <td>${trade.symbol_open !== null ? '$' + Math.round(trade.symbol_open).toLocaleString() : ''}</td>
          <td>${trade.symbol_close !== null ? '$' + Math.round(trade.symbol_close).toLocaleString() : ''}</td>
          <td>${plusSign(trade.momentum)}</td>
          
          <td>${plusSign(trade.win_loss)}</td>
        `;
        tbody.appendChild(tr);
      }
      
      // Update summary statistics
      updateSummary(tradesToRender);
    }

    function applyFilters() {
      const dateFilterPicker = document.getElementById('date-filter-picker');
      
      // Filter out test trades (where test_filter is TRUE)
      let filtered = trades.filter(trade => !trade.test_filter);
      
      filtered = filterTradesByDate(filtered, dateFilterPicker ? dateFilterPicker.value : 'TODAY');
      filtered = filterTradesByWinLoss(filtered);
      filtered = filterTradesByTTC(filtered);
      
      filteredTrades = [...filtered];
      applyCurrentSort();
      renderTrades(filteredTrades);
    }

    async function fetchAllTrades() {
      console.log('Fetching trades at', new Date().toLocaleTimeString());
      try {
        // Wait for port configuration to be loaded
        let retries = 0;
        const maxRetries = 10;
        while (retries < maxRetries) {
          try {
                    // Use the centralized port system
        const apiBaseUrl = getMainAppUrl();
        
        const res = await fetch(`${apiBaseUrl}/trades`, { cache: 'no-store' });
            if (!res.ok) throw new Error('Network response was not ok');
            trades = await res.json();
            applyFilters();
            return; // Success, exit the function
          } catch (portError) {
            if (portError.message.includes('Port configuration not loaded')) {
              console.log(`Waiting for port configuration... (attempt ${retries + 1}/${maxRetries})`);
              retries++;
              if (retries < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
                continue;
              }
            }
            throw portError; // Re-throw if it's not a port config error or we've exhausted retries
          }
        }
        throw new Error('Port configuration failed to load after multiple attempts');
      } catch (error) {
        const tbody = document.querySelector('#trade-log-table tbody');
        tbody.innerHTML = `<tr><td colspan="22" style="color:red;">Failed to load trades: ${error.message}</td></tr>`;
        console.error('Error fetching trades:', error);
      }
    }

    // Update date range display
    async function updateDateRangeDisplay() {
      const filterPicker = document.getElementById('date-filter-picker');
      const display = document.getElementById('date-range-display');
      if (!filterPicker || !display) return;
      const selectedValue = filterPicker.value;
      const now = new Date();
      let rangeText = '';
      function getDateOfThisWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        const diff = dayOfWeek - currDay;
        curr.setDate(curr.getDate() + diff);
        return formatDate(curr);
      }
      function getDateOfLastWeek(dayOfWeek) {
        const curr = new Date(now);
        const currDay = curr.getDay();
        curr.setDate(curr.getDate() - currDay - 7 + dayOfWeek);
        return formatDate(curr);
      }
      function getLatestSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay());
        return formatDate(curr);
      }
      function getPrevSunday() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 7);
        return formatDate(curr);
      }
      function getNextSaturdayOfPrevWeek() {
        const curr = new Date(now);
        curr.setDate(curr.getDate() - curr.getDay() - 1);
        return formatDate(curr);
      }
      switch (selectedValue) {
        case 'ALL':
          try {
            // Wait for port configuration to be loaded
            let retries = 0;
            const maxRetries = 5;
            while (retries < maxRetries) {
              try {
                const apiBaseUrl = getMainAppUrl();
                const response = await fetch(`${apiBaseUrl}/api/earliest_trade_date`);
                if (response.ok) {
                  const data = await response.json();
                  if (data.earliest_date) {
                    const todayStr = formatDate(now);
                    rangeText = `${data.earliest_date} to ${todayStr}`;
                  } else {
                    rangeText = '';
                  }
                } else {
                  rangeText = '';
                }
                break; // Success, exit the loop
              } catch (portError) {
                if (portError.message.includes('Port configuration not loaded')) {
                  console.log(`Waiting for port configuration in date range... (attempt ${retries + 1}/${maxRetries})`);
                  retries++;
                  if (retries < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, 300)); // Wait 300ms before retry
                    continue;
                  }
                }
                throw portError; // Re-throw if it's not a port config error or we've exhausted retries
              }
            }
            if (retries >= maxRetries) {
              console.error('Port configuration failed to load for date range');
              rangeText = '';
            }
          } catch (error) {
            console.error('Error fetching earliest trade date:', error);
            rangeText = '';
          }
          break;
        case 'TODAY':
          rangeText = formatDate(now);
          break;
        case 'THIS_WEEK': {
          const sunday = getLatestSunday();
          const todayStr = formatDate(now);
          rangeText = `${sunday} to ${todayStr}`;
          break;
        }
        case 'SUNDAY':
          rangeText = getDateOfThisWeek(0);
          break;
        case 'MONDAY':
          rangeText = getDateOfThisWeek(1);
          break;
        case 'TUESDAY':
          rangeText = getDateOfThisWeek(2);
          break;
        case 'WEDNESDAY':
          rangeText = getDateOfThisWeek(3);
          break;
        case 'THURSDAY':
          rangeText = getDateOfThisWeek(4);
          break;
        case 'FRIDAY':
          rangeText = getDateOfThisWeek(5);
          break;
        case 'SATURDAY':
          rangeText = getDateOfThisWeek(6);
          break;
        case 'LAST_WEEK': {
          const prevSunday = getPrevSunday();
          const nextSaturday = getNextSaturdayOfPrevWeek();
          rangeText = `${prevSunday} to ${nextSaturday}`;
          break;
        }
        case 'MONTH': {
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const monthStartStr = formatDate(monthStart);
          const todayStr2 = formatDate(now);
          rangeText = `${monthStartStr} to ${todayStr2}`;
          break;
        }
        case 'PREV_30': {
          const prev30 = new Date(now);
          prev30.setDate(now.getDate() - 30);
          const prev30Str = formatDate(prev30);
          const todayStr3 = formatDate(now);
          rangeText = `${prev30Str} to ${todayStr3}`;
          break;
        }
        case 'YTD': {
          const ytdStart = `${now.getFullYear()}-01-01`;
          const todayStr4 = formatDate(now);
          rangeText = `${ytdStart} to ${todayStr4}`;
          break;
        }
        case 'PREV_YEAR': {
          const prevYear = new Date(now);
          prevYear.setFullYear(now.getFullYear() - 1);
          const prevYearStr = formatDate(prevYear);
          const todayStr5 = formatDate(now);
          rangeText = `${prevYearStr} to ${todayStr5}`;
          break;
        }
        case 'CUSTOM':
          rangeText = '';
          break;
        default:
          rangeText = '';
      }
      display.textContent = rangeText;
    }

    // WebSocket connection for database change notifications
    function setupDatabaseChangeListener() {
      const ws = new WebSocket(`ws://${window.location.host}/ws/db_changes`);
      
      ws.onopen = function() {
        console.log('🔗 Connected to database change notifications (trade history)');
      };
      
      ws.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          console.log('📡 Received database change notification (trade history):', data);
          
          // Handle trade database changes and refresh immediately
          if (data.database === 'trades' || data.data?.trades) {
            console.log('🔄 Refreshing trade history due to database change');
            fetchAllTrades();
          }
        } catch (error) {
          console.error('❌ Error parsing database change notification (trade history):', error);
        }
      };
      
      ws.onerror = function(error) {
        console.error('❌ WebSocket error (trade history):', error);
      };
      
      ws.onclose = function() {
        console.log('🔌 Database change WebSocket connection closed (trade history)');
        // Attempt to reconnect after a delay
        setTimeout(() => {
          console.log('🔄 Attempting to reconnect to database change notifications (trade history)...');
          setupDatabaseChangeListener();
        }, 5000);
      };
    }

    // Periodic auto-refresh every 10 seconds
    function setupPeriodicRefresh() {
      const refreshInterval = 10000; // 10 seconds
      
      setInterval(() => {
        console.log('⏰ Periodic refresh triggered (trade history)');
        fetchAllTrades();
      }, refreshInterval);
      
      console.log('⏰ Periodic refresh setup: every 10 seconds (trade history)');
    }

    // On initial load, show filtered trades
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        // Load preferences and apply to UI first
        const res = await fetch(window.location.origin + '/api/get_trade_history_preferences');
        const data = await res.json();
        
        // Apply date filter
        const dateFilterPicker = document.getElementById('date-filter-picker');
        if (dateFilterPicker && data.date_filter) {
          dateFilterPicker.value = data.date_filter;
        }
        
        // Apply win/loss filters
        const filterWin = document.getElementById('filter-win');
        const filterLoss = document.getElementById('filter-loss');
        if (filterWin && data.win_filter !== undefined) {
          filterWin.checked = data.win_filter;
        }
        if (filterLoss && data.loss_filter !== undefined) {
          filterLoss.checked = data.loss_filter;
        }
        
        // Apply TTC filter
        const ttcFilter = document.getElementById('ttc-filter');
        if (ttcFilter && data.ttc_filter !== undefined) {
          ttcFilter.value = data.ttc_filter;
        }
        
        // Apply sort settings
        if (data.sort_key) {
          currentSort.key = data.sort_key;
          currentSort.asc = data.sort_asc !== undefined ? data.sort_asc : true;
        }
        
        // Update date range display
        await updateDateRangeDisplay();
      } catch (error) {
        console.error('Error loading preferences:', error);
      }

      // Now fetch trades after preferences are loaded
      fetchAllTrades();
      
      // Set up event listeners
      const filterPicker = document.getElementById('date-filter-picker');
      if (filterPicker) {
        filterPicker.addEventListener('change', () => {
          updateDateRangeDisplay();
          applyFilters();
          savePreferences();
        });
      }

      const headers = document.querySelectorAll('#trade-log-table thead th');
      headers.forEach(th => {
        th.classList.add('sortable');
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-key');
          if (key) {
            sortTrades(key);
            savePreferences();
          }
        });
      });

      // Hook up Win/Loss filter checkboxes
      const filterWin = document.getElementById('filter-win');
      const filterLoss = document.getElementById('filter-loss');
      if (filterWin) {
        filterWin.addEventListener('change', () => {
          applyFilters();
          savePreferences();
        });
      }
      if (filterLoss) {
        filterLoss.addEventListener('change', () => {
          applyFilters();
          savePreferences();
        });
      }

      // Hook up TTC filter
      const ttcFilter = document.getElementById('ttc-filter');
      if (ttcFilter) {
        ttcFilter.addEventListener('input', () => {
          applyFilters();
          savePreferences();
        });
      }

      // Hook up All/None buttons
      const selectAllBtn = document.getElementById('select-all-filters');
      const selectNoneBtn = document.getElementById('select-none-filters');
      
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
          if (filterWin) filterWin.checked = true;
          if (filterLoss) filterLoss.checked = true;
          applyFilters();
          savePreferences();
        });
      }
      
      if (selectNoneBtn) {
        selectNoneBtn.addEventListener('click', () => {
          if (filterWin) filterWin.checked = false;
          if (filterLoss) filterLoss.checked = false;
          applyFilters();
          savePreferences();
        });
      }
      
      // Set up WebSocket connection for database change notifications
      setupDatabaseChangeListener();
      
      // Set up periodic auto-refresh every 10 seconds
      setupPeriodicRefresh();
    });

    // Simple function to save preferences
    function savePreferences() {
      const dateFilterPicker = document.getElementById('date-filter-picker');
      const filterWin = document.getElementById('filter-win');
      const filterLoss = document.getElementById('filter-loss');
      const ttcFilter = document.getElementById('ttc-filter');
      
      const preferences = {
        date_filter: dateFilterPicker ? dateFilterPicker.value : 'ALL',
        win_filter: filterWin ? filterWin.checked : true,
        loss_filter: filterLoss ? filterLoss.checked : true,
        ttc_filter: ttcFilter ? parseInt(ttcFilter.value) : 60,
        sort_key: currentSort.key,
        sort_asc: currentSort.asc,
        page_size: 50,
        last_search_timestamp: Date.now()
      };
      
      fetch(window.location.origin + '/api/set_trade_history_preferences', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(preferences)
      })
      .then(response => {
        if (response.ok) {
          console.log('Preferences saved');
        } else {
          console.error('Failed to save preferences');
        }
      })
      .catch(error => {
        console.error('Error saving preferences:', error);
      });
    }
  </script>
</body>
</html>