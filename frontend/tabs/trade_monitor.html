<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="/styles/global.css">
<link rel="stylesheet" href="/styles/strike-table.css">
<script src="/js/live-data.js"></script>
<script src="/js/strike-table.js"></script>
<script src="/js/watchlist-table.js"></script>

        <script src="/js/globals.js"></script>
        
        <script src="/js/active-trade-supervisor_panel.js"></script>
        <script src="/js/trade-execution-controller.js"></script>
      
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Trade Monitor</title>
<style>
  

  body {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    height: 100vh;
  }

  .top-half {
    display: flex;
    flex-direction: row;
    overflow: hidden;
  }

  .bottom-half {
    flex: 1;
    overflow: hidden;
    margin-top: -10px;
  }

  .column {
    width: 33.3333vw;
    overflow-y: auto;
    padding: 10px;
    padding-top: 0px;
  
  }
  .column#col2 {
    width: 33.3333vw;
    overflow-y: auto;
    padding-left: 0px;
    padding-right: 0px;
  }

  .column:first-child {
    border-left: none;
    padding-left: 0px;
  }

  .panel-table {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
  }


  #tickerPanel {
    /* height removed to avoid conflicts */
    flex-shrink: 0;
    overflow: auto;
    border-collapse: collapse;
    color: white;
  }

  #tickerPanel td {
    padding-bottom: 8px;
    text-align: left;
    vertical-align: bottom;
  }


  #tickerPanel tr.price-row td {
    font-size: 270%;
    vertical-align: baseline;
  }

  #tickerPanel tr.change-row td {
    font-size: 70%;
  }

  #tickerPanel tr.chart-row td {
    height: 100%;
    vertical-align: top;
  }

  #newPanel {
    margin-top: 5px;
    border-bottom: 1px solid #a0a9b8;
    text-align: left;
    vertical-align: top;
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
  }

  /* #momentumPanel styles merged into .panel-container above */

  /* === STRIKE TABLE STYLES === */
  /* Moved to /styles/strike-table.css */



  /* === ACTIVE TRADE SUPERVISOR TABLE STYLES === */
  #activeTradeSupervisorTable {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
  }
  #activeTradeSupervisorTable th,
  #activeTradeSupervisorTable td {
    font-size: 14px;
    border: 1px solid #888;
    padding: 4px 6px;
  }
  /* Center all values (cells) in the Active Trade Supervisor table */
  #activeTradeSupervisorTable td {
    text-align: center;
  }
  #activeTradeSupervisorTable thead th {
    font-size: 13px;
    font-weight: bold;
    text-align: center;
    background-color: #222c3c;
    padding: 4px 6px;
  }


  .momentum-heat-band-spacer {
    width: 20px;
    min-width: 20px;
    max-width: 20px;
    height: 100%;
    min-height: 40px;
    background: none !important;
    border: none !important;
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    display: block;
  }



</style>
<style>



  /* Remove top, left, right, and interior borders from header row in Active Trade Supervisor table */
  #activeTradeSupervisorTable thead tr th {
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: none;
  }
</style>
<style>
#errorTooltip {
  position: absolute;
  z-index: 9999;
  background-color: white;
  color: black;
  border: 3px solid black;
  padding: 10px;
  max-width: 400px;
  font-family: monospace;
  font-size: 12px;
  white-space: pre-wrap;
  display: none;
  pointer-events: none;
}
</style>
<style>
  /* === YES BUTTON STYLES (existing) === */
  .yes-button {
    background-color: #45d34a;
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.2s;
  }
  .yes-button:hover {
    background-color: #28a745;
    cursor: pointer;
  }
</style>
<style>

  /* Unified spanner row styling for ALL tables */
  tr.spanner-row td {
    background-color: #535668 !important;
    color: #c0c0c0 !important;
    text-align: center !important;
    font-size: 12px !important;
    font-style: italic !important;
    height: 25px !important;
    padding: 2px 4px !important;
  }
  
  /* Blue background for closing trades */
  #activeTradeSupervisorTable tr.closing-trade {
    background-color: #1e3a8a !important;
  }
  #activeTradeSupervisorTable tr.closing-trade td {
    background-color: #1e3a8a !important;
    color: #ffffff !important;
  }
</style>
<style>

  
  /* Ensure clickable elements show pointer cursor */
  .clickable, [onclick], [data-clickable="true"] {
    cursor: pointer !important;
  }
  
  /* Ensure nav items show pointer cursor */
  .nav-item {
    cursor: pointer !important;
  }
</style>
<style>
  .trade-popup, .trade-closed-popup {
    position: fixed;
    bottom: 20px;
    right: 20px;
    color: white;
    padding: 18px 30px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 21px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    display: none;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  .trade-popup {
    background-color: #28a745;
  }
  .trade-closed-popup {
    background-color: #dc3545;
  }
  .trade-popup.show,
  .trade-closed-popup.show {
    display: block;
    opacity: 1;
    /* transition stays at default unless overridden in JS */
  }
</style>
<style>
#autoStopToggle {
  accent-color: red;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#autoStopToggle:checked {
  background-color: #007bff;
  box-shadow: none;
}

#autoStopToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#autoStopToggle:focus-visible {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

#autoStopSupervisorToggle {
  accent-color: r#007bff;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#autoStopSupervisorToggle:checked {
  background-color: #007bff;
  box-shadow: none;
}

#autoStopSupervisorToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#autoStopSupervisorToggle:focus-visible {
  outline: 2px solid #f00;
  outline-offset: 2px;
}
</style>
<style>
#autoEntryToggle {
  accent-color: #007bff;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#autoEntryToggle:checked {
  background-color: #007bff;
  box-shadow: none;
}

#autoEntryToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#autoEntryToggle:focus-visible {
  outline: 2px solid #00ff00;
  outline-offset: 2px;
}
</style>
<style>
#plusMinusToggle {
  accent-color: #007bff;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#plusMinusToggle:checked {
  background-color: #007bff;
  box-shadow: none;
}

#plusMinusToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#plusMinusToggle:focus-visible {
  outline: 2px solid #00ff00;
  outline-offset: 2px;
}
</style>
<style>
  /* === Multiplier Button Styles === */
  .multiplier-btn {
    background-color: transparent;
    border: 1px solid #ccc;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  .multiplier-btn.active {
    background-color: #007bff; /* bright blue */
    border-color: #0056b3;
    color: white;
    font-weight: bold;
    box-shadow: 0 0 6px rgba(0, 123, 255, 0.7);
  }
  .multiplier-btn:hover:not(.active) {
    background-color: rgba(255, 255, 255, 0.1);
  }
</style>
<style>
  /* === STRIKE TABLE RISK COLOR CLASSES === */
  /* Moved to /styles/strike-table.css */
</style>
<style>
  /* === Profile Data TABLE STYLES (match Active Trades) === */
  #recentTradesTable {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
  }
  #recentTradesTable th,
  #recentTradesTable td {
    font-size: 12px;
    border: 0px solid #888888;
    padding: 4px 6px;
    text-align: center;
  }
  #recentTradesTable thead th {
    font-size: 13px;
    font-weight: bold;
    background-color: #222c3c;
    padding: 4px 6px;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid #222c3c;
  }
  #recentTradesTable tbody tr:nth-child(even) {
    background-color: #323c4e;
  }
  #recentTradesTable tbody tr:hover {
    background-color: #4d586f !important;
  }
  #recentTradesTable tbody td {
    padding: 4px 6px;
    text-align: center;
    font-size: 12px;
  }
  #openPositionsTable thead th {
    font-size: 13px;
    font-weight: bold;
    background-color: #222c3c;
    padding: 4px 6px;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid #222c3c;
  }
  #openPositionsTable tbody tr:nth-child(even) {
    background-color: #323c4e;
  }
  #openPositionsTable tbody tr:hover {
    background-color: #4d586f !important;
  }
  #openPositionsTable tbody td {
    padding: 4px 6px;
    text-align: center;
    font-size: 12px;
  }
  #settlementsTable thead th {
    font-size: 13px;
    font-weight: bold;
    background-color: #222c3c;
    padding: 4px 6px;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid #222c3c;
  }
  #settlementsTable tbody tr:nth-child(even) {
    background-color: #323c4e;
  }
  #settlementsTable tbody tr:hover {
    background-color: #4d586f !important;
  }
  #settlementsTable tbody td {
    padding: 4px 6px;
    text-align: center;
    font-size: 12px;
  }

</style>

</style>
<style>
  /* Strike Table Column Widths (page-specific) */
  /* Moved to /styles/strike-table.css */
</style>


</head>
<body>
    <div class="top-half">
      <div class="column" id="col1">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: flex-start;">
        <select id="ticker-picker" class="dropdown-picker" name="ticker">
          <option value="BTC">BTC</option>
          <option value="ETH">ETH</option>
        </select>
      </div>
      <div class="panel-container" style="min-height: 200px;" id="tickerPanelContainer">
        <table id="tickerPanel" class="panel-table">
          <tbody>
            <tr class="price-row">
              <td style="position: relative;">
                <span id="btc-price-value" style="display: inline-block;">$—</span>
              </td>
            </tr>
            <tr class="change-row">
              <td id="btc-changes-cell">1h &nbsp;<span id="change-1h">—</span> &nbsp;&nbsp; 3h &nbsp;<span id="change-3h">—</span> &nbsp;&nbsp; 1d &nbsp;<span id="change-1d">—</span></td>
            </tr>
            <tr class="chart-row">
              <td><div id="tradingview_12345"></div></td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="panel-container" style="min-height: 00px;" id="momentumPanelContainer">
        <div class="panel-header">Momentum</div>
        <div class="panel-content" id="momentumPanelContent">
          <div style="display: flex; gap: 10px;">
            <div style="width: 30%; height: 180px; background-color: #1e2733; display: flex; align-items: center; justify-content: center;">
              <canvas id="momentumBarChartCanvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div style="width: 70%; height: 180px; background-color: #1e2733; position: relative;">
              <canvas id="rolling-momentum-chart" style="width: 100%; height: 100%;"></canvas>
              <div id="momentum-score-display" style="position: absolute; top: 8px; right: 8px;  color: white; padding: 4px 8px; border-radius: 4px; font-size: 20px; font-weight: bold;">—</div>
            </div>
          </div>
          <div id="fingerprint-display" style="font-size: 11px; color: #888; opacity: 0.5; font-family: monospace; padding: 4px 8px; margin-top: 4px;">Fingerprint: —</div>
        </div>
      </div>

    </div>
    
    <div class="column" id="col2">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
        <div id="strikePanelMarketTitleCell" style="font-size: 16px; text-align: left;">Loading market title...</div>
        <div style="display: flex; align-items: center; gap: 10px;">
          <div id="autoEntryIndicator" style="display: none; align-items: center; gap: 6px; margin-right: 5px;padding: 4px 8px;  color: white; border-radius: 4px; font-size: 12px; font-weight: 500;">
            <div style="width: 11px; height: 11px; background: #00ff2f; border-radius: 50%;"></div>
            <span>Automated Trading ON</span>
          </div>
          <div id="strikePanelTTC" style="font-size: 27px; font-weight: bold; text-align: right;">&nbsp;</div>
        </div>
      </div>
      <div class="panel-container" style="min-height: 450px; " id="strikePanelContainer">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
          <span>Market</span>
          <label style="font-size: 12px; user-select: none; color: white; display: flex; align-items: center; gap: 6px; margin: 0;">
            + / -
            <input type="checkbox" id="plusMinusToggle" style="opacity: 100%;"/>
          </label>
        </div>
        <table id="strikePanelTable" style="width: 100%; height: 100%; ">
          <tbody>
            <!-- Market title and TTC clock row removed -->
          </tbody>
        </table>
        <!-- Strike Table will be generated by strike-table.js -->
      </div>





</script>

<!-- === STRIKE TABLES JS (inserted as per instructions) === -->
<script>
// === Trade Open/Close Master Functions (Symmetric) ===
// Moved to strike-table.js and trade-execution-controller.js

// Trade execution functions moved to trade-execution-controller.js

/**
 * Cancel a pending or error trade.
 * Moved to trade-execution-controller.js
 */

// === STRIKE TABLE FUNCTIONS ===
// All strike table functionality moved to strike-table.js






</script>

</div>

    <div class="column" id="col3" style="padding-right: 0px;">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
          <select id="account-selector" class="dropdown-picker">
            <option value="live">PROD</option>
            <option value="demo">DEMO</option>
          </select>
        </div>
        <div style="display: flex; flex-direction: column; align-items: flex-end;">
          <span style="font-size: 11px; color: #ccc; font-weight: normal; margin-bottom: 0px;">Balance</span>
          <span id="account-balance" style="font-weight: bold; color: white; font-size: 14px;">Loading...</span>
        </div>
      </div>
              <div class="panel-container" id="watchlistPanel" style="min-height: 346px; max-height: 346px;">
        <div class="panel-header" style="display: flex; align-items: center; justify-content: space-between;">
          <span>Watchlist</span>
          <div style="display: flex; align-items: center; gap: 6px;">
            <img 
              id="autoEntrySettingsIcon"
              src="../images/icons/panel_settings.png" 
              alt="Auto Entry Settings" 
              title="Auto Entry Settings" 
              style="width: 14px; height: 14px; opacity: 0.7; transition: opacity 0.2s; cursor: pointer; align-self: center;"
              onmouseover="this.style.opacity='1'" 
              onmouseout="this.style.opacity='0.7'"
            />
            <label style="font-size: 12px; user-select: none; color: white; display: flex; align-items: center; gap: 6px; margin: 0;">
              AUTO ENTRY
              <input type="checkbox" id="autoEntryToggle" />
            </label>
          </div>
        </div>
        <!-- Trade Strategy and Position Size Row -->
        <div style="display: flex; align-items: flex-start; gap: 20px; margin-bottom: 12px;">
          <!-- Trade Strategy Picker -->
          <div style="flex: 1;">
            <div style="margin-bottom: 6px; font-size: 0.9rem; font-weight: bold;">Trade Strategy</div>
            <select id="trade-strategy-picker" class="dropdown-picker" name="trade-strategy">
              <option value="Hourly HTC">Hourly HTC</option>
              <option value="Momentum Scalp">Momentum Scalp</option>
              <option value="*** TEST ***">*** TEST ***</option>
            </select>
          </div>

          <!-- Position Size Picker -->
          <div style="flex: 1;">
            <div style="font-weight: bold; margin-bottom: 6px; font-size: 0.9rem;">Position Size: <span id="position-display" style="margin-left: 10px; updateupdatefont-weight: normal; color: #ccc;">100 contracts</span></div>
            <div id="positionSizeSelector" style="display: flex; align-items: center; gap: 10px;">
              <input type="number" id="position-size" min="1" style="width: 60px; padding: 4px 6px; text-align: right; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc; height: 28px; box-sizing: border-box;" />
              <div>
                <button class="multiplier-btn" data-multiplier="1" style="height: 28px; padding: 4px 8px; box-sizing: border-box;">1x</button>
                <button class="multiplier-btn" data-multiplier="2" style="height: 28px; padding: 4px 8px; box-sizing: border-box;">2x</button>
                <button class="multiplier-btn" data-multiplier="3" style="height: 28px; padding: 4px 8px; box-sizing: border-box;">3x</button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Watchlist Table -->
        <div style="margin-top: 20px; max-height: 250px; overflow-y: auto;">
          <table id="watchlist-table" class="strike-table" style="width: 100%; border-collapse: collapse; margin-bottom: 10px;">
            <colgroup>
              <col class="col-strike">
              <col class="col-buffer">
              <col class="col-bm">
              <col class="col-risk">
              <col class="col-side">
              <col class="col-buy">
            </colgroup>
            <thead>
              <tr>
                <th>STRIKE</th>
                <th>BUFFER</th>
                <th>%</th>
                <th>Prob</th>
                <th>SIDE</th>
                <th>BUY</th>
              </tr>
            </thead>
            <tbody>
              <!-- Watchlist content will be populated later -->
            </tbody>
          </table>
        </div>
      </div>
  <script>
    // Sync the mode picker with the global mode on load
    async function syncModePickerWithGlobal() {
        const res = await fetch("/api/get_account_mode");
        const data = await res.json();
        const modePicker = document.getElementById("accountModePicker");
        if (modePicker) {
            modePicker.value = data.mode;
        }
    }
    // Call this on load
    syncModePickerWithGlobal();

    // If the mode picker changes, update the backend global mode
    document.addEventListener('DOMContentLoaded', function() {
      const modePicker = document.getElementById("accountModePicker");
      if (modePicker) {
        modePicker.addEventListener("change", function() {
          const mode = modePicker.value;
          fetch('/api/set_account_mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode })
          }).catch(console.error);
        });
      }
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initial load of active trades
      fetchAndRenderTrades();
      
      // Active trades are now updated by the strike table loop in live-data.js
      // No separate polling needed
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetch('/api/get_account_mode')
        .then(res => res.json())
        .then(data => {
          const mode = data.mode;
          const selector = document.getElementById("account-selector");
          selector.value = mode === 'prod' ? 'live' : 'demo';
          
          // Fetch and update account balance
          updateAccountBalance(mode);
        });

      document.getElementById("account-selector").addEventListener("change", () => {
        const selected = document.getElementById("account-selector").value;
        const mode = selected === "live" ? "prod" : "demo";
        fetch('/api/set_account_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode })
        }).catch(console.error);
        
        // Update balance when account mode changes
        updateAccountBalance(mode);
      });
    });
    
    // Function to fetch and update account balance
    async function updateAccountBalance(mode) {
      try {
        const response = await fetch(`/api/account/balance?mode=${mode}`);
        const data = await response.json();
        const balanceEl = document.getElementById("account-balance");
        if (balanceEl) {
          const balance = data.balance || 0;
          const balanceInDollars = balance / 100; // Convert cents to dollars
          balanceEl.textContent = `$${Number(balanceInDollars).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
        }
      } catch (error) {
        console.error('Error fetching account balance:', error);
        const balanceEl = document.getElementById("account-balance");
        if (balanceEl) {
          balanceEl.textContent = "Error";
        }
      }
    }
    
    // Update balance every 30 seconds
    setInterval(() => {
      const selector = document.getElementById("account-selector");
      if (selector) {
        const mode = selector.value === "live" ? "prod" : "demo";
        updateAccountBalance(mode);
      }
    }, 30000);
  </script>
</body>
  <div id="errorTooltip" class="error-tooltip"></div>
<script>
// === Unified Preferences: AUTO STOP, Position Size, Multiplier with WebSocket sync (improved) ===
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded - Starting preferences setup');
  
  const autoStopToggle = document.getElementById('autoStopToggle');
  const autoStopSupervisorToggle = document.getElementById('autoStopSupervisorToggle');
  const positionInput = document.getElementById('position-size');
  const multiplierButtons = document.querySelectorAll('.multiplier-btn');
  const autoEntryToggle = document.getElementById('autoEntryToggle');
  const plusMinusToggle = document.getElementById('plusMinusToggle');
  
  console.log('Elements found:', {
    autoStopToggle: !!autoStopToggle,
    positionInput: !!positionInput,
    multiplierButtons: multiplierButtons.length,
    autoEntryToggle: !!autoEntryToggle,
    plusMinusToggle: !!plusMinusToggle
  });
  
  let currentMultiplier = null;
  // Remove: let ignoreWsUpdates = false; (now global)
  
  // Define ignoreWsUpdates for this scope
  if (typeof window.ignoreWsUpdates === 'undefined') {
    window.ignoreWsUpdates = false;
  }
  let ignoreWsUpdates = window.ignoreWsUpdates;

  function updatePositionDisplay() {
    const baseValue = parseInt(positionInput.value, 10) || 0;
    const total = baseValue * (currentMultiplier || 1);
    const positionDisplay = document.getElementById('position-display');
    if (positionDisplay) {
      positionDisplay.textContent = `${total} contracts`;
    }
  }

  // Initial preferences fetch and UI setup
  fetch(window.location.origin + '/api/get_preferences')
    .then(res => res.json())
    .then(data => {
      if (autoStopToggle && data.auto_stop !== undefined) {
        autoStopToggle.checked = data.auto_stop;
        window.autoStopEnabled = data.auto_stop;
      }
      if (autoStopSupervisorToggle && data.auto_stop !== undefined) {
        autoStopSupervisorToggle.checked = data.auto_stop;
      }
      if (autoEntryToggle && data.auto_entry !== undefined) {
        autoEntryToggle.checked = data.auto_entry;
        window.recoEnabled = data.auto_entry;
        
        // If AUTO ENTRY is enabled on initial load, apply filtering
        if (data.auto_entry) {
          console.log('AUTO ENTRY enabled on initial load - applying automatic filtering');
          setTimeout(() => {
            if (window.StrikeTable && window.StrikeTable.setAutoEntry) {
              window.StrikeTable.setAutoEntry(true);
            }
          }, 1000); // Delay to ensure strike table is loaded
        } else {
          // If AUTO ENTRY is disabled on initial load, enable click handlers
          setTimeout(() => {
            if (window.StrikeTable && window.StrikeTable.setAutoEntry) {
              window.StrikeTable.setAutoEntry(false);
            }
          }, 1000); // Delay to ensure strike table is loaded
        }
      }
              if (plusMinusToggle && data.diff_mode !== undefined) {
          plusMinusToggle.checked = data.diff_mode;
          window.diffMode = data.diff_mode;
      }
      if (positionInput && data.position_size !== undefined) {
        positionInput.value = data.position_size;
      }
      if (multiplierButtons.length && data.multiplier !== undefined) {
        currentMultiplier = data.multiplier;
        multiplierButtons.forEach(btn => {
          if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      updatePositionDisplay();
    });

  // WebSocket setup
  const ws = new WebSocket(`ws://${window.location.host}/ws/preferences`);

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log('WebSocket message received:', data);

      // === Automated Trade Notification ===
      if (data.type === 'automated_trade_triggered') {
        console.log('🔔 Automated trade triggered:', data.data);
        
        // Trigger the same audio/visual alerts as manual trades
        if (typeof playSound === 'function') {
          playSound('open');
        }
        
        if (typeof showTradeOpenedPopup === 'function') {
          showTradeOpenedPopup();
        }
        
        // Show a special automated trade notification
        showAutomatedTradeNotification(data.data);
        
        // Refresh trade panels to show the new automated trade
        if (typeof fetchAndRenderTrades === 'function') {
          fetchAndRenderTrades();
        }
        if (typeof fetchAndRenderRecentTrades === 'function') {
          fetchAndRenderRecentTrades();
        }
        
        return; // Don't process other WebSocket messages for this type
      }

      // === Automated Trade Close Notification ===
      if (data.type === 'automated_trade_closed') {
        console.log('🔔 Automated trade closed:', data.data);
        
        // Trigger the same audio/visual alerts as manual trade closes
        if (typeof playSound === 'function') {
          playSound('close');
        }
        
        if (typeof showTradeClosedPopup === 'function') {
          showTradeClosedPopup();
        }
        
        // Show a special automated trade close notification
        showAutomatedTradeCloseNotification(data.data);
        
        // Refresh trade panels to show the closed trade
        if (typeof fetchAndRenderTrades === 'function') {
          fetchAndRenderTrades();
        }
        if (typeof fetchAndRenderRecentTrades === 'function') {
          fetchAndRenderRecentTrades();
        }
        
        return; // Don't process other WebSocket messages for this type
      }

      // === Account Mode Sync ===
      if (data.account_mode) {
        const selector = document.getElementById("account-selector");
        if (selector) {
          selector.value = data.account_mode === "prod" ? "live" : "demo";
        }
      }


      // Only update UI if not focused to avoid overwriting user input
      if (autoStopToggle && data.auto_stop !== undefined && document.activeElement !== autoStopToggle) {
        ignoreWsUpdates = true;
        autoStopToggle.checked = data.auto_stop;
        window.autoStopEnabled = data.auto_stop;
        ignoreWsUpdates = false;
      }
      if (autoStopSupervisorToggle && data.auto_stop !== undefined && document.activeElement !== autoStopSupervisorToggle) {
        ignoreWsUpdates = true;
        autoStopSupervisorToggle.checked = data.auto_stop;
        ignoreWsUpdates = false;
      }

      if (autoEntryToggle && data.auto_entry !== undefined && document.activeElement !== autoEntryToggle) {
        ignoreWsUpdates = true;
        console.log('Received AUTO ENTRY update via WebSocket:', data.auto_entry);
        autoEntryToggle.checked = data.auto_entry;
        
        // Use clean API to update strike table auto entry mode
        if (window.StrikeTable && window.StrikeTable.setAutoEntry) {
          window.StrikeTable.setAutoEntry(data.auto_entry);
        }
        
      }

      // === Auto Entry Indicator Change ===
      if (data.type === 'auto_entry_indicator_change') {
        console.log('🔔 Auto entry indicator change:', data.data);
        updateAutoEntryIndicator(data.data);
        return; // Don't process other WebSocket messages for this type
      }

      // Fingerprint and momentum now consolidated in strike table - no separate WebSocket handlers needed

      if (plusMinusToggle && data.diff_mode !== undefined && document.activeElement !== plusMinusToggle) {
        ignoreWsUpdates = true;
        console.log('Received diff_mode update via WebSocket:', data.diff_mode);
        plusMinusToggle.checked = data.diff_mode;
        
        // Use clean API to update strike table diff mode
        if (window.StrikeTable && window.StrikeTable.setDiffMode) {
          window.StrikeTable.setDiffMode(data.diff_mode);
        }
        
        ignoreWsUpdates = false;
      }

      if (positionInput && data.position_size !== undefined && document.activeElement !== positionInput) {
        ignoreWsUpdates = true;
        positionInput.value = data.position_size;
        ignoreWsUpdates = false;
      }

      if (multiplierButtons.length && data.multiplier !== undefined && currentMultiplier !== data.multiplier) {
        ignoreWsUpdates = true;
        currentMultiplier = data.multiplier;
        multiplierButtons.forEach(btn => {
          if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        ignoreWsUpdates = false;
      }

      updatePositionDisplay();
    } catch (e) {
      console.error('Error parsing preferences WebSocket message:', e);
    }
  };

  // Save handlers, ignoring changes triggered by WebSocket updates
  if (autoStopToggle) {
    console.log('Adding auto stop event listener');
    autoStopToggle.addEventListener('change', () => {
      console.log('Auto stop event handler triggered, ignoreWsUpdates:', ignoreWsUpdates);
      if (ignoreWsUpdates) {
        console.log('Ignoring auto stop change due to WebSocket update');
        return;
      }
      const value = autoStopToggle.checked;
      console.log('Auto stop toggle changed to:', value);
      window.autoStopEnabled = value;
      console.log('Sending auto stop update to backend:', { enabled: value });
      fetch(window.location.origin + '/api/set_auto_stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      }).then(response => {
        console.log('Auto stop backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('Auto stop backend data:', data);
      }).catch(error => {
        console.error('Auto stop backend error:', error);
      });
    });
  }

  // Supervisor toggle - connected to same auto_stop preference
  if (autoStopSupervisorToggle) {
    console.log('Adding auto stop supervisor event listener');
    autoStopSupervisorToggle.addEventListener('change', () => {
      console.log('Auto stop supervisor event handler triggered, ignoreWsUpdates:', ignoreWsUpdates);
      if (ignoreWsUpdates) {
        console.log('Ignoring auto stop supervisor change due to WebSocket update');
        return;
      }
      const value = autoStopSupervisorToggle.checked;
      console.log('Auto stop supervisor toggle changed to:', value);
      window.autoStopEnabled = value;
      console.log('Sending auto stop supervisor update to backend:', { enabled: value });
      fetch(window.location.origin + '/api/set_auto_stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      }).then(response => {
        console.log('Auto stop supervisor backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('Auto stop supervisor backend data:', data);
      }).catch(error => {
        console.error('Auto stop supervisor backend error:', error);
      });
    });
  }

  if (autoEntryToggle) {
    console.log('Adding AUTO ENTRY event listener');
    autoEntryToggle.addEventListener('change', () => {
      console.log('AUTO ENTRY event handler triggered, ignoreWsUpdates:', ignoreWsUpdates);
      if (ignoreWsUpdates) {
        console.log('Ignoring AUTO ENTRY change due to WebSocket update');
        return;
      }
      const value = autoEntryToggle.checked;
      console.log('AUTO ENTRY toggle changed to:', value);
      
      // Use clean API to update strike table auto entry mode
      if (window.StrikeTable && window.StrikeTable.setAutoEntry) {
        window.StrikeTable.setAutoEntry(value);
      }
      
      console.log('Sending AUTO ENTRY update to backend:', { enabled: value });
      fetch(window.location.origin + '/api/set_auto_entry', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      }).then(response => {
        console.log('AUTO ENTRY backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('AUTO ENTRY backend data:', data);
      }).catch(error => {
        console.error('AUTO ENTRY backend error:', error);
      });
    });
  }

  if (plusMinusToggle) {
    console.log('Adding diff mode event listener');
    plusMinusToggle.addEventListener('change', () => {
      console.log('Diff mode event handler triggered, ignoreWsUpdates:', ignoreWsUpdates);
      if (ignoreWsUpdates) {
        console.log('Ignoring diff mode change due to WebSocket update');
        return;
      }
      const value = plusMinusToggle.checked;
      console.log('DIFF mode toggle changed to:', value);
      
      // Use clean API to update strike table immediately
      if (window.StrikeTable && window.StrikeTable.setDiffMode) {
        window.StrikeTable.setDiffMode(value);
      }
      
      // Sync to backend in background
      console.log('Sending diff mode update to backend:', { enabled: value });
      fetch(window.location.origin + '/api/set_diff_mode', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      }).then(response => {
        console.log('Diff mode backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('Diff mode backend data:', data);
      }).catch(error => {
        console.error('Diff mode backend error:', error);
      });
    });
  }

  if (positionInput) {
    console.log('Adding position size event listener');
    positionInput.addEventListener('change', () => {
      console.log('Position size event handler triggered, ignoreWsUpdates:', ignoreWsUpdates);
      if (ignoreWsUpdates) {
        console.log('Ignoring position size change due to WebSocket update');
        return;
      }
      const value = parseInt(positionInput.value, 10) || 100;
      console.log('Position size changed to:', value);
      console.log('Sending position size update to backend:', { position_size: value });
      fetch(window.location.origin + '/api/set_position_size', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ position_size: value })
      }).then(response => {
        console.log('Position size backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('Position size backend data:', data);
      }).catch(error => {
        console.error('Position size backend error:', error);
      });
      updatePositionDisplay();
    });
  }

  multiplierButtons.forEach(btn => {
    console.log('Adding event listener to multiplier button:', btn.dataset.multiplier);
    btn.addEventListener('click', () => {
      console.log('Multiplier button clicked:', btn.dataset.multiplier);
      if (ignoreWsUpdates) {
        console.log('Ignoring due to WebSocket update');
        return;
      }
      multiplierButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentMultiplier = parseInt(btn.dataset.multiplier, 10);
      console.log('Setting currentMultiplier to:', currentMultiplier);
      updatePositionDisplay();
      console.log('Sending multiplier update to backend:', { multiplier: currentMultiplier });
      fetch(window.location.origin + '/api/set_multiplier', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ multiplier: currentMultiplier })
      }).then(response => {
        console.log('Multiplier backend response:', response.status);
        return response.json();
      }).then(data => {
        console.log('Multiplier backend data:', data);
      }).catch(error => {
        console.error('Multiplier backend error:', error);
      });
    });
  });

});
</script>


      <!-- Active Trade Supervisor Panel -->
      <div class="panel-container" style="min-height: 310px;" id="activeTradeSupervisorPanel">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
          <span>Active Trade Supervisor</span>
          <div style="display: flex; align-items: center; gap: 6px;">
            <img 
              id="autoStopSettingsIcon"
              src="../images/icons/panel_settings.png" 
              alt="Auto Stop Settings" 
              title="Auto Stop Settings" 
              style="width: 14px; height: 14px; opacity: 0.7; transition: opacity 0.2s; cursor: pointer; align-self: center;"
              onmouseover="this.style.opacity='1'" 
              onmouseout="this.style.opacity='0.7'"
            />
            <label style="font-size: 12px; user-select: none; color: white; display: flex; align-items: center; gap: 6px; margin: 0;">
              AUTO STOP
              <input type="checkbox" id="autoStopSupervisorToggle" />
            </label>
          </div>
        </div>
        <table id="activeTradeSupervisorTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th>Strike</th>
              <th>Side</th>
              <th>Buy</th>
              <th>Pos</th>
              <th>Buffer</th>
              <th style="width: 40px;"">Prob</th>
              <th style="text-align: center;">Close</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <!-- Modal for Auto Stop Settings -->
      <div id="autoStopSettingsModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:1000;">
        <div id="autoStopSettingsDim" style="position:absolute; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4);"></div>
        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:white; border-radius:8px; min-width:400px; min-height:200px; box-shadow:0 4px 32px rgba(0,0,0,0.25); padding:20px; display:flex; flex-direction:column; align-items:stretch;">
          <div id="autoStopSettingsHeader" style="font-size:16px; font-weight:500; margin-bottom:24px; color:#222; letter-spacing:0.2px; text-align:left;">Auto Stop Settings</div>
          <div style="flex:1 1 auto; display:flex; flex-direction:column; justify-content:center; align-items:stretch;">
            <label for="autoStopProbabilitySlider" style="font-size:14px; color:#333; margin-bottom:12px; font-weight:500;">Current Win Probability:</label>
            <div style="position:relative; margin-bottom:24px; width:100%;">
              <input type="range" id="autoStopProbabilitySlider" min="0" max="100" value="25" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
              <div id="sliderValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">25%</div>
            </div>
            <!-- New TTC field -->
            <label for="autoStopMinTTCInput" style="font-size:14px; color:#333; margin-bottom:12px; font-weight:500;">Minimum Time to Close:</label>
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
              <div style="display: flex; align-items: center; border: 1px solid #ddd; border-radius: 4px; background: white;">
                <button id="autoStopMinTTCDown" style="padding: 8px 12px; border: none; background: #f8f9fa; cursor: pointer; border-right: 1px solid #ddd; border-radius: 4px 0 0 4px; font-size:12px;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">▼</button>
                <span id="autoStopMinTTCDisplay" style="padding: 8px 16px; font-size: 13px; color: #333; min-width: 60px; text-align: center; font-weight:500;">01:00</span>
                <button id="autoStopMinTTCUp" style="padding: 8px 12px; border: none; background: #f8f9fa; cursor: pointer; border-left: 1px solid #ddd; border-radius: 0 4px 4px 0; font-size:12px;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">▲</button>
              </div>
              <input type="hidden" id="autoStopMinTTCInput" value="60" />
            </div>
          </div>
          <div style="display:flex; gap:12px; justify-content:flex-end; align-items:center; margin-top:20px;">
            <button id="autoStopSettingsCancel" style="padding:8px 16px; border-radius:4px; border:1px solid #ddd; background:#f8f9fa; color:#333; font-size:13px; cursor:pointer; font-weight:500;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">Cancel</button>
            <button id="autoStopSettingsSave" style="padding:8px 16px; border-radius:4px; border:none; background:#007bff; color:white; font-size:13px; cursor:pointer; font-weight:500;" onmouseover="this.style.background='#0056b3'" onmouseout="this.style.background='#007bff'">Save</button>
          </div>
        </div>
      </div>
      <!-- Modal for Auto Entry Settings -->
      <div id="autoEntrySettingsModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:1000;">
        <div id="autoEntrySettingsDim" style="position:absolute; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.4);"></div>
        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:white; border-radius:8px; min-width:400px; min-height:200px; box-shadow:0 4px 32px rgba(0,0,0,0.25); padding:20px; display:flex; flex-direction:column; align-items:stretch;">
          <div id="autoEntrySettingsHeader" style="font-size:16px; font-weight:500; margin-bottom:24px; color:#222; letter-spacing:0.2px; text-align:left;">Auto Entry Settings</div>
          <div style="flex:1 1 auto; display:flex; flex-direction:column; justify-content:center; align-items:stretch;">
            <label for="timeWindowSlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Time Window:</label>
            <div style="position:relative; margin-bottom:24px; width:100%;">
              <!-- Time Window Slider Container -->
              <div id="timeWindowSliderContainer" style="position:relative; width:100%; height:6px; background:#e0e0e0; border-radius:3px; margin-top:8px;">
                <!-- Min Time Handle -->
                <div id="minTimeHandle" style="position:absolute; top:-5px; width:15px; height:15px; background:#007bff; border-radius:50%; cursor:pointer; z-index:10; transform:translateX(-50%); box-shadow:0 2px 4px rgba(0,0,0,0.2);" draggable="true"></div>
                <!-- Max Time Handle -->
                <div id="maxTimeHandle" style="position:absolute; top:-5px; width:15px; height:15px; background:#007bff; border-radius:50%; cursor:pointer; z-index:10; transform:translateX(-50%); box-shadow:0 2px 4px rgba(0,0,0,0.2);" draggable="true"></div>
                <!-- Selected Range -->
                <div id="timeWindowRange" style="position:absolute; top:0; height:6px; background:#007bff; border-radius:3px; z-index:5;"></div>
                <!-- Min Time Display -->
                <div id="timeWindowMinDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">00:00</div>
                <!-- Max Time Display -->
                <div id="timeWindowMaxDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">60:00</div>
              </div>
             
            </div>
            
            <label for="autoEntryProbabilitySlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Minimum Win Probability:</label>
            <div style="position:relative; margin-bottom:24px; width:100%;">
              <input type="range" id="autoEntryProbabilitySlider" min="0" max="100" value="25" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
              <div id="autoEntrySliderValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">25%</div>
            </div>
            
            <label for="autoEntryDifferentialSlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Minimum Differential:</label>
            <div style="position:relative; margin-bottom:8px; width:100%;">
              <input type="range" id="autoEntryDifferentialSlider" min="-10" max="10" step="0.25" value="0" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
              <div id="autoEntryDifferentialValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">0</div>
            </div>
            
            <label for="autoEntryAllowReEntry" style="font-size:14px; color:#333;margin-top:12px; margin-bottom:12px; font-weight:500;">Allow Re-Entry:</label>
            <div style="position:relative; margin-bottom:24px; width:100%;">
              <input type="checkbox" id="autoEntryAllowReEntry" style=" width:16px; height:16px; margin-right:8px; accent-color:#007bff;" />
              <span style="font-size:13px; color:#666;">Allow re-entry on the same strike</span>
            </div>
            
            <hr style="border: none; border-top: 1px solid #e0e0e0; margin: 24px 0;">
            
            <!-- Spike Alert Settings Section -->

              
              
              <div style="position:relative; margin-bottom:24px; width:100%;">
                <input type="checkbox" id="spikeAlertEnabled" style="width:16px; height:16px; margin-right:8px; accent-color:#007bff;" />
                <span style="font-size:13px; color:#666;">Pause auto entry during market spikes</span>
              </div>
              
              <label for="spikeAlertMomentumSlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Momentum Spike Level (±):</label>
              <div style="position:relative; margin-bottom:24px; width:100%;">
                <input type="range" id="spikeAlertMomentumSlider" min="10" max="100" value="40" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
                <div id="spikeAlertMomentumValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">±40</div>
              </div>
              
              <label for="spikeAlertCooldownSlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Cooldown Level (±):</label>
              <div style="position:relative; margin-bottom:24px; width:100%;">
                <input type="range" id="spikeAlertCooldownSlider" min="5" max="50" value="30" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
                <div id="spikeAlertCooldownValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">±30</div>
              </div>
              
              <label for="spikeAlertTimeSlider" style="font-size:14px; color:#333; margin-bottom:34px; font-weight:500;">Cooldown Time (minutes):</label>
              <div style="position:relative; margin-bottom:8px; width:100%;">
                <input type="range" id="spikeAlertTimeSlider" min="1" max="60" value="15" style="width:100%; height:6px; z-index:1; position:relative; background:#e0e0e0; border-radius:3px; outline:none;" />
                <div id="spikeAlertTimeValueDisplay" style="position:absolute; top:-32px; left:0; font-size:12px; color:#222; background:white; padding:4px 8px; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); pointer-events:none; z-index:2; transform:translateX(-50%); border:1px solid #e0e0e0;">15 min</div>
              </div>
            
          </div>
          <div style="display:flex; gap:12px; justify-content:flex-end; align-items:center; margin-top:20px;">
            <button id="autoEntrySettingsCancel" style="padding:8px 16px; border-radius:4px; border:1px solid #ddd; background:#f8f9fa; color:#333; font-size:13px; cursor:pointer; font-weight:500;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">Cancel</button>
            <button id="autoEntrySettingsSave" style="padding:8px 16px; border-radius:4px; border:none; background:#007bff; color:white; font-size:13px; cursor:pointer; font-weight:500;" onmouseover="this.style.background='#0056b3'" onmouseout="this.style.background='#007bff'">Save</button>
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Bottom Half -->
  <div class="bottom-half">
    <div class="panel-container" style="min-height: 100px;" id="profileDataPanel">
      <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
        <div style="display: flex; gap: 20px;">
          <span id="trade-history-tab" class="panel-tab active" style="cursor: pointer; opacity: 1; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="if(!this.classList.contains('active')) this.style.opacity='0.3'">Trade History</span>
          <span id="open-positions-tab" class="panel-tab" style="cursor: pointer; opacity: 0.3; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="if(!this.classList.contains('active')) this.style.opacity='0.3'">Open Positions</span>
          <span id="recent-fills-tab" class="panel-tab" style="cursor: pointer; opacity: 0.3; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="if(!this.classList.contains('active')) this.style.opacity='0.3'">Recent Fills</span>
          <span id="settlements-tab" class="panel-tab" style="cursor: pointer; opacity: 0.3; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="if(!this.classList.contains('active')) this.style.opacity='0.3'">Settlements</span>
        </div>
      </div>
      <div id="trade-history-content" class="tab-content active">
        <div style="height: 194px; overflow-y: auto;">
          <table id="tradeHistoryTable" class="panel-table" style="width: 100%; border-collapse: collapse; font-size: 0.7rem;">
            <style>
              #tradeHistoryTable thead th {
                font-size: 13px;
                font-weight: bold;
                background-color: #222c3c;
                padding: 4px 6px;
                border-top: none;
                border-left: none;
                border-right: none;
                border-bottom: 1px solid #222c3c;
                text-align: center;
              }
              #tradeHistoryTable tbody tr:hover {
                background-color: #4d586f !important;
              }
              #tradeHistoryTable tbody td {
                padding: 4px 6px;
                text-align: center;
                font-size: 12px;
              }
              #tradeHistoryTable .group-odd {
                background-color: #394559;
              }
              #tradeHistoryTable .group-even {
                background-color: #1f2633;
              }
            </style>
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Date</th>
                <th>Time</th>
                <th>Symbol</th>
                <th>Strategy</th>
                <th>Contract</th>
                <th>Strike</th>
                <th>Side</th>
                <th>Prob</th>
                <th>Diff</th>
                <th>Buy</th>
                <th>Sell</th>
                <th>Position</th>
                <th>Fees</th>
                <th>PnL</th>
                <th>Closed</th>
                <th>Symbol Open</th>
                <th>Symbol Close</th>
                <th>Mom</th>
                <th>W/L</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div id="recent-fills-content" class="tab-content" style="display: none;">
        <div style="height: 194px; overflow-y: auto;">
          <table id="recentTradesTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr>
                <th>Date</th>
                <th>Time</th>
                <th>Contract</th>
                <th>Strike</th>
                <th>Side</th>
                <th>Count</th>
                <th>Price</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div id="settlements-content" class="tab-content" style="display: none;">
        <div style="height: 194px; overflow-y: auto;">
          <table id="settlementsTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr>
                <th>Ticker</th>
                <th>Result</th>
                <th>Yes</th>
                <th>No</th>
                <th>Revenue</th>
                <th>Settled At</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div id="open-positions-content" class="tab-content" style="display: none;">
        <table id="openPositionsTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th>Ticker</th>
              <th>Buy</th>
              <th>Position</th>
              <th>Fees</th>
              <th>Time</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
  <script type="text/javascript">
    new TradingView.widget({
      "width": "100%",
      "height": "285",
      "symbol": "COINBASE:BTCUSD",
      "interval": "1",
      "timezone": "Etc/UTC",
      "theme": "dark",
      "style": "1",
      "locale": "en",
      "toolbar_bg": "#f1f3f6",
      "scalesProperties.textColor": "#FFFFFF",
      "backgroundColor": "#1e2733",
      "enable_publishing": false,
      "hide_top_toolbar": true,
      "hide_legend": true,
      "save_image": false,
      "disabled_features": ["volume_force_overlay", "create_volume_indicator_by_default"],
      "studies": [],
      "container_id": "tradingview_12345"
    });
  </script>

  <script>
    window.momentumData = {
      deltas: {
        '1m': null,
        '2m': null,
        '3m': null,
        '4m': null,
        '15m': null,
        '30m': null,
      },
      weightedScore: null,
    };

    function formatNumber(val, addPercent) {
      if (val === null || val === undefined || isNaN(val)) return '—';
      const prefix = val >= 0 ? '+' : '';
      return prefix + (val * 100).toFixed(0) + (addPercent ? '%' : '');
    }

    // Global variable to store momentum_delta for use elsewhere
    window.momentum_delta = 0;

    function updateMomentumPanel() {
      const { deltas, weightedScore } = window.momentumData;

      // Ensure rollingScores array exists
      if (!window.momentumData.rollingScores) {
        window.momentumData.rollingScores = [];
      }

      const momentumScoreEl = document.getElementById('momentum-score-display');
      if (momentumScoreEl) {
        momentumScoreEl.textContent = formatNumber(weightedScore, false);
      }

      // After updating the display, append weightedScore to rollingScores and trim to 40
      if (typeof weightedScore === "number" && !isNaN(weightedScore)) {
        window.momentumData.rollingScores.push(weightedScore);
        if (window.momentumData.rollingScores.length > 40) {
          window.momentumData.rollingScores = window.momentumData.rollingScores.slice(-40);
        }
      }

      // --- Calculate momentum_delta using "momentum of momentum" (second derivative) method ---
      // Maintain a longer history for delta calculation
      if (!window.momentumData.momentumScoreHistory) {
        window.momentumData.momentumScoreHistory = [];
      }
      if (typeof weightedScore === "number" && !isNaN(weightedScore)) {
        window.momentumData.momentumScoreHistory.push(weightedScore);
        // Keep at most 120 points
        if (window.momentumData.momentumScoreHistory.length > 120) {
          window.momentumData.momentumScoreHistory = window.momentumData.momentumScoreHistory.slice(-120);
        }
      }
      // momentum_delta and indicator display removed from UI

      Object.entries(deltas).forEach(([key, val]) => {
        const el = document.getElementById(`delta-${key}`);
        if (el) el.textContent = formatNumber(val, false);
      });

      renderMomentumBarChart(deltas);
      drawRollingMomentumChart();
      
      // Fingerprint now updated from consolidated strike table data - no separate API call needed
    }
    
    // Fingerprint display now handled by consolidated strike table data in strike-table.js

    // Chart.js-based momentum bar chart (flicker-free: update data in place)
    let momentumBarChart = null;
    function renderMomentumBarChart(deltas) {
      const ctx = document.getElementById('momentumBarChartCanvas').getContext('2d');
      const keys = ['4m', '3m', '2m', '1m'];
      const values = keys.map(k => deltas[k] * 100);
      const bgColors = values.map(v => v >= 0 ? 'rgba(40,167,69,0.7)' : 'rgba(220,53,69,0.7)');

      if (!momentumBarChart) {
        // Initial render
        momentumBarChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: keys,
            datasets: [{
              data: values,
              backgroundColor: bgColors,
            }]
          },
          options: {
            responsive: true,
            animation: false,
            scales: {
              y: {
                min: -50,
                max: 50,
                ticks: { color: '#fff' },
                grid: { color: '#444' }
              },
              x: {
                ticks: { color: '#fff' },
                grid: { color: '#444' }
              }
            },
            plugins: { legend: { display: false } }
          }
        });
      } else {
        // Just update the data
        momentumBarChart.data.datasets[0].data = values;
        momentumBarChart.data.datasets[0].backgroundColor = bgColors;
        momentumBarChart.update();
      }
    }

    // fetchCore() moved to live-data.js

    // Draw rolling momentum chart in the third table
    function drawRollingMomentumChart() {
      const canvas = document.getElementById('rolling-momentum-chart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      // Margins/layout
      const margin = { top: 20, right: 20, bottom: 40, left: 40 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      // Draw vertical axis line at 40px from the left
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.stroke();

      // Y-axis scale: -50 (bottom) to 50 (top)
      const yMin = -50;
      const yMax = 50;
      function yForValue(v) {
        // Map v in [yMin, yMax] to [chartHeight+margin.top, margin.top]
        const y = margin.top + ((yMax - v) / (yMax - yMin)) * chartHeight;
        return y;
      }

      // Draw tick marks and labels for -50, -25, 0, 25, 50 (vertical axis)
      ctx.font = '11px monospace';
      ctx.fillStyle = '#ccc';
      ctx.textAlign = 'right';
      const ticks = [-50, -25, 0, 25, 50];
      ticks.forEach(tick => {
        const y = yForValue(tick);
        // Draw tick mark
        ctx.strokeStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(margin.left - 8, y);
        ctx.lineTo(margin.left, y);
        ctx.stroke();
        // Draw label
        ctx.fillText(tick.toString(), margin.left - 12, y + 4);
      });

      // Draw horizontal zero line
      const zeroY = yForValue(0);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(margin.left, zeroY);
      ctx.lineTo(width - margin.right, zeroY);
      ctx.stroke();

      // === Draw horizontal axis line, ticks, and labels ===
      // Axis line near bottom margin
      const axisY = height - margin.bottom + 5;
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(margin.left, axisY);
      ctx.lineTo(width - margin.right, axisY);
      ctx.stroke();

      // Decide number of ticks based on chart width: about 5-6
      const approxTicks = Math.max(5, Math.min(6, Math.round(chartWidth / 60)));
      const nTicks = approxTicks;
      // For minute labels, use 0 to (nTicks-1)
      ctx.font = '11px monospace';
      ctx.fillStyle = '#ccc';
      ctx.textAlign = 'center';
      const tickHeight = 5;
      const labelOffset = 15;
      const labels = ['4m', '3m', '2m', '1m', '0m'];
      for (let i = 0; i < nTicks; ++i) {
        const x = margin.left + (i * chartWidth) / (nTicks - 1);
        // Draw tick mark
        ctx.strokeStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, axisY + tickHeight);
        ctx.stroke();
        // Draw label with custom time labels
        const label = labels[i] || '';
        ctx.fillText(label, x, axisY + tickHeight + 25);
      }

      // === End horizontal axis and ticks ===

      // Plot the momentum score points scaled accordingly
      // Use history from window.momentumData.rollingScores or fallback to last 40 weightedScore values
      let points = [];
      if (window.momentumData.rollingScores && Array.isArray(window.momentumData.rollingScores)) {
        points = window.momentumData.rollingScores.slice(-40);
      } else if (typeof window.momentumData.weightedScore === 'number') {
        points = Array(40).fill(window.momentumData.weightedScore);
      }
      // Multiply all points by 100 for display in -50..50 range
      points = points.map(v => (v === null || v === undefined || isNaN(v) ? null : v * 100));
      // Do NOT reverse the points array; keep natural order (oldest to newest, left to right).
      // If not enough points, pad with nulls
      if (points.length < 2) {
        // Not enough data to plot
        return;
      }
      // X scale
      const n = points.length;
      const xStep = n > 1 ? chartWidth / (n - 1) : 0;
      // Helper to get point at index i (returns {x, y})
      function getPoint(i) {
        const v = points[i];
        return {
          x: margin.left + i * xStep,
          y: yForValue(v)
        };
      }
      // Smoothing factor (0.2-0.4 is typical)
      const smooth = 0.2;
      // Find valid indices (skip nulls/NaNs)
      let validIndices = [];
      for (let i = 0; i < n; ++i) {
        const v = points[i];
        if (v !== null && v !== undefined && !isNaN(v)) {
          validIndices.push(i);
        }
      }
      if (validIndices.length < 2) return;

      // Helper: map a value in [-40, 40] to a color gradient (red for negative, green for positive)
      function colorForValue(val) {
        // Clamp value to [-40, 40]
        val = Math.max(-40, Math.min(40, val));
        // Map negative: -40 (deep red) to 0 (light red)
        // Map positive: 0 (light green) to 40 (deep green)
        if (val < 0) {
          // Red: from #ffb3b3 (light) to #dc3545 (deep)
          // Interpolate between (255,179,179) and (220,53,69)
          const t = (val + 40) / 40; // 0 at -40, 1 at 0
          const r = Math.round(220 * (1 - t) + 255 * t);
          const g = Math.round(53 * (1 - t) + 179 * t);
          const b = Math.round(69 * (1 - t) + 179 * t);
          return `rgb(${r},${g},${b})`;
        } else {
          // Green: from #b3ffb3 (light) to #28a745 (deep)
          // Interpolate between (179,255,179) and (40,167,69)
          const t = val / 40; // 0 at 0, 1 at 40
          const r = Math.round(179 * (1 - t) + 40 * t);
          const g = Math.round(255 * (1 - t) + 167 * t);
          const b = Math.round(179 * (1 - t) + 69 * t);
          return `rgb(${r},${g},${b})`;
        }
      }

      // Draw smooth line using cubic Bézier curves, segment by segment with color
      for (let j = 1; j < validIndices.length; ++j) {
        const i0 = validIndices[j - 1];
        const i1 = validIndices[j];
        const v0 = points[i0];
        const v1 = points[i1];
        // Compute average value for color mapping
        const avgVal = (v0 + v1) / 2;
        ctx.strokeStyle = colorForValue(avgVal);
        ctx.lineWidth = 2;
        ctx.beginPath();
        const p0 = getPoint(i0);
        const p1 = getPoint(i1);
        // Previous/next indices for control points
        const iPrev = validIndices[j - 2] !== undefined ? validIndices[j - 2] : i0;
        const iNext = validIndices[j + 1] !== undefined ? validIndices[j + 1] : i1;
        const pPrev = getPoint(iPrev);
        const pNext = getPoint(iNext);
        // Calculate control points
        // cp1: from p0 toward pNext
        const dx1 = (p1.x - pPrev.x) * smooth;
        const dy1 = (p1.y - pPrev.y) * smooth;
        const cp1x = p0.x + dx1;
        const cp1y = p0.y + dy1;
        // cp2: from p1 back toward pPrev
        const dx2 = (pNext.x - p0.x) * -smooth;
        const dy2 = (pNext.y - p0.y) * -smooth;
        const cp2x = p1.x + dx2;
        const cp2y = p1.y + dy2;
        ctx.moveTo(p0.x, p0.y);
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p1.x, p1.y);
        ctx.stroke();
      }
      // Optionally: draw points as small circles
      // ctx.fillStyle = '#fff';
      // for (let i = 0; i < n; ++i) {
      //   const v = points[i];
      //   if (v === null || v === undefined || isNaN(v)) continue;
      //   const x = margin.left + i * xStep;
      //   const y = yForValue(v);
      //   ctx.beginPath();
      //   ctx.arc(x, y, 2, 0, 2 * Math.PI);
      //   ctx.fill();
      // }
    }
  </script>
  <script>

    // Helper function to format numbers as $XX,XXX.XX
    function formatUSD(val) {
      if (typeof val !== "number" || isNaN(val)) return "—";
      return "$" + val.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    // Helper: decorate change cell with color and triangle
    function decorateChange(el, val) {
      const num = parseFloat(val);
      if (isNaN(num)) {
        el.textContent = "—";
        el.style.backgroundColor = "";
        el.style.color = "";
        return;
      }
      const triangle = num >= 0 ? " ▲" : " ▼";
      el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
      el.style.color = "#fff";
      el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
      el.style.padding = "2px 6px";
      el.style.borderRadius = "4px";
      el.style.display = "inline-block";
    }

    // NOTE: fetchBTCPriceChanges is now handled by live-data.js
    // The live-data.js module provides centralized data polling for price changes


    // === Momentum Chart (Chart.js) ===
    let momentumChart = null;
    let momentumHistory = [];
    function renderMomentumChart(history) {
      const ctx = document.getElementById('rolling-momentum-chart').getContext('2d');
      const color = history.length < 2 || history[history.length - 1] >= history[history.length - 2] ? '#00cc00' : '#cc0000';
      if (!momentumChart) {
        momentumChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: history.map(() => ''),
            datasets: [{
              label: '',
              data: history,
              borderColor: color,
              borderWidth: 1,
              pointRadius: 0,
              tension: 0.3,
              fill: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            plugins: { legend: { display: false } },
            scales: {
              x: { display: false },
              y: {
                min: -50,
                max: 50,
                ticks: { stepSize: 25, color: '#ccc' },
                grid: { color: '#444' }
              }
            }
          }
        });
      } else {
        momentumChart.data.labels = history.map(() => '');
        momentumChart.data.datasets[0].data = history;
        momentumChart.data.datasets[0].borderColor = color;
        momentumChart.update();
      }
    }


    // === Momentum Chart Duplicate (Chart.js) ===
    // (Poll for fills/positions/settlements/balance REMOVED below)

    // NOTE: fetchOtherCoreData and fetchBTCPriceChanges are now handled by live-data.js
    // The live-data.js module provides centralized data polling for all price updates


  </script>

<script>
  const container = document.getElementById('container');
  const col1 = document.getElementById('col1');
  const col2 = document.getElementById('col2');
  const col3 = document.getElementById('col3');
</script>

</script>

<script>
  // Listen for change events on the ticker-picker select and update ticker-display cell
  document.addEventListener('DOMContentLoaded', function() {
    const tickerSelect = document.getElementById('ticker-picker');
    const tickerDisplay = document.getElementById('ticker-display');
    if (tickerSelect && tickerDisplay) {
      // Set initial display to selected value
      tickerDisplay.textContent = tickerSelect.value;
      tickerSelect.addEventListener('change', function() {
        tickerDisplay.textContent = tickerSelect.value;
      });
    }
  });
</script>
</div>
</body>
<script>
// === Active Trades Panel and Trade Execution ===

const recentTradesTableBody = document.querySelector('#recentTradesTable tbody');

const errorTooltip = document.getElementById('errorTooltip');

function positionErrorTooltip(mouseX, mouseY) {
  if (!errorTooltip) return;
  const left = mouseX - errorTooltip.offsetWidth - 14;
  const top  = mouseY - errorTooltip.offsetHeight / 2;
  errorTooltip.style.left = left + 'px';
  errorTooltip.style.top  = top  + 'px';
}

function showErrorTooltip(text, mouseX, mouseY) {
  if (!errorTooltip) return;
  errorTooltip.textContent = text;
  errorTooltip.style.display = 'block';
  positionErrorTooltip(mouseX, mouseY);
}

function hideErrorTooltip() {
  if (errorTooltip) errorTooltip.style.display = 'none';
}

function formatDateTime(isoString) {
  const date = new Date(isoString);
  const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  return [date.toLocaleDateString(), time];
}

// Utility function to get selected symbol from ticker panel
function getSelectedSymbol() {
  const tickerSelect = document.getElementById('ticker-picker');
  if (tickerSelect) {
    return tickerSelect.value;
  }
  return "";
}

// Utility function to get truncated market title, e.g., "BTC 11am"
function getTruncatedMarketTitle() {
  const cell = document.getElementById('strikePanelMarketTitleCell');
  if (cell && cell.textContent && cell.textContent !== 'Loading market title...') {
    const marketTitle = cell.textContent.trim();
    // Extract time from "BTC price today at 5pm?" -> "5pm"
    const timeMatch = marketTitle.match(/at\s+(.+?)\?/i);
    if (timeMatch) {
      return `BTC ${timeMatch[1].trim()}`;
    }
  }
  return 'BTC Unknown';
}

// Utility function to get current BTC ticker price from the UI
function getCurrentBTCTickerPrice() {
  const el = document.getElementById('btc-price-value');
  if (el && el.textContent) {
    // Remove $ and commas, parse as float
    const val = parseFloat(el.textContent.replace(/\$|,/g, ''));
    return isNaN(val) ? "" : val;
  }
  return "";
}

// Utility function to get current momentum score from the panel
function getCurrentMomentumScore() {
  const el = document.getElementById('momentum-score-display');
  if (el && el.textContent) {
    // Parse the display value (e.g., "+1", "-2", "0") and convert to decimal
    const displayText = el.textContent.trim();
    const val = parseFloat(displayText.replace(/[^\d\.\-]/g, ''));
    if (!isNaN(val)) {
      // Convert from display format (e.g., +1) to decimal format (e.g., 0.01)
      return val / 100;
    }
  }
  return "";
}

// Play a sound by type, allowing overlapping playback
function playSound(type) {
  const soundId = type === 'open' ? 'openTradeSound' : 'closeTradeSound';
  const original = document.getElementById(soundId);
  if (!original) return;

  const clone = original.cloneNode(true); // Allow overlapping playback
  clone.volume = type === 'open' ? 0.1 : 0.2; // Set volume inline
  clone.play().catch(err => {});
}

// Open trade popup function
function showTradeOpenedPopup() {
  const popup = document.getElementById('tradeOpenedPopup');
  if (popup) {
    popup.style.display = 'block';
    setTimeout(() => {
      popup.style.display = 'none';
    }, 3000);
  }
}

async function showPopup(strike, side, price) {
  // showTradeOpenedPopup();   // popup disabled for test
  // --- All other logic temporarily disabled ---
  /*
  // === Backend: Send trade open request ===
  // const res = await fetch('/trades', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({
  //     strike,
  //     side,
  //     price,
  //     // Add other required fields here
  //   })
  // });
  // if (!res.ok) throw new Error('Failed to open trade');
  // const trade = await res.json();

  // === DB: Add to local trades state ===
  // window.trades = window.trades || [];
  // window.trades.push(trade);

  // === UI: Update active trades table ===
  // await fetchAndRenderTrades();
  // showTradeOpenedPopup();
  */
}


// Active trades functionality moved to active-trades-manager.js

// === Active Trades Panel ===
async function fetchAndRenderTrades() {
  try {
    const res = await fetch('/trades?status=open', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch open trades");
    const trades = await res.json();
    
    const tradesTbody = document.querySelector('#test-trades-table tbody');
    if (!tradesTbody) return;
    
    tradesTbody.innerHTML = '';
    
    if (!Array.isArray(trades) || trades.length === 0) {
      // Show empty state
      return;
    }
    
    for (const trade of trades) {
      const row = document.createElement('tr');
      row.innerHTML = `
        <td>${trade.date || ''}</td>
        <td>${trade.time || ''}</td>
        <td>${trade.contract || ''}</td>
        <td>${trade.strike || ''}</td>
        <td>${trade.side || ''}</td>
        <td>${trade.buy_price || ''}</td>
        <td>${trade.position || ''}</td>
      `;
      
      // Add Close button cell
      const closeTd = document.createElement('td');
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'button';
      closeBtn.onclick = function() { 
        const currentPrice = getCurrentBTCTickerPrice();
        closeTrade(trade.id, currentPrice, event); 
      };
      closeTd.appendChild(closeBtn);
      row.appendChild(closeTd);
      tradesTbody.appendChild(row);
    }
  } catch (err) {
    console.error('Error fetching and rendering trades:', err);
    const tradesTbody = document.querySelector('#test-trades-table tbody');
    if (tradesTbody) {
      const row = document.createElement('tr');
      row.innerHTML = `<td colspan="8" style="color:red;">Failed to fetch trades</td>`;
      tradesTbody.appendChild(row);
    }
  }
}

// === Recent Trades Panel (now using fills.db) ===
async function fetchAndRenderRecentTrades() {
  try {
    // Fetch fills data from the fills.db
    const res = await fetch('/api/db/fills', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch recent fills");
    const data = await res.json();
    const fills = data.fills || [];
    
    // Limit to previous 30 fills (same logic as settlements)
    const recentFills = fills.slice(0, 30);
    
    const recentTradesTableBody = document.querySelector('#recentTradesTable tbody');
    if (!recentTradesTableBody) return;
    recentTradesTableBody.innerHTML = '';
    
    if (recentFills.length === 0) {
      // Show "No Fills" message
      const noFillsRow = document.createElement('tr');
      noFillsRow.innerHTML = '<td colspan="7" style="text-align: center; color: #ccc; padding: 20px;">No Fills</td>';
      recentTradesTableBody.appendChild(noFillsRow);
      return;
    }
    
    recentFills.forEach(fill => {
      // Parse the created_time to extract date and time
      const createdTime = new Date(fill.created_time);
      const dateCell = createdTime.toLocaleDateString();
      const timeCell = createdTime.toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit',
        hour12: false 
      });
      // Contract: extract the part before '-T', then last two digits as hour
      let contract = '';
      if (fill.ticker) {
        const tickerMain = fill.ticker.split('-T')[0];
        const hourMatch = tickerMain.match(/(\d{2})$/);
        if (hourMatch) {
          const hour = parseInt(hourMatch[1], 10);
          const ampm = hour >= 12 ? 'pm' : 'am';
          const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
          contract = `BTC ${displayHour}${ampm}`;
        } else {
          contract = fill.ticker;
        }
      }
      
      // Strike: extract number after "-T" at the end of the string
      let strike = '';
      if (fill.ticker) {
        // Find the number after "-T" at the end
        const strikeMatch = fill.ticker.match(/-T(\d+\.?\d*)$/);
        if (strikeMatch) {
          const strikeValue = Math.round(parseFloat(strikeMatch[1]));
          strike = `$${strikeValue.toLocaleString()}`;
        }
      }
      // Side: force display as 'Y' for YES and 'N' for NO, and use original for Buy
      let side = '';
      let buy = '';
      if (fill.side) {
        const s = fill.side.toUpperCase();
        side = s === 'YES' ? 'Y' : (s === 'NO' ? 'N' : s);
        // Convert price from cents to dollars
        const price = s === 'YES' ? fill.yes_price : fill.no_price;
        if (price != null) {
          const priceInDollars = price / 100;
          buy = priceInDollars.toFixed(2);
        } else {
          buy = '';
        }
      }
      // Pos: count
      const pos = fill.count != null ? fill.count : '';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${dateCell}</td>
        <td>${timeCell}</td>
        <td>${contract}</td>
        <td>${strike}</td>
        <td>${side}</td>
        <td>${pos}</td>
        <td>${buy}</td>
      `;
      recentTradesTableBody.appendChild(tr);
    });
  } catch (err) {
    console.error('Error fetching recent fills for trades table:', err);
  }
}

// === Trade History Data Fetching and Rendering ===
async function fetchAndRenderTradeHistory() {
  try {
    const res = await fetch('/trades', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch trade history");
    const trades = await res.json();
    
    const tradeHistoryTableBody = document.querySelector('#tradeHistoryTable tbody');
    if (!tradeHistoryTableBody) return;
    tradeHistoryTableBody.innerHTML = '';
    
    if (trades.length === 0) {
      const noTradesRow = document.createElement('tr');
      noTradesRow.innerHTML = '<td colspan="21" style="text-align: center; color: #ccc; padding: 20px;">No Trades</td>';
      tradeHistoryTableBody.appendChild(noTradesRow);
      return;
    }
    
    // Sort trades by ID (newest first)
    const sortedTrades = trades.sort((a, b) => (b.id || 0) - (a.id || 0));
    
    // Limit to most recent 50 trades for performance
    const recentTrades = sortedTrades.slice(0, 50);
    
    // Group by contract with color coding
    let lastContract = null;
    let groupIndex = 0;
    
    recentTrades.forEach(trade => {
      const tr = document.createElement('tr');
      
      // Check if this is a new contract group
      const isNewGroup = trade.contract !== lastContract;
      if (isNewGroup) {
        groupIndex++;
      }
      lastContract = trade.contract;
      
      // Assign group class based on contract grouping
      tr.classList.add(groupIndex % 2 === 1 ? 'group-odd' : 'group-even');
      
      // Helper to format numbers with + sign for positive values
      function plusSign(val) {
        if (val === null || val === undefined || val === '') return '';
        const num = Number(val);
        if (isNaN(num)) return val;
        return (num > 0 ? '+' : '') + Math.round(num);
      }
      
      // Format PnL
      const pnl = trade.pnl !== null && trade.pnl !== undefined ? Number(trade.pnl).toFixed(2) : '';
      
      // Format win/loss
      const winLoss = trade.win_loss || '';
      
      // Format momentum
      const momentum = trade.momentum !== null && trade.momentum !== undefined ? Number(trade.momentum).toFixed(2) : '';
      
      // Format symbol prices
      const symbolOpen = trade.symbol_open !== null && trade.symbol_open !== undefined ? '$' + Math.round(trade.symbol_open).toLocaleString() : '';
      const symbolClose = trade.symbol_close !== null && trade.symbol_close !== undefined ? '$' + Math.round(trade.symbol_close).toLocaleString() : '';
      
      // Format buy/sell prices
      const buyPrice = trade.buy_price !== null && trade.buy_price !== undefined ? Number(trade.buy_price).toFixed(2) : '';
      const sellPrice = trade.sell_price !== null && trade.sell_price !== undefined ? Number(trade.sell_price).toFixed(2) : '';
      
      // Format probability
      const prob = trade.prob !== null && trade.prob !== undefined ? Number(trade.prob).toFixed(1) : '';
      
      tr.innerHTML = `
        <td>${trade.id || ''}</td>
        <td>${trade.status || ''}</td>
        <td>${trade.date || ''}</td>
        <td>${trade.time || ''}</td>
        <td>${trade.symbol || ''}</td>
        <td>${trade.trade_strategy || ''}</td>
        <td>${trade.contract || ''}</td>
        <td>${trade.strike || ''}</td>
        <td>${trade.side || ''}</td>
        <td>${prob}</td>
        <td>${plusSign(trade.diff)}</td>
        <td>${buyPrice}</td>
        <td>${sellPrice}</td>
        <td>${trade.position || ''}</td>
        <td>${trade.fees || ''}</td>
        <td>${pnl}</td>
        <td>${trade.closed_at || ''}</td>
        <td>${symbolOpen}</td>
        <td>${symbolClose}</td>
        <td>${plusSign(momentum)}</td>
        <td>${plusSign(winLoss)}</td>
      `;
      tradeHistoryTableBody.appendChild(tr);
    });
  } catch (err) {
    console.error('Error fetching trade history:', err);
    const tradeHistoryTableBody = document.querySelector('#tradeHistoryTable tbody');
    if (tradeHistoryTableBody) {
      tradeHistoryTableBody.innerHTML = '<tr><td colspan="21" style="text-align: center; color: red; padding: 20px;">Error loading trade history</td></tr>';
    }
  }
}

// === New function: Close all expired trades (set status to closed and closed_at to current time in NY) ===
async function closeExpiredTrades() {
  try {
    // Fetch all open trades
    const res = await fetch('/trades?status=open', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch open trades");
    const openTrades = await res.json();

    // Get current BTC ticker price from DOM element
    const currentPriceEl = document.getElementById('btc-price-value');
    const currentSymbolPrice = currentPriceEl ? parseFloat(currentPriceEl.textContent.replace(/\$|,/g, '')) : null;

    // Loop over each trade and send a close request
    for (const trade of openTrades) {
      const strike = parseFloat(String(trade.strike).replace(/\$|,/g, '')) || 0;
      const isYes = (trade.side || "").toUpperCase() === "Y";
      // Use inclusive logic for win condition at expiration
      const didWin = isYes ? currentSymbolPrice >= strike : currentSymbolPrice <= strike;

      const payload = {
        status: "closed",
        closed_at: new Date().toLocaleTimeString('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }),
        symbol_close: currentSymbolPrice,
        sell_price: didWin ? 1.00 : 0.00
      };

      const updateRes = await fetch(`/trades/${trade.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!updateRes.ok) {
        console.error(`Failed to close trade ${trade.id}`);
      }
    }

    // Active trades are now handled by active-trades-manager.js
    await fetchAndRenderRecentTrades();
  } catch (err) {
    console.error("Error in closeExpiredTrades:", err);
  }
}

// === Tab Switching Functionality ===
function initializeTabSwitching() {
  const tradeHistoryTab = document.getElementById('trade-history-tab');
  const recentFillsTab = document.getElementById('recent-fills-tab');
  const openPositionsTab = document.getElementById('open-positions-tab');
  const tradeHistoryContent = document.getElementById('trade-history-content');
  const recentFillsContent = document.getElementById('recent-fills-content');
  const openPositionsContent = document.getElementById('open-positions-content');

  function switchToTab(activeTab, activeContent, inactiveTab, inactiveContent) {
    // Update tab styles
    activeTab.classList.add('active');
    activeTab.style.opacity = '1';
    inactiveTab.classList.remove('active');
    inactiveTab.style.opacity = '0.3';
    
    // Update content visibility
    activeContent.classList.add('active');
    activeContent.style.display = 'block';
    inactiveContent.classList.remove('active');
    inactiveContent.style.display = 'none';
  }

  // Trade History tab click handler
  tradeHistoryTab.addEventListener('click', () => {
    // Hide all tabs and show only trade history
    recentFillsTab.classList.remove('active');
    recentFillsTab.style.opacity = '0.3';
    openPositionsTab.classList.remove('active');
    openPositionsTab.style.opacity = '0.3';
    settlementsTab.classList.remove('active');
    settlementsTab.style.opacity = '0.3';
    tradeHistoryTab.classList.add('active');
    tradeHistoryTab.style.opacity = '1';
    
    // Hide all content and show only trade history
    recentFillsContent.classList.remove('active');
    recentFillsContent.style.display = 'none';
    openPositionsContent.classList.remove('active');
    openPositionsContent.style.display = 'none';
    settlementsContent.classList.remove('active');
    settlementsContent.style.display = 'none';
    tradeHistoryContent.classList.add('active');
    tradeHistoryContent.style.display = 'block';
    
    // Refresh trade history data
    fetchAndRenderTradeHistory();
  });

  // Recent Fills tab click handler
  recentFillsTab.addEventListener('click', () => {
    // Hide all tabs and show only recent fills
    tradeHistoryTab.classList.remove('active');
    tradeHistoryTab.style.opacity = '0.3';
    openPositionsTab.classList.remove('active');
    openPositionsTab.style.opacity = '0.3';
    settlementsTab.classList.remove('active');
    settlementsTab.style.opacity = '0.3';
    recentFillsTab.classList.add('active');
    recentFillsTab.style.opacity = '1';
    
    // Hide all content and show only recent fills
    tradeHistoryContent.classList.remove('active');
    tradeHistoryContent.style.display = 'none';
    openPositionsContent.classList.remove('active');
    openPositionsContent.style.display = 'none';
    settlementsContent.classList.remove('active');
    settlementsContent.style.display = 'none';
    recentFillsContent.classList.add('active');
    recentFillsContent.style.display = 'block';
    
    // Refresh recent fills data
    fetchAndRenderRecentTrades();
  });

  // Open Positions tab click handler
  openPositionsTab.addEventListener('click', () => {
    // Hide all tabs and show only positions
    tradeHistoryTab.classList.remove('active');
    tradeHistoryTab.style.opacity = '0.3';
    recentFillsTab.classList.remove('active');
    recentFillsTab.style.opacity = '0.3';
    settlementsTab.classList.remove('active');
    settlementsTab.style.opacity = '0.3';
    openPositionsTab.classList.add('active');
    openPositionsTab.style.opacity = '1';
    
    // Hide all content and show only positions
    tradeHistoryContent.classList.remove('active');
    tradeHistoryContent.style.display = 'none';
    recentFillsContent.classList.remove('active');
    recentFillsContent.style.display = 'none';
    settlementsContent.classList.remove('active');
    settlementsContent.style.display = 'none';
    openPositionsContent.classList.add('active');
    openPositionsContent.style.display = 'block';
    
    // Fetch and render positions data
    fetchAndRenderPositions();
  });

  // Settlements tab click handler
  const settlementsTab = document.getElementById('settlements-tab');
  const settlementsContent = document.getElementById('settlements-content');
  
  settlementsTab.addEventListener('click', () => {
    // Hide all tabs and show only settlements
    tradeHistoryTab.classList.remove('active');
    tradeHistoryTab.style.opacity = '0.3';
    recentFillsTab.classList.remove('active');
    recentFillsTab.style.opacity = '0.3';
    openPositionsTab.classList.remove('active');
    openPositionsTab.style.opacity = '0.3';
    settlementsTab.classList.add('active');
    settlementsTab.style.opacity = '1';
    
    // Hide all content and show only settlements
    tradeHistoryContent.classList.remove('active');
    tradeHistoryContent.style.display = 'none';
    recentFillsContent.classList.remove('active');
    recentFillsContent.style.display = 'none';
    openPositionsContent.classList.remove('active');
    openPositionsContent.style.display = 'none';
    settlementsContent.classList.add('active');
    settlementsContent.style.display = 'block';
    
    // Fetch and render settlements data
    fetchAndRenderSettlements();
  });


}

// Function to update Open Positions tab count
function updateOpenPositionsTabCount(count) {
  const openPositionsTab = document.getElementById('open-positions-tab');
  if (openPositionsTab) {
    if (count > 0) {
      openPositionsTab.textContent = `Open Positions (${count})`;
    } else {
      openPositionsTab.textContent = 'Open Positions';
    }
  }
}

// === Positions Data Fetching and Rendering ===
async function fetchAndRenderPositions() {
  try {
    const response = await fetch('/api/db/positions', { cache: 'no-store' });
    if (!response.ok) {
      throw new Error('Failed to fetch positions data');
    }
    
    const data = await response.json();
    const positions = data.positions || [];
    
    const openPositionsTableBody = document.querySelector('#openPositionsTable tbody');
    if (!openPositionsTableBody) return;
    
    // Clear existing content
    openPositionsTableBody.innerHTML = '';
    
    if (positions.length === 0) {
      // Show "No Open Positions" message
      const noPositionsRow = document.createElement('tr');
      noPositionsRow.innerHTML = '<td colspan="5" style="text-align: center; color: #ccc; padding: 20px;">No Open Positions</td>';
      openPositionsTableBody.appendChild(noPositionsRow);
      updateOpenPositionsTabCount(0);
      return;
    }
    
    // Filter positions with non-zero positions
    const activePositions = positions.filter(p => p.position !== 0);
    
    // Update the tab count
    updateOpenPositionsTabCount(activePositions.length);
    
    // Render positions data using the same logic as account_manager.html
    openPositionsTableBody.innerHTML = activePositions
      .map(p => `
        <tr>
          <td>${p.ticker}</td>
          <td>${p.market_exposure && p.position !== 0 ? (p.market_exposure / p.position / 100).toFixed(2) : "0.00"}</td>
          <td>${p.position}</td>
          <td>${(p.fees_paid / 100).toFixed(2)}</td>
          <td>${new Date(p.last_updated_ts).toLocaleTimeString("en-US", { timeZone: "America/New_York", hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}</td>
        </tr>
      `).join("");
    
  } catch (error) {
    console.error('Error fetching positions:', error);
    const openPositionsTableBody = document.querySelector('#openPositionsTable tbody');
    if (openPositionsTableBody) {
      openPositionsTableBody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: #dc3545; padding: 20px;">Error loading positions</td></tr>';
    }
  }
}



// === Settlements Data Fetching and Rendering ===
async function fetchAndRenderSettlements() {
  try {
    const response = await fetch('/api/db/settlements', { cache: 'no-store' });
    if (!response.ok) {
      throw new Error('Failed to fetch settlements data');
    }
    
    const data = await response.json();
    const allSettlements = data.settlements || [];
    
    // Limit to previous 30 settlements
    const recentSettlements = allSettlements.slice(0, 30);
    
    const settlementsTableBody = document.querySelector('#settlementsTable tbody');
    if (!settlementsTableBody) return;
    
    // Clear existing content
    settlementsTableBody.innerHTML = '';
    
    if (recentSettlements.length === 0) {
      // Show "No Settlements" message
      const noSettlementsRow = document.createElement('tr');
      noSettlementsRow.innerHTML = '<td colspan="6" style="text-align: center; color: #ccc; padding: 20px;">No Settlements</td>';
      settlementsTableBody.appendChild(noSettlementsRow);
      return;
    }
    
    // Render settlements data using the same logic as account_manager.html
    settlementsTableBody.innerHTML = recentSettlements.map(s => {
      // Convert revenue from cents to dollars
      const revenueInDollars = s.revenue / 100;
      const formattedRevenue = revenueInDollars.toLocaleString(undefined, { 
        minimumFractionDigits: 0, 
        maximumFractionDigits: 0 
      });
      
      return `
        <tr>
          <td>${s.ticker}</td>
          <td>${s.market_result === "yes" ? "Y" : "N"}</td>
          <td>${s.yes_count}</td>
          <td>${s.no_count}</td>
          <td>$${formattedRevenue}</td>
          <td>${new Date(s.settled_time).toLocaleTimeString("en-US", { timeZone: "America/New_York", hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}</td>
        </tr>
      `;
    }).join("");
    
  } catch (error) {
    console.error('Error fetching settlements:', error);
    const settlementsTableBody = document.querySelector('#settlementsTable tbody');
    if (settlementsTableBody) {
      settlementsTableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #dc3545; padding: 20px;">Error loading settlements</td></tr>';
    }
  }
}

// === Open Positions Data Fetching (placeholder for future implementation) ===
async function fetchAndRenderOpenPositions() {
  try {
    // This is a placeholder function for future implementation
    // For now, it will show an empty table
    const openPositionsTableBody = document.querySelector('#openPositionsTable tbody');
    if (!openPositionsTableBody) return;
    
    openPositionsTableBody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #ccc;">No open positions</td></tr>';
  } catch (err) {
    console.error('Error fetching open positions:', err);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  fetchAndRenderTradeHistory(); // Load trade history data since it's now the default tab
  fetchAndRenderRecentTrades();
  fetchAndRenderPositions();
  initializeTabSwitching();
  
  // Set up WebSocket connection for database change notifications
  setupDatabaseChangeListener();
});

// WebSocket connection for database change notifications
function setupDatabaseChangeListener() {
  const ws = new WebSocket(`ws://${window.location.host}/ws/db_changes`);
  
  ws.onopen = function() {
    console.log('🔗 Connected to database change notifications');
  };
  
  ws.onmessage = function(event) {
    try {
      const data = JSON.parse(event.data);
      console.log('📡 Received database change notification:', data);
      
      // Handle different database change types and refresh immediately
      if (data.database === 'fills') {
        console.log('🔄 Refreshing fills table due to database change');
        fetchAndRenderRecentTrades();
      } else if (data.database === 'positions') {
        console.log('🔄 Refreshing positions table due to database change');
        fetchAndRenderPositions();
      } else if (data.database === 'settlements') {
        console.log('🔄 Refreshing settlements table due to database change');
        fetchAndRenderSettlements();
      } else if (data.database === 'trades') {
        console.log('🔄 Refreshing trade history table due to database change');
        fetchAndRenderTradeHistory();
      }
    } catch (error) {
      console.error('❌ Error parsing database change notification:', error);
    }
  };
  
  ws.onerror = function(error) {
    console.error('❌ WebSocket error:', error);
  };
  
  ws.onclose = function() {
    console.log('🔌 Database change WebSocket connection closed');
    // Attempt to reconnect after a delay
    setTimeout(() => {
      console.log('🔄 Attempting to reconnect to database change notifications...');
      setupDatabaseChangeListener();
    }, 5000);
  };
}



</script>
<script>
  function showTradeOpenedPopup() {
    const popup = document.getElementById('tradeOpenedPopup');
    if (!popup) return;

    popup.style.transition = 'none';
    popup.style.display = 'block';
    popup.style.opacity = '1';

    setTimeout(() => {
      popup.style.transition = 'opacity 0.5s ease';
      popup.style.opacity = '0';
      setTimeout(() => {
        popup.style.display = 'none';
      }, 500);
    }, 2000);
  }

  function showTradeClosedPopup() {
    const popup = document.getElementById('tradeClosedPopup');
    if (!popup) return;

    popup.style.transition = 'none';
    popup.style.display = 'block';
    popup.style.opacity = '1';

    setTimeout(() => {
      popup.style.transition = 'opacity 0.5s ease';
      popup.style.opacity = '0';
      setTimeout(() => {
        popup.style.display = 'none';
      }, 500);
    }, 2000);
  }

  function showAutomatedTradeNotification(tradeData) {
    // Create a special automated trade notification popup
    const notification = document.createElement('div');
    notification.className = 'automated-trade-notification';
    notification.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 280px;
      background: linear-gradient(135deg, #00ff88, #00cc66);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
      border: 2px solid #00ff88;
      max-width: 250px;
    `;
    
    // Create the notification content
    const strike = tradeData.strike || 'Unknown';
    const side = tradeData.side || 'Unknown';
    const buyPrice = tradeData.buy_price ? `$${tradeData.buy_price.toFixed(2)}` : 'Unknown';
    const probability = tradeData.probability ? `${tradeData.probability}%` : 'Unknown';
    
    notification.innerHTML = `
      <div style="margin-bottom: 8px; font-size: 12px;">🤖 AUTO TRADE</div>
      <div style="font-size: 11px; margin-bottom: 3px;">${strike} ${side.toUpperCase()}</div>
      <div style="font-size: 11px; margin-bottom: 3px;">${buyPrice} (${probability})</div>
    `;
    
    // Add to page
    document.body.appendChild(notification);
    
    // Show the notification
    setTimeout(() => {
      notification.style.opacity = '1';
    }, 100);
    
    // Hide after 4 seconds
    setTimeout(() => {
      notification.style.opacity = '0';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 4000);
  }

  function showAutomatedTradeCloseNotification(tradeData) {
    // Create a special automated trade close notification popup
    const notification = document.createElement('div');
    notification.className = 'automated-trade-close-notification';
    notification.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 280px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.3s ease;
      border: 2px solid #ff6b6b;
      max-width: 250px;
    `;

    // Create the notification content
    const strike = tradeData.strike || 'Unknown';
    const side = tradeData.side || 'Unknown';
    const buyPrice = tradeData.buy_price ? `$${tradeData.buy_price.toFixed(2)}` : 'Unknown';
    const sellPrice = tradeData.sell_price ? `$${tradeData.sell_price.toFixed(2)}` : 'Unknown';
    const pnl = tradeData.pnl || 'Unknown';
    
    notification.innerHTML = `
      <div style="margin-bottom: 8px; font-size: 12px;">🤖 AUTO CLOSE</div>
      <div style="font-size: 11px; margin-bottom: 3px;">${strike} ${side.toUpperCase()}</div>
      <div style="font-size: 11px; margin-bottom: 3px;">Buy: ${buyPrice} | Sell: ${sellPrice}</div>
      <div style="font-size: 11px;">PnL: ${pnl}</div>
    `;

    // Add to page
    document.body.appendChild(notification);

    // Show the notification
    setTimeout(() => {
      notification.style.opacity = '1';
    }, 100);

    // Hide after 4 seconds
    setTimeout(() => {
      notification.style.opacity = '0';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }, 4000);
  }
</script>
</script>
</script>

  <!-- Trade Open/Closed Popups -->
  <div id="tradeOpenedPopup" class="trade-popup">Trade Opened</div>
  <div id="tradeClosedPopup" class="trade-closed-popup">Trade Closed</div>



  <!-- Preload audio for trade open/close confirmations -->
  <audio id="openTradeSound" preload="auto">
    <source src="/audio/sfx/open_trade_confirmation.wav" type="audio/wav">
  </audio>
  <audio id="closeTradeSound" preload="auto">
    <source src="/audio/sfx/close_trade_confirmation.wav" type="audio/wav">
  </audio>
  <!-- === Staggered polling loops for main panels === -->
  <script>
  // NOTE: All polling is now handled by live-data.js module
  // This centralized approach prevents conflicts and ensures consistent updates
  </script>

  <!-- --- Add a MutationObserver to update arrows when momentum score changes --- -->
  <script>
  (function setupMomentumArrowObserver() {
    const momentumEl = document.getElementById('momentum-score-display');
    if (!momentumEl) {
      setTimeout(setupMomentumArrowObserver, 1000);
      return;
    }
    const observer = new MutationObserver(() => {
      // Helper function to update spanner row arrows
      function updateSpannerArrows(tableSelector) {
        const spannerRow = document.querySelector(`${tableSelector} tr.spanner-row`);
        if (!spannerRow) {
          return;
        }
        const spannerTd = spannerRow.querySelector('td');
        if (!spannerTd) {
          return;
        }
        const val = parseFloat(momentumEl.textContent.replace(/[^\d\.\-]/g, ''));
        // SVGs for straight arrows (no margin)
        const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
        let arrowBlock = '';
        const absMomentum = Math.abs(val);
        if (absMomentum < 5) {
          arrowBlock = '-';
        } else if (absMomentum < 10) {
          arrowBlock = val > 0 ? svgDown : svgUp;
        } else if (absMomentum < 20) {
          arrowBlock = (val > 0 ? svgDown : svgUp).repeat(2);
        } else {
          arrowBlock = (val > 0 ? svgDown : svgUp).repeat(3);
        }
        // Extract the price from the current text
        const match = spannerTd.textContent.match(/Current Price: \$[\d,]+/);
        const priceText = match ? match[0] : '';
        spannerTd.innerHTML = `<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>${priceText}<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>`;
      }
      
      // Update spanner rows in all tables
      
      updateSpannerArrows('#strike-table');
    });
    observer.observe(momentumEl, { childList: true, characterData: true, subtree: true });
  })();
  </script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const autoStopSettingsIcon = document.getElementById('autoStopSettingsIcon');
  const autoStopSettingsModal = document.getElementById('autoStopSettingsModal');
  const autoStopSettingsDim = document.getElementById('autoStopSettingsDim');
  const autoStopSettingsCancel = document.getElementById('autoStopSettingsCancel');
  const autoStopSettingsSave = document.getElementById('autoStopSettingsSave');
  const autoStopProbabilitySlider = document.getElementById('autoStopProbabilitySlider');
  const sliderValueDisplay = document.getElementById('sliderValueDisplay');
  let lastSavedProbability = 25;

  function updateSliderDisplay(value) {
    if (sliderValueDisplay && autoStopProbabilitySlider) {
      sliderValueDisplay.textContent = value + '%';
      // Calculate thumb position in px
      const min = parseInt(autoStopProbabilitySlider.min, 10);
      const max = parseInt(autoStopProbabilitySlider.max, 10);
      const percent = (value - min) / (max - min);
      const sliderWidth = autoStopProbabilitySlider.offsetWidth;
      // 16px is approx thumb width, adjust as needed
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      sliderValueDisplay.style.left = `${offset}px`;
    }
  }

  async function fetchAutoStopSettings() {
    try {
      const resp = await fetch('/api/get_auto_stop_settings');
      if (resp.ok) {
        const data = await resp.json();
        return data.current_probability ?? 25;
      }
    } catch {}
    return 25;
  }

  function showAutoStopSettingsModal() {
    if (autoStopSettingsModal) {
      autoStopSettingsModal.style.display = 'block';
      document.body.style.overflow = 'hidden';
      fetchAutoStopSettings().then(prob => {
        lastSavedProbability = prob;
        autoStopProbabilitySlider.value = prob;
        updateSliderDisplay(prob);
      });
      // Fetch min_ttc_seconds
      fetch('/api/get_auto_stop_settings').then(r => r.json()).then(data => {
        const minTTC = data.min_ttc_seconds !== undefined ? data.min_ttc_seconds : 60;
        const minTTCInput = document.getElementById('autoStopMinTTCInput');
        const minTTCDisplay = document.getElementById('autoStopMinTTCDisplay');
        minTTCInput.value = minTTC;
        minTTCDisplay.textContent = formatSecondsToMMSS(minTTC);
        window.lastSavedMinTTC = minTTC;
      });
    }
  }

  function hideAutoStopSettingsModal() {
    if (autoStopSettingsModal) {
      autoStopSettingsModal.style.display = 'none';
      document.body.style.overflow = '';
    }
  }

  if (autoStopSettingsIcon) {
    autoStopSettingsIcon.addEventListener('click', showAutoStopSettingsModal);
  }
  if (autoStopSettingsCancel) {
    autoStopSettingsCancel.addEventListener('click', function() {
      // Reset slider to last saved value
      autoStopProbabilitySlider.value = lastSavedProbability;
      updateSliderDisplay(lastSavedProbability);
      // Reset TTC input to last saved value
      if (window.lastSavedMinTTC !== undefined) {
        const minTTCInput = document.getElementById('autoStopMinTTCInput');
        const minTTCDisplay = document.getElementById('autoStopMinTTCDisplay');
        minTTCInput.value = window.lastSavedMinTTC;
        minTTCDisplay.textContent = formatSecondsToMMSS(window.lastSavedMinTTC);
      }
      hideAutoStopSettingsModal();
    });
  }
  if (autoStopSettingsSave) {
    autoStopSettingsSave.addEventListener('click', async function() {
      const newProb = parseInt(autoStopProbabilitySlider.value, 10);
      const minTTCInput = document.getElementById('autoStopMinTTCInput');
      const minTTC = parseInt(minTTCInput.value, 10);
      if (!isNaN(newProb)) {
        try {
          const response = await fetch('/api/set_auto_stop_settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled: true, current_probability: newProb, min_ttc_seconds: minTTC })
          });
          if (response.ok) {
            console.log('Auto stop settings saved successfully');
            lastSavedProbability = newProb;
            window.lastSavedMinTTC = minTTC;
          } else {
            console.error('Failed to save auto stop settings:', response.status);
          }
        } catch (error) {
          console.error('Error saving auto stop settings:', error);
        }
      }
      hideAutoStopSettingsModal();
    });
  }
  if (autoStopProbabilitySlider && sliderValueDisplay) {
    autoStopProbabilitySlider.addEventListener('input', function() {
      updateSliderDisplay(this.value);
    });
    // On resize, keep value display in sync
    window.addEventListener('resize', function() {
      updateSliderDisplay(autoStopProbabilitySlider.value);
    });
    // Initial position
    updateSliderDisplay(autoStopProbabilitySlider.value);
  }
  // Remove click-to-close on dimmed area
  if (autoStopSettingsDim) {
    autoStopSettingsDim.addEventListener('click', function(e) {
      // Do nothing
      e.stopPropagation();
    });
  }
});

// Helper to format seconds as mm:ss
function formatSecondsToMMSS(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// Update display and hidden input when buttons are clicked
const minTTCDisplay = document.getElementById('autoStopMinTTCDisplay');
const minTTCInput = document.getElementById('autoStopMinTTCInput');
const minTTCUp = document.getElementById('autoStopMinTTCUp');
const minTTCDown = document.getElementById('autoStopMinTTCDown');

if (minTTCDisplay && minTTCInput && minTTCUp && minTTCDown) {
  minTTCUp.addEventListener('click', function() {
    const currentVal = parseInt(minTTCInput.value, 10) || 0;
    const newVal = currentVal + 15; // Increment by 15 seconds
    minTTCInput.value = newVal;
    minTTCDisplay.textContent = formatSecondsToMMSS(newVal);
  });
  
  minTTCDown.addEventListener('click', function() {
    const currentVal = parseInt(minTTCInput.value, 10) || 0;
    const newVal = Math.max(0, currentVal - 30); // Decrement by 30 seconds, minimum 0
    minTTCInput.value = newVal;
    minTTCDisplay.textContent = formatSecondsToMMSS(newVal);
  });
}

// AUTO ENTRY SETTINGS FUNCTIONALITY
document.addEventListener('DOMContentLoaded', function() {
  const autoEntrySettingsIcon = document.getElementById('autoEntrySettingsIcon');
  const autoEntrySettingsModal = document.getElementById('autoEntrySettingsModal');
  const autoEntrySettingsDim = document.getElementById('autoEntrySettingsDim');
  const autoEntrySettingsCancel = document.getElementById('autoEntrySettingsCancel');
  const autoEntrySettingsSave = document.getElementById('autoEntrySettingsSave');
  const autoEntryProbabilitySlider = document.getElementById('autoEntryProbabilitySlider');
  const autoEntrySliderValueDisplay = document.getElementById('autoEntrySliderValueDisplay');
  const autoEntryDifferentialSlider = document.getElementById('autoEntryDifferentialSlider');
  const autoEntryDifferentialValueDisplay = document.getElementById('autoEntryDifferentialValueDisplay');
  let lastSavedAutoEntryProbability = 25;
  let lastSavedAutoEntryDifferential = 0;

  function updateAutoEntrySliderDisplay(value) {
    if (autoEntrySliderValueDisplay && autoEntryProbabilitySlider) {
      autoEntrySliderValueDisplay.textContent = value + '%';
      // Calculate thumb position in px
      const min = parseInt(autoEntryProbabilitySlider.min, 10);
      const max = parseInt(autoEntryProbabilitySlider.max, 10);
      const percent = (value - min) / (max - min);
      const sliderWidth = autoEntryProbabilitySlider.offsetWidth;
      // 16px is approx thumb width, adjust as needed
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      autoEntrySliderValueDisplay.style.left = `${offset}px`;
    }
  }

  function updateAutoEntryDifferentialDisplay(value) {
    if (autoEntryDifferentialValueDisplay && autoEntryDifferentialSlider) {
      // Parse as float to handle decimal values
      const floatValue = parseFloat(value);
      // Add + sign for positive numbers, keep negative numbers as is
      const displayValue = floatValue >= 0 ? `+${floatValue.toFixed(2)}` : floatValue.toFixed(2);
      autoEntryDifferentialValueDisplay.textContent = displayValue;
      // Calculate thumb position in px
      const min = parseFloat(autoEntryDifferentialSlider.min);
      const max = parseFloat(autoEntryDifferentialSlider.max);
      const percent = (floatValue - min) / (max - min);
      const sliderWidth = autoEntryDifferentialSlider.offsetWidth;
      // 16px is approx thumb width, adjust as needed
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      autoEntryDifferentialValueDisplay.style.left = `${offset}px`;
    }
  }

  function updateSpikeAlertMomentumDisplay(value) {
    const display = document.getElementById('spikeAlertMomentumValueDisplay');
    const slider = document.getElementById('spikeAlertMomentumSlider');
    if (display && slider) {
      display.textContent = `±${value}`;
      // Calculate thumb position in px
      const min = parseInt(slider.min, 10);
      const max = parseInt(slider.max, 10);
      const percent = (value - min) / (max - min);
      const sliderWidth = slider.offsetWidth;
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      display.style.left = `${offset}px`;
    }
  }

  function updateSpikeAlertCooldownDisplay(value) {
    const display = document.getElementById('spikeAlertCooldownValueDisplay');
    const slider = document.getElementById('spikeAlertCooldownSlider');
    if (display && slider) {
      display.textContent = `±${value}`;
      // Calculate thumb position in px
      const min = parseInt(slider.min, 10);
      const max = parseInt(slider.max, 10);
      const percent = (value - min) / (max - min);
      const sliderWidth = slider.offsetWidth;
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      display.style.left = `${offset}px`;
    }
  }

  function updateSpikeAlertTimeDisplay(value) {
    const display = document.getElementById('spikeAlertTimeValueDisplay');
    const slider = document.getElementById('spikeAlertTimeSlider');
    if (display && slider) {
      display.textContent = `${value} min`;
      // Calculate thumb position in px
      const min = parseInt(slider.min, 10);
      const max = parseInt(slider.max, 10);
      const percent = (value - min) / (max - min);
      const sliderWidth = slider.offsetWidth;
      const thumbWidth = 16;
      const offset = percent * (sliderWidth - thumbWidth) + thumbWidth / 2;
      display.style.left = `${offset}px`;
    }
  }

  async function fetchAutoEntrySettings() {
    try {
      const resp = await fetch('/api/get_auto_entry_settings');
      if (resp.ok) {
        const data = await resp.json();
        return {
          min_probability: data.min_probability ?? 25,
          min_differential: data.min_differential ?? 0,
          allow_re_entry: data.allow_re_entry ?? false
        };
      }
    } catch {}
    return { min_probability: 25, min_differential: 0, allow_re_entry: false };
  }

  function showAutoEntrySettingsModal() {
    if (autoEntrySettingsModal) {
      autoEntrySettingsModal.style.display = 'block';
      document.body.style.overflow = 'hidden';
      fetchAutoEntrySettings().then(settings => {
        lastSavedAutoEntryProbability = settings.min_probability;
        lastSavedAutoEntryDifferential = settings.min_differential;
        autoEntryProbabilitySlider.value = settings.min_probability;
        autoEntryDifferentialSlider.value = settings.min_differential;
        updateAutoEntrySliderDisplay(settings.min_probability);
        updateAutoEntryDifferentialDisplay(settings.min_differential);
        
        // Set the allow re-entry checkbox
        const allowReEntryCheckbox = document.getElementById('autoEntryAllowReEntry');
        if (allowReEntryCheckbox) {
          allowReEntryCheckbox.checked = settings.allow_re_entry;
          window.lastSavedAutoEntryAllowReEntry = settings.allow_re_entry;
        }
      });
      // Fetch all settings
      fetch('/api/get_auto_entry_settings').then(r => r.json()).then(data => {
        const minTTC = data.min_ttc_seconds !== undefined ? data.min_ttc_seconds : 60;
        const minTime = data.min_time !== undefined ? data.min_time : 0;
        const maxTime = data.max_time !== undefined ? data.max_time : 3600;
        
        // Set Time Window slider values
        minTimeSeconds = minTime;
        maxTimeSeconds = maxTime;
        
        // Initialize slider after modal is shown
        setTimeout(() => {
          initTimeWindowSlider();
        }, 100);
        
        // Store last saved values for cancel functionality
        window.lastSavedAutoEntryMinTime = minTime;
        window.lastSavedAutoEntryMaxTime = maxTime;
        
        // Load spike alert settings
        const spikeAlertEnabled = data.spike_alert_enabled !== undefined ? data.spike_alert_enabled : true;
        const spikeAlertMomentum = data.spike_alert_momentum_threshold !== undefined ? data.spike_alert_momentum_threshold : 40;
        const spikeAlertCooldown = data.spike_alert_cooldown_threshold !== undefined ? data.spike_alert_cooldown_threshold : 30;
        const spikeAlertTime = data.spike_alert_cooldown_minutes !== undefined ? data.spike_alert_cooldown_minutes : 15;
        
        // Set spike alert controls
        const spikeAlertEnabledCheckbox = document.getElementById('spikeAlertEnabled');
        const spikeAlertMomentumSlider = document.getElementById('spikeAlertMomentumSlider');
        const spikeAlertCooldownSlider = document.getElementById('spikeAlertCooldownSlider');
        const spikeAlertTimeSlider = document.getElementById('spikeAlertTimeSlider');
        
        if (spikeAlertEnabledCheckbox) {
          spikeAlertEnabledCheckbox.checked = spikeAlertEnabled;
          window.lastSavedSpikeAlertEnabled = spikeAlertEnabled;
        }
        
        if (spikeAlertMomentumSlider) {
          spikeAlertMomentumSlider.value = spikeAlertMomentum;
          updateSpikeAlertMomentumDisplay(spikeAlertMomentum);
          window.lastSavedSpikeAlertMomentum = spikeAlertMomentum;
        }
        
        if (spikeAlertCooldownSlider) {
          spikeAlertCooldownSlider.value = spikeAlertCooldown;
          updateSpikeAlertCooldownDisplay(spikeAlertCooldown);
          window.lastSavedSpikeAlertCooldown = spikeAlertCooldown;
        }
        
        if (spikeAlertTimeSlider) {
          spikeAlertTimeSlider.value = spikeAlertTime;
          updateSpikeAlertTimeDisplay(spikeAlertTime);
          window.lastSavedSpikeAlertTime = spikeAlertTime;
        }
      });
    }
  }

  function hideAutoEntrySettingsModal() {
    if (autoEntrySettingsModal) {
      autoEntrySettingsModal.style.display = 'none';
      document.body.style.overflow = '';
    }
  }

  if (autoEntrySettingsIcon) {
    autoEntrySettingsIcon.addEventListener('click', showAutoEntrySettingsModal);
  }
  if (autoEntrySettingsCancel) {
    autoEntrySettingsCancel.addEventListener('click', function() {
      // Reset sliders to last saved values
      autoEntryProbabilitySlider.value = lastSavedAutoEntryProbability;
      autoEntryDifferentialSlider.value = lastSavedAutoEntryDifferential;
      updateAutoEntrySliderDisplay(lastSavedAutoEntryProbability);
      updateAutoEntryDifferentialDisplay(lastSavedAutoEntryDifferential);
      
      // Reset Time Window slider to last saved values
      if (window.lastSavedAutoEntryMinTime !== undefined && window.lastSavedAutoEntryMaxTime !== undefined) {
        minTimeSeconds = window.lastSavedAutoEntryMinTime;
        maxTimeSeconds = window.lastSavedAutoEntryMaxTime;
        updateTimeWindowSlider();
      }
      
      // Reset allow re-entry checkbox to last saved value
      const allowReEntryCheckbox = document.getElementById('autoEntryAllowReEntry');
      if (allowReEntryCheckbox && window.lastSavedAutoEntryAllowReEntry !== undefined) {
        allowReEntryCheckbox.checked = window.lastSavedAutoEntryAllowReEntry;
      }
      
      // Reset spike alert settings to last saved values
      const spikeAlertEnabledCheckbox = document.getElementById('spikeAlertEnabled');
      const spikeAlertMomentumSlider = document.getElementById('spikeAlertMomentumSlider');
      const spikeAlertCooldownSlider = document.getElementById('spikeAlertCooldownSlider');
      const spikeAlertTimeSlider = document.getElementById('spikeAlertTimeSlider');
      
      if (spikeAlertEnabledCheckbox && window.lastSavedSpikeAlertEnabled !== undefined) {
        spikeAlertEnabledCheckbox.checked = window.lastSavedSpikeAlertEnabled;
      }
      
      if (spikeAlertMomentumSlider && window.lastSavedSpikeAlertMomentum !== undefined) {
        spikeAlertMomentumSlider.value = window.lastSavedSpikeAlertMomentum;
        updateSpikeAlertMomentumDisplay(window.lastSavedSpikeAlertMomentum);
      }
      
      if (spikeAlertCooldownSlider && window.lastSavedSpikeAlertCooldown !== undefined) {
        spikeAlertCooldownSlider.value = window.lastSavedSpikeAlertCooldown;
        updateSpikeAlertCooldownDisplay(window.lastSavedSpikeAlertCooldown);
      }
      
      if (spikeAlertTimeSlider && window.lastSavedSpikeAlertTime !== undefined) {
        spikeAlertTimeSlider.value = window.lastSavedSpikeAlertTime;
        updateSpikeAlertTimeDisplay(window.lastSavedSpikeAlertTime);
      }
      
      autoEntrySettingsModal.style.display = 'none';
      document.body.style.overflow = 'auto';
    });
  }
  if (autoEntrySettingsSave) {
    autoEntrySettingsSave.addEventListener('click', async function() {
      const newProb = parseInt(autoEntryProbabilitySlider.value, 10);
      const newDifferential = parseFloat(autoEntryDifferentialSlider.value);
      
      if (!isNaN(newProb) && !isNaN(newDifferential)) {
        try {
          const allowReEntryCheckbox = document.getElementById('autoEntryAllowReEntry');
          const allowReEntry = allowReEntryCheckbox ? allowReEntryCheckbox.checked : false;
          
          // Get spike alert settings
          const spikeAlertEnabledCheckbox = document.getElementById('spikeAlertEnabled');
          const spikeAlertMomentumSlider = document.getElementById('spikeAlertMomentumSlider');
          const spikeAlertCooldownSlider = document.getElementById('spikeAlertCooldownSlider');
          const spikeAlertTimeSlider = document.getElementById('spikeAlertTimeSlider');
          
          const spikeAlertEnabled = spikeAlertEnabledCheckbox ? spikeAlertEnabledCheckbox.checked : true;
          const spikeAlertMomentum = spikeAlertMomentumSlider ? parseInt(spikeAlertMomentumSlider.value) : 40;
          const spikeAlertCooldown = spikeAlertCooldownSlider ? parseInt(spikeAlertCooldownSlider.value) : 30;
          const spikeAlertTime = spikeAlertTimeSlider ? parseInt(spikeAlertTimeSlider.value) : 15;
          
          const response = await fetch('/api/set_auto_entry_settings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              min_probability: newProb,
              min_differential: newDifferential,
              min_ttc_seconds: 60, // Keep default TTC for now
              min_time: minTimeSeconds,
              max_time: maxTimeSeconds,
              allow_re_entry: allowReEntry,
              spike_alert_enabled: spikeAlertEnabled,
              spike_alert_momentum_threshold: spikeAlertMomentum,
              spike_alert_cooldown_threshold: spikeAlertCooldown,
              spike_alert_cooldown_minutes: spikeAlertTime
            })
          });
          
          if (response.ok) {
            lastSavedAutoEntryProbability = newProb;
            lastSavedAutoEntryDifferential = newDifferential;
            window.lastSavedAutoEntryMinTime = minTimeSeconds;
            window.lastSavedAutoEntryMaxTime = maxTimeSeconds;
            window.lastSavedAutoEntryAllowReEntry = allowReEntry;
            window.lastSavedSpikeAlertEnabled = spikeAlertEnabled;
            window.lastSavedSpikeAlertMomentum = spikeAlertMomentum;
            window.lastSavedSpikeAlertCooldown = spikeAlertCooldown;
            window.lastSavedSpikeAlertTime = spikeAlertTime;
            autoEntrySettingsModal.style.display = 'none';
            document.body.style.overflow = 'auto';
          } else {
            console.error('Failed to save auto entry settings');
          }
        } catch (error) {
          console.error('Error saving auto entry settings:', error);
        }
      }
    });
  }
  if (autoEntryProbabilitySlider && autoEntrySliderValueDisplay) {
    autoEntryProbabilitySlider.addEventListener('input', function() {
      updateAutoEntrySliderDisplay(this.value);
    });
    // On resize, keep value display in sync
    window.addEventListener('resize', function() {
      updateAutoEntrySliderDisplay(autoEntryProbabilitySlider.value);
    });
    // Initial position
    updateAutoEntrySliderDisplay(autoEntryProbabilitySlider.value);
  }
  
  if (autoEntryDifferentialSlider && autoEntryDifferentialValueDisplay) {
    autoEntryDifferentialSlider.addEventListener('input', function() {
      updateAutoEntryDifferentialDisplay(this.value);
    });
    // On resize, keep value display in sync
    window.addEventListener('resize', function() {
      updateAutoEntryDifferentialDisplay(autoEntryDifferentialSlider.value);
    });
    // Initial position
    updateAutoEntryDifferentialDisplay(autoEntryDifferentialSlider.value);
  }
  
  // Spike Alert Slider Event Listeners
  const spikeAlertMomentumSlider = document.getElementById('spikeAlertMomentumSlider');
  const spikeAlertCooldownSlider = document.getElementById('spikeAlertCooldownSlider');
  const spikeAlertTimeSlider = document.getElementById('spikeAlertTimeSlider');
  
  if (spikeAlertMomentumSlider) {
    spikeAlertMomentumSlider.addEventListener('input', function() {
      updateSpikeAlertMomentumDisplay(this.value);
    });
    window.addEventListener('resize', function() {
      updateSpikeAlertMomentumDisplay(spikeAlertMomentumSlider.value);
    });
  }
  
  if (spikeAlertCooldownSlider) {
    spikeAlertCooldownSlider.addEventListener('input', function() {
      updateSpikeAlertCooldownDisplay(this.value);
    });
    window.addEventListener('resize', function() {
      updateSpikeAlertCooldownDisplay(spikeAlertCooldownSlider.value);
    });
  }
  
  if (spikeAlertTimeSlider) {
    spikeAlertTimeSlider.addEventListener('input', function() {
      updateSpikeAlertTimeDisplay(this.value);
    });
    window.addEventListener('resize', function() {
      updateSpikeAlertTimeDisplay(spikeAlertTimeSlider.value);
    });
  }
  // Remove click-to-close on dimmed area
  if (autoEntrySettingsDim) {
    autoEntrySettingsDim.addEventListener('click', function(e) {
      // Do nothing
      e.stopPropagation();
    });
  }
});

// AUTO ENTRY TTC CONTROLS
const autoEntryMinTTCDisplay = document.getElementById('autoEntryMinTTCDisplay');
const autoEntryMinTTCInput = document.getElementById('autoEntryMinTTCInput');
const autoEntryMinTTCUp = document.getElementById('autoEntryMinTTCUp');
const autoEntryMinTTCDown = document.getElementById('autoEntryMinTTCDown');

if (autoEntryMinTTCDisplay && autoEntryMinTTCInput && autoEntryMinTTCUp && autoEntryMinTTCDown) {
  autoEntryMinTTCUp.addEventListener('click', function() {
    const currentVal = parseInt(autoEntryMinTTCInput.value, 10) || 0;
    const newVal = currentVal + 15; // Increment by 15 seconds
    autoEntryMinTTCInput.value = newVal;
    autoEntryMinTTCDisplay.textContent = formatSecondsToMMSS(newVal);
  });
  
  autoEntryMinTTCDown.addEventListener('click', function() {
    const currentVal = parseInt(autoEntryMinTTCInput.value, 10) || 0;
    const newVal = Math.max(0, currentVal - 30); // Decrement by 30 seconds, minimum 0
    autoEntryMinTTCInput.value = newVal;
    autoEntryMinTTCDisplay.textContent = formatSecondsToMMSS(newVal);
  });
}







// AUTO ENTRY TIME WINDOW CONTROLS
const timeWindowSliderContainer = document.getElementById('timeWindowSliderContainer');
const minTimeHandle = document.getElementById('minTimeHandle');
const maxTimeHandle = document.getElementById('maxTimeHandle');
const timeWindowRange = document.getElementById('timeWindowRange');
const timeWindowMinDisplay = document.getElementById('timeWindowMinDisplay');
const timeWindowMaxDisplay = document.getElementById('timeWindowMaxDisplay');

let isDragging = false;
let currentHandle = null;
let sliderWidth = 0;
let minTimeSeconds = 0;
let maxTimeSeconds = 3600;

// Initialize slider
function initTimeWindowSlider() {
  if (!timeWindowSliderContainer) return;
  
  // Get the actual slider width more accurately
  sliderWidth = timeWindowSliderContainer.offsetWidth;
  updateTimeWindowSlider();
}

// Update slider positions and range
function updateTimeWindowSlider() {
  if (!sliderWidth) return;
  
  const minPercent = (minTimeSeconds / 3600) * 100;
  const maxPercent = (maxTimeSeconds / 3600) * 100;
  
  minTimeHandle.style.left = `${minPercent}%`;
  maxTimeHandle.style.left = `${maxPercent}%`;
  
  timeWindowRange.style.left = `${minPercent}%`;
  timeWindowRange.style.width = `${maxPercent - minPercent}%`;
  
  // Update time display boxes to align with handles
  timeWindowMinDisplay.textContent = formatSecondsToMMSS(minTimeSeconds);
  timeWindowMaxDisplay.textContent = formatSecondsToMMSS(maxTimeSeconds);
  
  timeWindowMinDisplay.style.left = `${minPercent}%`;
  timeWindowMaxDisplay.style.left = `${maxPercent}%`;
}

// Handle mouse events for dragging
function handleMouseDown(e) {
  isDragging = true;
  currentHandle = e.target;
  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
  e.preventDefault();
}

function handleMouseMove(e) {
  if (!isDragging || !currentHandle) return;
  
  const rect = timeWindowSliderContainer.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const percent = Math.max(0, Math.min(100, (x / rect.width) * 100));
  
  // Map percentage directly to 15-second intervals (240 total intervals: 0-3600 seconds)
  const intervalIndex = Math.round((percent / 100) * 240);
  const snappedSeconds = Math.max(0, Math.min(3600, intervalIndex * 15));
  
  // Debug logging
  console.log('Slider Debug:', {
    x: x,
    percent: percent,
    intervalIndex: intervalIndex,
    snappedSeconds: snappedSeconds,
    isMultipleOf15: snappedSeconds % 15 === 0
  });
  
  if (currentHandle === minTimeHandle) {
    if (snappedSeconds >= maxTimeSeconds) return;
    minTimeSeconds = snappedSeconds;
  } else if (currentHandle === maxTimeHandle) {
    if (snappedSeconds <= minTimeSeconds) return;
    maxTimeSeconds = snappedSeconds;
  }
  
  updateTimeWindowSlider();
}

function handleMouseUp() {
  isDragging = false;
  currentHandle = null;
  document.removeEventListener('mousemove', handleMouseMove);
  document.removeEventListener('mouseup', handleMouseUp);
}

// Add event listeners
if (minTimeHandle && maxTimeHandle) {
  minTimeHandle.addEventListener('mousedown', handleMouseDown);
  maxTimeHandle.addEventListener('mousedown', handleMouseDown);
}

// Initialize slider when modal is shown
function initTimeWindowSliderOnShow() {
  setTimeout(initTimeWindowSlider, 100);
}

// === AUTO ENTRY INDICATOR FUNCTIONS ===

// Fetch initial auto entry indicator state
async function fetchInitialAutoEntryIndicator() {
    try {
        const response = await fetch('/api/auto_entry_indicator');
        if (!response.ok) throw new Error('Failed to fetch auto entry indicator');
        const data = await response.json();
        
        // Update the indicator display
        updateAutoEntryIndicator(data);
    } catch (error) {
        console.error('Error fetching initial auto entry indicator:', error);
    }
}

// Update the auto entry indicator display
function updateAutoEntryIndicator(data) {
    const indicator = document.getElementById('autoEntryIndicator');
    if (!indicator) {
        console.error('Auto entry indicator element not found');
        return;
    }
    
    // Get the indicator elements
    const indicatorDot = indicator.querySelector('div');
    const indicatorText = indicator.querySelector('span');
    
    // Check for SPIKE ALERT state first
    if (data.spike_alert_active) {
        // SPIKE ALERT MODE - Show red indicator
        indicator.style.display = 'flex';
        indicator.style.backgroundColor = '#dc3545'; // Red background
        indicator.style.border = '1px solid #c82333';
        
        if (indicatorDot) {
            indicatorDot.style.background = '#ff6b6b'; // Red dot
        }
        
        if (indicatorText) {
            const recoveryCountdown = data.spike_alert_recovery_countdown;
            if (recoveryCountdown !== null && recoveryCountdown > 0) {
                indicatorText.textContent = `SPIKE ALERT - AUTO TRADING PAUSED (${recoveryCountdown.toFixed(1)}m)`;
            } else {
                indicatorText.textContent = 'SPIKE ALERT - AUTO TRADING PAUSED';
            }
        }
        
        console.log('🚨 SPIKE ALERT: Auto trading paused due to market spike');
        return;
    }
    
    // Use the new scanning_active field as the primary condition
    // This provides the true system-wide scanning status
    if (data.scanning_active) {
        // Show the indicator when scanning is actually active
        indicator.style.display = 'flex';
        indicator.style.backgroundColor = ''; // Reset background
        indicator.style.border = ''; // Reset border
        
        if (indicatorDot) {
            indicatorDot.style.background = '#00ff2f'; // Green dot
        }
        
        if (indicatorText) {
            indicatorText.textContent = 'Automated Trading ON';
        }
        
        console.log('🔔 AUTOMATED TRADING ON: Scanning is active');
    } else {
        // Hide the indicator when scanning is not active
        indicator.style.display = 'none';
        console.log('🔔 AUTOMATED TRADING OFF: Scanning is not active');
        
        // Log additional debug info
        if (data.enabled && !data.service_healthy) {
            console.log('⚠️ Auto entry enabled but service not healthy');
        } else if (data.enabled && data.service_healthy && !data.ttc_within_window) {
            console.log('⚠️ Auto entry enabled and service healthy but TTC not in window');
        } else if (!data.enabled) {
            console.log('⚠️ Auto entry not enabled');
        }
    }
}

// Fetch initial state when page loads
document.addEventListener('DOMContentLoaded', () => {
    fetchInitialAutoEntryIndicator();
});

// Also fetch initial state when live-data.js loads
if (typeof window.liveData !== 'undefined') {
    fetchInitialAutoEntryIndicator();
}
</script>

  <script>
    // Force initialize strike table after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOMContentLoaded - Force initializing strike table');
      
      // Wait a bit for all scripts to load
      setTimeout(function() {
        console.log('Checking strike table functions...');
        console.log('window.StrikeTable:', typeof window.StrikeTable);
        console.log('window.initializeStrikeTableContainer:', typeof window.initializeStrikeTableContainer);
        console.log('window.updateStrikeTable:', typeof window.updateStrikeTable);
        
        if (typeof window.StrikeTable !== 'undefined' && typeof window.StrikeTable.initialize === 'function') {
          console.log('Initializing StrikeTable...');
          window.StrikeTable.initialize();
        } else {
          console.log('StrikeTable not available, trying direct initialization...');
          if (typeof window.initializeStrikeTableContainer === 'function') {
            console.log('Calling initializeStrikeTableContainer...');
            window.initializeStrikeTableContainer();
          }
          if (typeof window.updateStrikeTable === 'function') {
            console.log('Calling updateStrikeTable...');
            window.updateStrikeTable();
          }
        }
        
        // Test API call directly
        setTimeout(function() {
          console.log('Testing API call...');
          fetch('/api/strike_tables/btc')
            .then(response => response.json())
            .then(data => {
              console.log('API response:', data);
              console.log('Strikes count:', data.strikes ? data.strikes.length : 'no strikes');
            })
            .catch(error => {
              console.error('API error:', error);
            });
        }, 500);
      }, 100);
    });
  </script>
  
  <script>
    // Expose trade refresh functions to global scope
    window.fetchAndRenderTrades = fetchAndRenderTrades;
    window.fetchAndRenderRecentTrades = fetchAndRenderRecentTrades;
    window.fetchAndRenderTradeHistory = fetchAndRenderTradeHistory;
  </script>
  
  <script>
    // Auto-refresh trade history table every 10 seconds
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Setting up auto-refresh for trade history table (every 10 seconds)');
      
      // Set up the auto-refresh interval
      const refreshInterval = setInterval(function() {
        console.log('Auto-refreshing trade history table...');
        
        // Refresh trade history data without reloading the page
        // These functions are defined in this file, so they should be available
        try {
          if (typeof fetchAndRenderTrades === 'function') {
            console.log('Calling fetchAndRenderTrades...');
            fetchAndRenderTrades();
          } else {
            console.log('fetchAndRenderTrades function not found');
          }
          
          if (typeof fetchAndRenderRecentTrades === 'function') {
            console.log('Calling fetchAndRenderRecentTrades...');
            fetchAndRenderRecentTrades();
          } else {
            console.log('fetchAndRenderRecentTrades function not found');
          }
          
          // Also try to refresh other trade-related data
          if (typeof fetchAndRenderTradeHistory === 'function') {
            console.log('Calling fetchAndRenderTradeHistory...');
            fetchAndRenderTradeHistory();
          }
          
        } catch (error) {
          console.error('Error during auto-refresh:', error);
        }
      }, 10000); // 10 seconds = 10000 milliseconds
      
      // Store the interval ID so it can be cleared if needed
      window.tradeHistoryRefreshInterval = refreshInterval;
      
      // Optional: Clear interval when page is unloaded
      window.addEventListener('beforeunload', function() {
        if (window.tradeHistoryRefreshInterval) {
          clearInterval(window.tradeHistoryRefreshInterval);
        }
      });
    });
  </script>
</body>
</html>
