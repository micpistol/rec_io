<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="../styles/global.css">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Trade Monitor</title>
<style>
  

  body {
    display: flex;
    flex-direction: row;
  }

  .column {
    width: 33.3333vw;
    overflow-y: auto;
    padding: 10px;
    padding-top: 0px;
  
  }
  .column#col2 {
    width: 33.3333vw;
    overflow-y: auto;
    padding-left: 0px;
    padding-right: 0px;
  }

  .column:first-child {
    border-left: none;
    padding-left: 0px;
  }

  .panel-table {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
  }


  #tickerPanel {
    /* height removed to avoid conflicts */
    flex-shrink: 0;
    overflow: auto;
    border-collapse: collapse;
    color: white;
  }

  #tickerPanel td {
    padding-bottom: 8px;
    text-align: left;
    vertical-align: bottom;
  }


  #tickerPanel tr.price-row td {
    font-size: 270%;
    vertical-align: baseline;
  }

  #tickerPanel tr.change-row td {
    font-size: 70%;
  }

  #tickerPanel tr.chart-row td {
    height: 100%;
    vertical-align: top;
  }

  #newPanel {
    margin-top: 5px;
    border-bottom: 1px solid #a0a9b8;
    text-align: left;
    vertical-align: top;
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
  }

  /* #momentumPanel styles merged into .panel-container above */

  /* === STRIKE TABLE STYLES === */
  .strike-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
    table-layout: fixed;
  }
  .strike-table th {
    font-size: 11px;
    font-weight: bold;
    text-align: center;
    background-color: #222c3c;
    padding: 4px 6px;
  }
  .strike-table td {
    font-size: 14px;
    text-align: right;
    border: 1px solid #888;
    padding: 4px 6px;
  }
  .strike-table td.center {
    text-align: center;
  }
  .strike-table td:nth-child(5) {
    text-align: center;
  }
  .strike-table td:nth-child(6),
  .strike-table td:nth-child(7) {
    text-align: center;
  }

  /* Hide the header row in the watchlist table but preserve column widths */
  #watchlist-table thead {
    visibility: collapse;
  }

  .price-box {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 5px 9.6px;
    border-radius: 8px;
    background-color: transparent;
    font-weight: bold;
    min-width: 48px;
    user-select: none;
    border: 1px solid #ccc;
    transition: background-color 0.2s ease;
    cursor: default;
  }
  .price-box:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }
  .price-box.disabled {
    opacity: 0.1;
    pointer-events: none;
    cursor: default;
  }

  /* Risk color classes */
  .ultra-safe { background-color: #58b558 !important; }
  .safe { background-color: #7ec27e !important; }
  .caution { background-color: #c5ab50 !important; }
  .high-risk { background-color: #a07777 !important; }
  .danger-stop { background-color: #ec3434 !important; }

  /* Column width classes */
  .col-strike { width: 60px; }
  .col-buffer { width: 40px; }
  .col-bm { width: 40px; }
  .col-adj { width: 40px; }
  .col-risk { width: 40px; }
  .col-yes { width: 60px; }
  .col-no { width: 60px; }

  /* === ACTIVE TRADES TABLE STYLES === */
  #activeTradesTable {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
  }
  #activeTradesTable th,
  #activeTradesTable td {
    font-size: 14px;
    border: 1px solid #888;
    padding: 4px 6px;
  }
  /* Center all values (cells) in the Active Trades table */
  #activeTradesTable td {
    text-align: center;
  }
  #activeTradesTable thead th {
    font-size: 13px;
    font-weight: bold;
    text-align: center;
    background-color: #222c3c;
    padding: 4px 6px;
  }

  /* === WATCHLIST TABLE STYLES === */
  #watchlist-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
  }

  #watchlist-table th {
    font-size: 11px;
    font-weight: bold;
    text-align: center;
    background-color: #222c3c;
    padding: 4px 6px;
  }

  #watchlist-table td {
    font-size: 14px;
    text-align: right;
    border: 1px solid #888;
    padding: 4px 6px;
  }

  #watchlist-table td:nth-child(5) {
    text-align: center;
  }
  #watchlist-table td:nth-child(6),
  #watchlist-table td:nth-child(7) {
    text-align: center;
  }
  
  #watchlist-table td:first-child {
    text-align: center;
    padding: 0;
    border: none;
    background: none;
  }
  .momentum-heat-band-spacer {
    width: 20px;
    min-width: 20px;
    max-width: 20px;
    height: 100%;
    min-height: 40px;
    background: none !important;
    border: none !important;
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    display: block;
  }

  .price-box {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 5px 5px;
    border-radius: 8px;
    background-color: transparent;
    font-weight: bold;
    min-width: 48px;
    user-select: none;
    border: 1px solid #ccc;
    transition: background-color 0.2s ease;
    cursor: default;
  }

  .price-box:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }

  .price-box.disabled {
    opacity: 0.1;
    pointer-events: none;
    cursor: default;
  }

</style>
<style>

  /* Remove top, left, right, and interior borders from header row in Active Trades table */
  #activeTradesTable thead tr th {
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: none;
  }
</style>
<style>
#errorTooltip {
  position: absolute;
  z-index: 9999;
  background-color: white;
  color: black;
  border: 3px solid black;
  padding: 10px;
  max-width: 400px;
  font-family: monospace;
  font-size: 12px;
  white-space: pre-wrap;
  display: none;
  pointer-events: none;
}
</style>
<style>
  /* === YES BUTTON STYLES (existing) === */
  .yes-button {
    background-color: #45d34a;
    color: #fff;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    font-size: 1rem;
    font-weight: bold;
    transition: background-color 0.2s;
  }
  .yes-button:hover {
    background-color: #28a745;
    cursor: pointer;
  }
</style>
<style>
  #activeTradesTable tr.spanner-row td {
    background-color: #535668;
    color: #c0c0c0;
    text-align: center;
    font-size: 12px;
    font-style: italic;
    height: 25px;
    padding: 2px 4px;
  }
</style>
<style>
  .trade-popup, .trade-closed-popup {
    position: fixed;
    bottom: 20px;
    right: 20px;
    color: white;
    padding: 18px 30px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 21px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    display: none;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  .trade-popup {
    background-color: #28a745;
  }
  .trade-closed-popup {
    background-color: #dc3545;
  }
  .trade-popup.show,
  .trade-closed-popup.show {
    display: block;
    opacity: 1;
    /* transition stays at default unless overridden in JS */
  }
</style>
<style>
#autoStopToggle {
  accent-color: red;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#autoStopToggle:checked {
  background-color: red;
  box-shadow: none;
}

#autoStopToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#autoStopToggle:focus-visible {
  outline: 2px solid #f00;
  outline-offset: 2px;
}
</style>
<style>
#recoToggle {
  accent-color: #00ff00;
  background-color: transparent;
  border: none;
  outline: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  position: relative;
  cursor: pointer;
  border-radius: 3px;
  box-shadow: inset 0 0 0 1px white;
  transition: outline 0.2s ease;
}

#recoToggle:checked {
  background-color: #00ff00;
  box-shadow: none;
}

#recoToggle:checked::after {
  content: "";
  position: absolute;
  left: 4px;
  top: 1px;
  width: 5px;
  height: 9px;
  border: solid white;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

#recoToggle:focus-visible {
  outline: 2px solid #00ff00;
  outline-offset: 2px;
}
</style>
<style>
  /* === Multiplier Button Styles === */
  .multiplier-btn {
    background-color: transparent;
    border: 1px solid #ccc;
    color: white;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  .multiplier-btn.active {
    background-color: #007bff; /* bright blue */
    border-color: #0056b3;
    color: white;
    font-weight: bold;
    box-shadow: 0 0 6px rgba(0, 123, 255, 0.7);
  }
  .multiplier-btn:hover:not(.active) {
    background-color: rgba(255, 255, 255, 0.1);
  }
</style>
<style>
  /* === STRIKE TABLE RISK COLOR CLASSES === */
  .ultra-safe { background-color: #58b558 !important; }
  .safe { background-color: #7ec27e !important; }
  .caution { background-color: #c5ab50 !important; }
  .high-risk { background-color: #a07777 !important; }
  .danger-stop { background-color: #ec3434 !important; }

</style>
<style>
  /* === RECENT TRADES TABLE STYLES (match Active Trades) === */
  #recentTradesTable {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
  }
  #recentTradesTable th,
  #recentTradesTable td {
    font-size: 12px;
    border: 0px solid #888888;
    padding: 4px 6px;
    text-align: center;
  }
  #recentTradesTable thead th {
    font-size: 13px;
    font-weight: bold;
    background-color: #222c3c;
    padding: 4px 6px;
    border-top: none;
    border-left: none;
    border-right: none;
    border-bottom: 1px solid #222c3c;
  }
</style>
<style>
  #activeTradesTable button.close-trade-btn {
    transform: scale(0.8);
    transform-origin: center;
  }
</style>
<style>
  /* Strike Table Column Widths (page-specific) */
  .col-strike { width: 60px; }
  .col-buffer { width: 40px; }
  .col-bm { width: 40px; }
  .col-adj { width: 40px; }
  .col-risk { width: 40px; }
  .col-yes { width: 60px; }
  .col-no { width: 60px; }
</style>


</head>
<body>
    <div class="column" id="col1">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: flex-start;">
        <select id="ticker-picker" class="dropdown-picker" name="ticker">
          <option value="BTC">BTC/USD</option>
          <option value="ETH">ETH/USD</option>
        </select>
      </div>
      <div class="panel-container" style="min-height: 200px;" id="tickerPanelContainer">
        <table id="tickerPanel" class="panel-table">
          <tbody>
            <tr class="price-row">
              <td style="position: relative;">
                <span id="btc-price-value" style="display: inline-block;">$â€”</span>
                <div id="volIndicator" style="display: inline-block; float: right; text-align: center; margin-left: 10px;">
                  <div style="font-size: 10px; color: #ccc; letter-spacing: 0.5px;">VOL</div>
                  <div id="volLight" style="width: 24px; height: 24px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, #00cc00, #006600); box-shadow: 0 0 4px #00cc00; border: 1px solid #444;"></div>
                </div>
              </td>
            </tr>
            <tr class="change-row">
              <td id="btc-changes-cell">1h &nbsp;<span id="change-1h">â€”</span> &nbsp;&nbsp; 3h &nbsp;<span id="change-3h">â€”</span> &nbsp;&nbsp; 1d &nbsp;<span id="change-1d">â€”</span></td>
            </tr>
            <tr class="chart-row">
              <td><div id="tradingview_12345"></div></td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="panel-container" style="min-height: 00px;" id="momentumPanelContainer">
        <div class="panel-header">Momentum</div>
        <div class="panel-content" id="momentumPanelContent">
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 0 8px 8px 8px;">
            <div></div>
            <div style="display: flex; justify-content: flex-end; align-items: center; gap: 6px; ">
              <div id="momentum-score-value" style="font-size: 25px; font-weight: bold; color: white;">â€”</div>
              <!-- momentum delta indicator removed -->
            </div>
          </div>
          <div style="display: flex; gap: 10px;">
            <div style="width: 30%; height: 180px; background-color: #1e2733; display: flex; align-items: center; justify-content: center;">
              <canvas id="momentumBarChartCanvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            <div style="width: 70%; background-color: #1e2733;">
              <canvas id="rolling-momentum-chart" width="280" height="170" style="display: block; margin: auto;"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div class="panel-container" style="min-height: 150px;" id="volatilityPanel">
        <div class="panel-header">Volatility</div>
        <div style="display: flex; justify-content: flex-end; align-items: center; font-size: 14px; font-weight: bold; gap: 6px;">
          <span style="text-align: right; min-width: 40px;">Score:</span>
          <span id="volScore" style="text-align: right; display: inline-block; width: 50px;">0.00</span>
        </div>
        <div style="display: flex; justify-content: flex-end; align-items: center; font-size: 14px; font-weight: bold; gap: 6px;">
          <span style="text-align: right; min-width: 40px;">Vol MA:</span>
          <span id="volMovingAvg" style="text-align: right; display: inline-block; width: 50px;">0.00</span>
        </div>
        <div style="display: flex; justify-content: flex-end; align-items: center; font-size: 14px; font-weight: bold; gap: 6px;">
          <span style="text-align: right; min-width: 40px;">Vol Î”:</span>
          <span id="volDelta" style="text-align: right; display: inline-block; width: 50px;">0.00</span>
        </div>
        <div style="display: flex; justify-content: flex-end; align-items: center; font-size: 14px; font-weight: bold; margin-top: 12px; gap: 6px;">
          <span style="text-align: right; min-width: 40px;">Spike:</span>
          <span id="volSpike" style="text-align: right; display: inline-block; width: 50px;">0.00</span>
        </div>
      </div>
    </div>
    
    <div class="column" id="col2">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
        <div id="strikePanelMarketTitleCell" style="font-size: 16px; text-align: left;">Loading market title...</div>
        <div id="strikePanelTTC" style="font-size: 27px; font-weight: bold; text-align: right;">&nbsp;</div>
      </div>
      <div class="panel-container" style="min-height: 200px; " id="strikePanelContainer">
        <table id="strikePanelTable" style="width: 100%; height: 100%; ">
          <tbody>
            <!-- Market title and TTC clock row removed -->
          </tbody>
        </table>
        <div style="display: flex; align-items: flex-start;">
          <!-- Strike Table -->
          <table id="strike-table" class="strike-table" style="width: 100%; table-layout: fixed;">
            <colgroup>
              <col class="col-strike">
              <col class="col-buffer">
              <col class="col-bm">
              <col class="col-adj">
              <col class="col-risk">
              <col class="col-yes">
              <col class="col-no">
            </colgroup>
            <thead>
              <tr>
                <th>STRIKE</th>
                <th>BUFFER</th>
                <th>B/M</th>
                <th>Adj</th>
                <th>RISK</th>
                <th>YES</th>
                <th>NO</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
      <div class="panel-container" style="min-height: 100px;" id="watchlistPanel">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
          <span>Watchlist</span>
          <label style="font-size: 12px; user-select: none; color: white; display: flex; align-items: center; gap: 6px; margin: 0;">
            RECO
            <input type="checkbox" id="recoToggle" />
          </label>
        </div>
        <div style="display: flex; flex-direction: row; align-items: stretch;">
          <table id="strike-table" class="strike-table" style="width: 100%; border-collapse: collapse; margin-bottom: 10px;">
            
            <colgroup>
              <col class="col-strike">
              <col class="col-buffer">
              <col class="col-bm">
              <col class="col-adj">
              <col class="col-risk">
              <col class="col-yes">
              <col class="col-no">
            </colgroup>
            <thead style="display:none;">
              <tr>
                <th>STRIKE</th>
                <th>BUFFER</th>
                <th>B/M</th>
                <th>Adj</th>
                <th>RISK</th>
                <th>YES</th>
                <th>NO</th>
              </tr>
            </thead>
            
            
            
            <tbody id="watchlist-body">
              <!-- Watchlist items will be added here -->
            </tbody>
          </table>
        </div>
      </div>
</script>

<!-- === STRIKE TABLES JS (inserted as per instructions) === -->
<script>
// === Trade Open/Close Master Functions (Symmetric) ===
// Modified openTrade to accept a DOM element as the first argument (target)
// --- Row Flash CSS ---
const rowFlashStyle = document.createElement('style');
rowFlashStyle.innerHTML = `
.strike-row-flash {
  animation: strike-row-flash-anim 0.55s linear;
}
@keyframes strike-row-flash {
  0% { background-color: #fff700; color: #222 !important; }
  80% { background-color: #fff700; color: #222 !important; }
  100% { background-color: inherit; color: inherit; }
}
`;
document.head.appendChild(rowFlashStyle);

function openTrade(target) {
  // Play sound and popup immediately
  playSound('open');
  showTradeOpenedPopup();

  const btn = target;
  if (btn?.disabled) return;
  btn.disabled = true;

  // --- Visual feedback: row flash highlight ---
  let row = btn.closest('tr');
  if (row) {
    row.classList.add('strike-row-flash');
    setTimeout(() => row.classList.remove('strike-row-flash'), 600);
  }

  // --- Immediately trigger trade table update (no debounce, no delay, no backend wait) ---
  fetchAndRenderTrades();

  // Defer backend logic to next tick to decouple from UI thread
  setTimeout(() => {
    (async () => {
      try {
        const now = new Date();
        const btnText = btn?.textContent?.trim() || '';
        // Convert prices like 96 to 0.96
        const buy_price = parseFloat((parseFloat(btnText) / 100).toFixed(2));

        const posInput = document.getElementById('position-size');
        const rawBasePos = posInput ? parseInt(posInput.value, 10) : NaN;
        const validBase = Number.isFinite(rawBasePos) && rawBasePos > 0 ? rawBasePos : null;

        const multiplierBtn = document.querySelector('.multiplier-btn.active');
        const multiplier = multiplierBtn ? parseInt(multiplierBtn.dataset.multiplier, 10) : 1;

        const position = validBase !== null ? validBase * multiplier : null;

        const symbol = getSelectedSymbol();
        const contract = getTruncatedMarketTitle();
        // Get the strike and side from data attributes on the parent td or span
        let strike = null;
        let side = null;
        // Attempt to find strike and side from parent td or span
        // Find the row
        let row2 = btn.closest('tr');
        if (row2) {
          // First td is strike cell
          const strikeCell = row2.querySelector('td');
          if (strikeCell) {
            // Remove $ and commas, parse as number
            strike = parseFloat(strikeCell.textContent.replace(/\$|,/g, ''));
          }
          // Determine side by column index
          const tds = Array.from(row2.children);
          for (let i = 0; i < tds.length; ++i) {
            if (tds[i].contains(btn)) {
              if (i === 5) side = 'yes';
              if (i === 6) side = 'no';
            }
          }
        }
        // Fallback: try to get from btn.dataset
        if (!strike && btn.dataset.strike) strike = parseFloat(btn.dataset.strike);
        if (!side && btn.dataset.side) side = btn.dataset.side;
        // Get ticker from data-ticker attribute (on td or span)
        let kalshiTicker = btn.dataset.ticker || null;
        if (!kalshiTicker && btn.parentElement && btn.parentElement.dataset.ticker) {
          kalshiTicker = btn.parentElement.dataset.ticker;
        }
        // Fallback: try to find from latestKalshiMarkets if available
        if (!kalshiTicker && window.latestKalshiMarkets && Array.isArray(window.latestKalshiMarkets) && strike != null) {
          const match = window.latestKalshiMarkets.find(m => Math.round(m.floor_strike) === strike);
          if (match) kalshiTicker = match.ticker;
        }
        const symbol_open = getCurrentBTCTickerPrice();
        const momentum = getCurrentMomentumScore();
        // Use window.coreData for volatility if present
        const volatility = window.coreData?.volatility_score != null
          ? parseFloat(window.coreData.volatility_score.toFixed(2))
          : null;

        // === Generate unique ticket ID just before payload definition ===
        const ticket_id = 'TICKET-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();

        // === Immediately log the initial entry to backend ===
        fetch('/api/log_event', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ticket_id: ticket_id,
            message: "MONITOR: TICKET INITIATED â€” CONFIRMED"
          })
        });
        // === Prune old trade logs right after logging event ===
        fetch('/api/prune_trade_logs', { method: 'POST' });

        // === Construct new payload as specified ===
        const payload = {
          ticket_id:         ticket_id,
          status:            "pending",
          date:              now.toISOString().split("T")[0],
          time:              now.toLocaleTimeString('en-US', { hour12: false }),
          symbol:            symbol,
          market:            "Kalshi",
          trade_strategy:    "Hourly HTC",
          contract:          contract,
          strike:            `$${Number(strike).toLocaleString()}`,
          side:              side && side.toUpperCase() === 'YES' ? 'Y' : (side && side.toUpperCase() === 'NO' ? 'N' : (side ? side[0].toUpperCase() : null)),
          ticker:            kalshiTicker,
          buy_price:         buy_price,
          // position will be set below if valid
          symbol_open:       symbol_open,
          symbol_close:      null,
          momentum:          momentum,
          momentum_delta:    null,
          volatility:        volatility,
          volatility_delta:  null,
          win_loss:          null
        };
        if (position !== null) {
          payload.position = position;
        }

        // ðŸ” Log to console for now â€” we'll send this to backend and executor in next step
        console.log("Prepared trade payload:", payload);

        fetch('/trades', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        })
        .then(() => {
          // (Optionally, trigger another refresh here, but already done above)
          fetchAndRenderRecentTrades();
        })
        .catch(err => console.error('Failed to open trade:', err))
        .finally(() => setTimeout(() => (btn.disabled = false), 500));
      } catch (err) {
        console.error('Failed to open trade:', err);
        setTimeout(() => (btn.disabled = false), 500);
      }
    })();
  }, 0);
}

function closeTrade(tradeId, sellPrice, event) {
  // ðŸŽ§ Sound confirmation
  setTimeout(() => playSound('close'), 0);

  // âœ… Add UI popup
  showTradeClosedPopup();

  const btn = event?.target;
  if (btn?.disabled) return;
  btn.disabled = true;

  // === Send close trade ticket as POST ===
  (async () => {
    try {
      // Fetch trade details to construct the close ticket
      const tradeRes = await fetch(`/trades/${tradeId}`);
      if (!tradeRes.ok) throw new Error('Failed to fetch trade for closing');
      const trade = await tradeRes.json();
      // === Generate unique ticket ID just like in openTrade ===
      const ticket_id = 'TICKET-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();

      // === Immediately log the close ticket creation ===
      await fetch('/api/log_event', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ticket_id: ticket_id,
          message: "MONITOR: CLOSE TICKET INITIATED â€” CONFIRMED"
        })
      });

      // === Prune old trade logs (keep file size sane) ===
      await fetch('/api/prune_trade_logs', { method: 'POST' });

      // === Restore original logic for extracting count from active trades table row ===
      // Find the row in the active trades table corresponding to this tradeId
      let count = null;
      const rows = activeTradesTableBody ? activeTradesTableBody.querySelectorAll('tr') : [];
      for (const row of rows) {
        // Assume a data-position attribute exists on the row for the position count
        if (row.getAttribute && row.getAttribute('data-trade-id') == tradeId) {
          count = parseInt(row.getAttribute('data-position'), 10);
          break;
        }
      }
      // Fallback to trade.position if not found in DOM (but do not provide a default/fallback value)
      if (count === null || isNaN(count)) {
        count = trade.position;
      }

      // Invert side
      let invertedSide = null;
      if (trade.side === 'Y' || trade.side === 'YES') invertedSide = 'N';
      else if (trade.side === 'N' || trade.side === 'NO') invertedSide = 'Y';
      else invertedSide = trade.side;
      // Use current BTC price for symbol_close
      const symbolClose = getCurrentBTCTickerPrice();
      // Compose payload to match open ticket, plus intent: 'close'
      const payload = {
        ticket_id:        ticket_id,
        intent:           'close',
        ticker:           trade.ticker,
        side:             invertedSide,
        count:            count,
        action:           'close',
        type:             'market',
        time_in_force:    'IOC',
        buy_price:        sellPrice,
        symbol_close:     symbolClose
      };
      await fetch('/trades', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      // Refresh panels
      fetchAndRenderTrades();
      fetchAndRenderRecentTrades();
    } catch (err) {
      console.error('Failed to close trade:', err);
    } finally {
      // Reâ€‘enable button after debounce
      setTimeout(() => (btn.disabled = false), 500);
    }
  })();
}

/**
 * Cancel a pending or error trade.
 * Marks the trade as "canceled" in the backend, logs the event, then refreshes the UI.
 */
async function cancelTrade(dbId, ticketId) {
  try {
    // Cancel trade in DB
    await fetch(`/trades/${dbId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status: 'canceled' })
    });

    // Log using full ticket_id
    await fetch('/api/log_event', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ticket_id: ticketId,
        message: 'MONITOR: TRADE CANCELED â€” CONFIRMED'
      })
    });

    updateActiveTrades();
    fetchAndRenderRecentTrades();
  } catch (err) {
    console.error('Failed to cancel trade:', err);
  }
}

// === Track last Yes/No button states ===
const lastButtonStates = new Map();

// Debounce helper function (moved to top-level for reuse)
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    if (timeout) return;
    func.apply(this, args);
    timeout = setTimeout(() => {
      timeout = null;
    }, wait);
  };
}

// Helper function to update Yes/No button with conditional redraw
function updateYesNoButton(spanEl, strike, side, askPrice, isActive, ticker = null) {
  const key = `${strike}-${side}`;
  const prev = lastButtonStates.get(key);
  if (prev && prev.askPrice === askPrice && prev.isActive === isActive) {
    // No change; skip update
    return;
  }

  spanEl.textContent = askPrice > 0 ? askPrice : 'â€”';
  spanEl.className = isActive ? 'price-box' : 'price-box disabled';
  spanEl.style.cursor = isActive ? 'pointer' : 'default';

  // Set data-ticker on the YES/NO cell's parent td (for reference, if needed)
  if (spanEl.parentElement && ticker) {
    spanEl.parentElement.setAttribute('data-ticker', ticker);
  }
  // Also set data-ticker directly on spanEl for easier access in openTrade
  if (ticker) {
    spanEl.setAttribute('data-ticker', ticker);
  }
  // Set data-strike and data-side for easier retrieval in openTrade
  spanEl.setAttribute('data-strike', strike);
  spanEl.setAttribute('data-side', side);

  if (isActive) {
    spanEl.onclick = debounce(function(event) {
      openTrade(spanEl);
    }, 300);
  } else {
    spanEl.onclick = null;
  }

  lastButtonStates.set(key, { askPrice, isActive });
}

// === STRIKE TABLE REFACTOR: persistent rows and in-place update ===
const strikeRowsMap = new Map();

function buildStrikeTableRows(basePrice) {
  const step = 250;
  const rows = [];
  for (let i = basePrice - 6 * step; i <= basePrice + 6 * step; i += step) {
    rows.push(i);
  }
  return rows;
}

function initializeStrikeTable(basePrice) {
  const strikeTableBody = document.querySelector('#strike-table tbody');
  const strikes = buildStrikeTableRows(basePrice);
  strikeTableBody.innerHTML = ''; // only clear once at start
  strikeRowsMap.clear();

  strikes.forEach(strike => {
    const row = document.createElement('tr');

    // Strike cell
    const strikeTd = document.createElement('td');
    strikeTd.textContent = '$' + strike.toLocaleString();
    strikeTd.classList.add('center');
    row.appendChild(strikeTd);

    // Buffer cell
    const bufferTd = document.createElement('td');
    row.appendChild(bufferTd);

    // B/M cell
    const bmTd = document.createElement('td');
    row.appendChild(bmTd);

    // Adj B/M cell
    const adjBmTd = document.createElement('td');
    row.appendChild(adjBmTd);

    // Risk cell
    const riskTd = document.createElement('td');
    row.appendChild(riskTd);

    // Yes button cell and span
    const yesTd = document.createElement('td');
    // Set data-ticker on the cell (will be updated later in updateYesNoButton)
    yesTd.setAttribute('data-ticker', '');
    const yesSpan = document.createElement('span');
    yesTd.appendChild(yesSpan);
    row.appendChild(yesTd);

    // No button cell and span
    const noTd = document.createElement('td');
    noTd.setAttribute('data-ticker', '');
    const noSpan = document.createElement('span');
    noTd.appendChild(noSpan);
    row.appendChild(noTd);

    strikeTableBody.appendChild(row);

    strikeRowsMap.set(strike, {
      row,
      bufferTd,
      bmTd,
      adjBmTd,
      riskTd,
      yesSpan,
      noSpan
    });
  });
}

function updateStrikeTable(coreData, latestKalshiMarkets) {
  if (!coreData || typeof coreData.btc_price !== 'number') return;

  const base = Math.round(coreData.btc_price / 250) * 250;
  const ttcSeconds = coreData.ttc_seconds || 1;
  const ttcMinutes = ttcSeconds / 60;
  const centerPrice = coreData.btc_price;

  strikeRowsMap.forEach((cells, strike) => {
    const { row, bufferTd, bmTd, adjBmTd, riskTd, yesSpan, noSpan } = cells;

    // Buffer
    const buffer = centerPrice - strike;
    bufferTd.textContent = Math.abs(buffer).toLocaleString(undefined, {maximumFractionDigits: 0});

    // B/M and Adj B/M
    const bpm = Math.abs(buffer) / ttcMinutes;
    const adjBpm = bpm * Math.sqrt(ttcMinutes / 15);
    bmTd.textContent = Math.round(bpm).toLocaleString();
    adjBmTd.textContent = adjBpm.toFixed(1);

    // Risk calculation
    let risk = 1;
    if (adjBpm >= 80) risk = 10;
    else if (adjBpm >= 65) risk = 9;
    else if (adjBpm >= 50) risk = 8;
    else if (adjBpm >= 40) risk = 7;
    else if (adjBpm >= 35) risk = 6;
    else if (adjBpm >= 30) risk = 5;
    else if (adjBpm >= 25) risk = 4;
    else if (adjBpm >= 15) risk = 3;
    else if (adjBpm >= 10) risk = 2;

    riskTd.textContent = risk.toString();

    // Update row classes based on risk
    row.className = ''; // reset
    if (risk >= 7) {
      row.classList.add('ultra-safe');
    } else if (risk === 5 || risk === 6) {
      row.classList.add('safe');
    } else if (risk === 4) {
      row.classList.add('caution');
    } else if (risk >= 1 && risk <= 3) {
      row.classList.add('high-risk');
    }

    // Active row border highlight
    const lowerBound = strike;
    const upperBound = strike + 249.9999;
    const isActiveRow = centerPrice >= lowerBound && centerPrice <= upperBound;
    if (isActiveRow) {
      [cells.row.children[0], bufferTd, bmTd, adjBmTd, riskTd, yesSpan.parentElement, noSpan.parentElement].forEach(cell => {
        cell.style.borderTop = "3px solid #444";
        cell.style.borderBottom = "3px solid #444";
      });
    } else {
      [cells.row.children[0], bufferTd, bmTd, adjBmTd, riskTd, yesSpan.parentElement, noSpan.parentElement].forEach(cell => {
        cell.style.borderTop = "";
        cell.style.borderBottom = "";
      });
    }

    // Find markets for yes/no asks - use more flexible matching
    const matchingMarket = latestKalshiMarkets.find(m => {
      const marketStrike = Math.round(m.floor_strike);
      return marketStrike === strike || Math.abs(marketStrike - strike) <= 1;
    });
    
    // Debug logging for first few strikes
    if (strike >= 107000 && strike <= 109000 && !matchingMarket) {
      console.log(`No market found for strike ${strike}. Available strikes in range:`, latestKalshiMarkets.filter(m => m.floor_strike >= 107000 && m.floor_strike <= 109000).map(m => Math.round(m.floor_strike)));
    }
    
    // Extract the corresponding ticker value from the same matchingMarket object
    const ticker = matchingMarket ? matchingMarket.ticker : null;
    const yesAsk = matchingMarket && typeof matchingMarket.yes_ask === "number" ? Math.round(matchingMarket.yes_ask) : 0;
    const noAsk = matchingMarket && typeof matchingMarket.no_ask === "number" ? Math.round(matchingMarket.no_ask) : 0;

    const isYesActive = yesAsk > noAsk && yesAsk < 99 && yesAsk >= 40;
    const isNoActive = noAsk > yesAsk && noAsk < 99 && noAsk >= 40;

    updateYesNoButton(yesSpan, strike, "yes", yesAsk, isYesActive, ticker);
    updateYesNoButton(noSpan, strike, "no", noAsk, isNoActive, ticker);
    
    // Update position indicator (subtle background tint)
    updatePositionIndicator(cells.row.children[0], strike);
  });
  
  // Update momentum heat band
  updateMomentumHeatBandSegmented();
  // Also update the watchlist to keep it in sync with the strike table
  updateWatchlistDisplay();
}

// Function to update momentum heat band
function updateMomentumHeatBandSegmented() {
  const momentumScore = getCurrentMomentumScore();
  const heatBand = document.getElementById('momentum-heat-gradient');
  const strikeTable = document.getElementById('strike-table');
  if (!heatBand || !strikeTable) return;

  // Parse momentum score
  const score = typeof momentumScore === 'string' ? parseFloat(momentumScore) : momentumScore;
  if (isNaN(score)) {
    heatBand.innerHTML = '';
    heatBand.style.background = 'none';
    return;
  }

  // Get all strike rows
  const rows = strikeTable.querySelectorAll('tbody tr');
  if (!rows.length) return;

  // Find ATM row (the one with border highlight)
  let atmIndex = -1;
  rows.forEach((row, idx) => {
    if (row.children[0].style.borderTop && row.children[0].style.borderTop.includes('3px')) {
      atmIndex = idx;
    }
  });
  if (atmIndex === -1) atmIndex = Math.floor(rows.length / 2); // fallback

  // Clear previous
  heatBand.innerHTML = '';
  heatBand.style.display = 'flex';
  heatBand.style.flexDirection = 'column';
  heatBand.style.justifyContent = 'center';
  heatBand.style.background = 'none';
  heatBand.style.height = strikeTable.offsetHeight + 'px';

  // Always create the center neutral segment
  const centerSeg = document.createElement('div');
  centerSeg.style.flex = '1 1 0';
  centerSeg.style.width = '100%';
  centerSeg.style.margin = '0';
  centerSeg.style.padding = '0';
  centerSeg.style.background = 'rgba(120,120,120,0.3)';
  centerSeg.style.border = '1px solid rgba(120,120,120,0.5)';

  // If momentum is zero, only show the center segment
  if (score === 0) {
    // Fill above and below with empty space to keep center centered
    for (let i = 0; i < atmIndex; ++i) {
      const empty = document.createElement('div');
      empty.style.flex = '1 1 0';
      heatBand.appendChild(empty);
    }
    heatBand.appendChild(centerSeg);
    for (let i = atmIndex + 1; i < rows.length; ++i) {
      const empty = document.createElement('div');
      empty.style.flex = '1 1 0';
      heatBand.appendChild(empty);
    }
    return;
  }

  // Otherwise, build the heatmap
  // The length of the bars is proportional to |momentum| (maxes at Â±50)
  const maxMomentum = 50;
  const absScore = Math.min(Math.abs(score), maxMomentum);
  const barLength = Math.round((rows.length - 1) / 2 * (absScore / maxMomentum));

  // Helper to get color for a segment (gradient)
  function getGradientColor(baseColor, relIdx, totalLen, intensity) {
    // relIdx: 0 (closest to center) to totalLen-1 (farthest)
    // intensity: 0-1
    let alpha = 0.15 + 0.7 * ((relIdx + 1) / totalLen) * intensity;
    if (baseColor === 'green') return `rgba(69, 211, 74, ${alpha})`;
    if (baseColor === 'red') return `rgba(220, 53, 69, ${alpha})`;
    return 'rgba(120,120,120,0.18)';
  }

  // Build segments above (upwards from center)
  for (let i = 0; i < atmIndex; ++i) {
    const seg = document.createElement('div');
    seg.style.flex = '1 1 0';
    seg.style.width = '100%';
    seg.style.margin = '0';
    seg.style.padding = '0';
    // Only color if within barLength from center
    const relIdx = atmIndex - 1 - i;
    if (relIdx < barLength) {
      // For positive momentum: red up, negative: green up
      const color = score > 0 ? 'red' : 'green';
      seg.style.background = getGradientColor(color, relIdx, barLength, absScore / maxMomentum);
    }
    heatBand.appendChild(seg);
  }
  // Center
  heatBand.appendChild(centerSeg);
  // Build segments below (downwards from center)
  for (let i = atmIndex + 1; i < rows.length; ++i) {
    const seg = document.createElement('div');
    seg.style.flex = '1 1 0';
    seg.style.width = '100%';
    seg.style.margin = '0';
    seg.style.padding = '0';
    // Only color if within barLength from center
    const relIdx = i - (atmIndex + 1);
    if (relIdx < barLength) {
      // For positive momentum: green down, negative: red down
      const color = score > 0 ? 'green' : 'red';
      seg.style.background = getGradientColor(color, relIdx, barLength, absScore / maxMomentum);
    }
    heatBand.appendChild(seg);
  }
}

// Helper function to create gradient bars
function createGradientBar(container, direction, color, intensity, length) {
  const bar = document.createElement('div');
  bar.style.flex = `${length} 1 0`;
  bar.style.width = '100%';
  bar.style.margin = '0';
  bar.style.padding = '0';
  bar.style.position = 'relative';
  bar.style.overflow = 'hidden';
  
  // Create gradient effect
  const gradient = document.createElement('div');
  gradient.style.width = '100%';
  gradient.style.height = '100%';
  gradient.style.position = 'absolute';
  gradient.style.top = '0';
  gradient.style.left = '0';
  
  if (color === 'green') {
    gradient.style.background = `linear-gradient(${direction === 'down' ? 'to bottom' : 'to top'}, 
      rgba(69, 211, 74, ${0.2 + 0.4 * intensity}) 0%, 
      rgba(69, 211, 74, ${0.4 + 0.6 * intensity}) 50%, 
      rgba(69, 211, 74, ${0.6 + 0.4 * intensity}) 100%)`;
  } else {
    gradient.style.background = `linear-gradient(${direction === 'down' ? 'to bottom' : 'to top'}, 
      rgba(220, 53, 69, ${0.2 + 0.4 * intensity}) 0%, 
      rgba(220, 53, 69, ${0.4 + 0.6 * intensity}) 50%, 
      rgba(220, 53, 69, ${0.6 + 0.4 * intensity}) 100%)`;
  }
  
  bar.appendChild(gradient);
  container.appendChild(bar);
}

// Function to update position indicator
async function updatePositionIndicator(strikeCell, strike) {
  try {
    // Fetch active trades to check for positions at this strike
    const tradesRes = await fetch('/trades', { cache: 'no-store' });
    if (!tradesRes.ok) return;
    
    const trades = await tradesRes.json();
    const activeTrades = trades.filter(trade => 
      trade.status !== "closed" && 
      trade.status !== "expired"
    );
    
    // Check if any active trade has this strike
    const hasPosition = activeTrades.some(trade => {
      const tradeStrike = parseFloat(trade.strike.replace(/[^\d.-]/g, ''));
      return tradeStrike === strike;
    });
    
    // Update visual indicator
    if (hasPosition) {
      strikeCell.style.backgroundColor = '#1a2a1a'; // Very subtle green tint
      strikeCell.style.borderLeft = '3px solid #45d34a'; // Green left border
    } else {
      strikeCell.style.backgroundColor = '';
      strikeCell.style.borderLeft = '';
    }
  } catch (e) {
    console.error('Error updating position indicator:', e);
    strikeCell.style.backgroundColor = '';
    strikeCell.style.borderLeft = '';
  }
}

// --- Main periodic fetcher for strike table ---
async function fetchAndUpdate() {
  try {
    const [coreRes, marketsRes] = await Promise.all([fetch('/core'), fetch('/kalshi_market_snapshot')]);
    if (!coreRes.ok || !marketsRes.ok) return;
    const coreData = await coreRes.json();
    const marketsData = await marketsRes.json();
    const latestKalshiMarkets = Array.isArray(marketsData.markets) ? marketsData.markets : [];

    if (!strikeRowsMap.size) {
      const base = Math.round(coreData.btc_price / 250) * 250;
      initializeStrikeTable(base);
    }
    updateStrikeTable(coreData, latestKalshiMarkets);

    // --- PATCH: Force heat band height to match strike table ---
    setTimeout(() => {
      const strikeTable = document.getElementById('strike-table');
      const heatBand = document.getElementById('momentum-heat-band');
      if (strikeTable && heatBand) {
        heatBand.style.height = strikeTable.offsetHeight + 'px';
      }
      updateMomentumHeatBandSegmented(); // Always update after table render
    }, 0);

    // Check if ATM strike has drifted more than 2 rows from center
    const currentCenterStrike = Math.round(coreData.btc_price / 250) * 250;
    const strikeList = Array.from(strikeRowsMap.keys()).sort((a, b) => a - b);
    const centerIndex = Math.floor(strikeList.length / 2);
    const currentCenter = strikeList[centerIndex];

    const drift = currentCenterStrike - currentCenter;

    // If ATM strike is more than 2 rows from center (rows 5-9), shift table one row in that direction
    if (drift >= 500 || drift <= -500) {
      const newBase = currentCenter + (drift > 0 ? 250 : -250);
      initializeStrikeTable(newBase);
    }
  } catch (e) {
    console.error("Error fetching or updating strike table:", e);
  }
}

// setInterval(fetchAndUpdate, 1000); // Replaced by staggered polling below
document.addEventListener('DOMContentLoaded', fetchAndUpdate);

// === Market Title Raw Fetch and UI Update (NEW LOGIC) ===
// Global raw data holder for market title
window.CurrentMarketTitleRaw = "";

// Fetch the raw market title from backend
async function fetchMarketTitleRaw() {
  try {
    const res = await fetch('/market_title');
    const data = await res.json();
    window.CurrentMarketTitleRaw = data.title || "";
  } catch (e) {
    window.CurrentMarketTitleRaw = "";
    console.error("Error fetching market title:", e);
  }
}

// Update the strike panel market title display with formatting
function updateStrikePanelMarketTitle() {
  const cell = document.getElementById('strikePanelMarketTitleCell');
  if (!cell || !window.CurrentMarketTitleRaw) return;

  const timeMatch = window.CurrentMarketTitleRaw.match(/at\s(.*)\?/i);
  const timeStr = timeMatch ? timeMatch[1] : "";
  cell.textContent = `Bitcoin price today at ${timeStr}?`;
  cell.style.color = "white";
}

// Initial calls and interval
fetchMarketTitleRaw();
updateStrikePanelMarketTitle();
setInterval(fetchMarketTitleRaw, 5000);
setInterval(updateStrikePanelMarketTitle, 5000);


// TTC clock for strike panel right cell (NEW IMPLEMENTATION)
let cachedTTC = null;
let lastFetchTimestamp = 0;

function formatTTC(seconds) {
  if (seconds === null || seconds === undefined || isNaN(seconds)) {
    return '--:--';
  }
  const m = String(Math.floor(seconds / 60)).padStart(2, '0');
  const s = String(seconds % 60).padStart(2, '0');
  return `${m}:${s}`;
}

function updateClockDisplay() {
  const ttcEl = document.getElementById('strikePanelTTC');
  if (!ttcEl || cachedTTC === null) return;

  ttcEl.textContent = formatTTC(cachedTTC);

  ttcEl.style.backgroundColor = '';
  ttcEl.style.color = '';
  ttcEl.style.borderRadius = '';
  ttcEl.style.padding = '';

  if (cachedTTC >= 0 && cachedTTC <= 180) {
    ttcEl.style.backgroundColor = '#d2372b';
    ttcEl.style.color = '#fff';
    ttcEl.style.borderRadius = '6px';
    ttcEl.style.padding = '0 10px';
  } else if (cachedTTC <= 300) {
    ttcEl.style.backgroundColor = '#ffc107';
    ttcEl.style.color = '#fff';
    ttcEl.style.borderRadius = '6px';
    ttcEl.style.padding = '0 10px';
  } else if (cachedTTC <= 720) {
    ttcEl.style.backgroundColor = '#45d34a';
    ttcEl.style.color = '#fff';
    ttcEl.style.borderRadius = '6px';
    ttcEl.style.padding = '0 10px';
  } else if (cachedTTC <= 900) {
    ttcEl.style.backgroundColor = '#ffc107';
    ttcEl.style.color = '#fff';
    ttcEl.style.borderRadius = '6px';
    ttcEl.style.padding = '0 10px';
  }
}

async function fetchAndCacheTTC() {
  try {
    const res = await fetch('/core');
    const data = await res.json();
    cachedTTC = data.ttc_seconds;
    lastFetchTimestamp = Date.now();
  } catch {
    cachedTTC = null;
  }
}

setInterval(() => {
  if (cachedTTC !== null) {
    cachedTTC = Math.max(0, cachedTTC - 1);
  }
  updateClockDisplay();

  if (Date.now() - lastFetchTimestamp > 10000) {
    fetchAndCacheTTC();
  }
}, 1000);

fetchAndCacheTTC();

// === WATCHLIST FUNCTIONALITY ===
let watchlistData = [];
let ignoreWsUpdates = false; // Move to global scope

// Load watchlist from preferences on page load
async function loadWatchlistFromPreferences() {
  try {
    const response = await fetch('/api/get_watchlist');
    const data = await response.json();
    watchlistData = data.watchlist || [];
    console.log('Loaded watchlist from preferences:', watchlistData);
    updateWatchlistDisplay();
  } catch (error) {
    console.error('Error loading watchlist from preferences:', error);
  }
}

// Save watchlist to preferences
async function saveWatchlistToPreferences() {
  console.log('saveWatchlistToPreferences called with watchlistData:', watchlistData);
  console.log('ignoreWsUpdates:', ignoreWsUpdates);
  if (ignoreWsUpdates) {
    console.log('Skipping save due to ignoreWsUpdates flag');
    return;
  }
  try {
    console.log('Saving watchlist to preferences:', watchlistData);
    const response = await fetch('/api/set_watchlist', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ watchlist: watchlistData })
    });
    console.log('Save response status:', response.status);
    if (!response.ok) {
      console.error('Save failed with status:', response.status);
    } else {
      console.log('Watchlist saved successfully');
    }
  } catch (error) {
    console.error('Error saving watchlist to preferences:', error);
  }
}

function addToWatchlist(strikeRow) {
  console.log('addToWatchlist called with strikeRow:', strikeRow);
  const strike = parseFloat(strikeRow.children[0].textContent.replace(/[\$,]/g, ''));
  console.log('Parsed strike value:', strike);
  if (watchlistData.includes(strike)) {
    console.log('Strike already in watchlist, skipping');
    return; // Already in watchlist
  }
  console.log('Adding strike to watchlistData');
  watchlistData.push(strike);
  console.log('Updated watchlistData:', watchlistData);
  updateWatchlistDisplay();
  saveWatchlistToPreferences();
}

function removeFromWatchlist(strike) {
  watchlistData = watchlistData.filter(item => item !== strike);
  updateWatchlistDisplay();
  saveWatchlistToPreferences();
}

// Function to update the watchlist display
function updateWatchlistDisplay() {
  const watchlistBody = document.getElementById('watchlist-body');
  if (!watchlistBody) return;
  const strikeTable = document.getElementById('strike-table');
  if (!strikeTable) return;
  const strikeRows = Array.from(strikeTable.querySelectorAll('tbody tr'));

  // Build a map of strike value to strike table row
  const strikeRowMap = new Map();
  strikeRows.forEach(row => {
    const cell = row.querySelector('td');
    if (!cell) return;
    const cellStrike = parseFloat(cell.textContent.replace(/[\$,]/g, ''));
    strikeRowMap.set(cellStrike, row);
  });

  // Remove rows for strikes no longer in watchlist
  Array.from(watchlistBody.children).forEach(row => {
    const strike = parseFloat(row.children[0].textContent.replace(/[\$,]/g, ''));
    if (!watchlistData.includes(strike)) {
      watchlistBody.removeChild(row);
    }
  });

  // Add or update rows for each watched strike (don't clear innerHTML)
  watchlistData.sort((a, b) => a - b);
  
  // Create a set of existing strikes in the watchlist for quick lookup
  const existingStrikes = new Set();
  Array.from(watchlistBody.children).forEach(row => {
    const strike = parseFloat(row.children[0].textContent.replace(/[\$,]/g, ''));
    existingStrikes.add(strike);
  });
  
  watchlistData.forEach(strike => {
    const marketRow = strikeRowMap.get(strike);
    if (!marketRow) return;
    
    let row = Array.from(watchlistBody.children).find(r => {
      return parseFloat(r.children[0].textContent.replace(/[\$,]/g, '')) === strike;
    });
    
    if (!row) {
      // Create new row only if it doesn't exist
      row = document.createElement('tr');
      row.className = marketRow.className + ' watchlist-row';
      Array.from(marketRow.children).forEach((cell, cellIndex) => {
        const newCell = cell.cloneNode(true);
        if (cellIndex === 0) {
          newCell.style.cursor = 'pointer';
          newCell.title = 'Click to remove from watchlist';
          newCell.onclick = () => removeFromWatchlist(strike);
        } else {
          newCell.style.cursor = '';
          newCell.title = '';
        }
        row.appendChild(newCell);
      });
      watchlistBody.appendChild(row);
    } else {
      // Update existing row class to match market row
      row.className = marketRow.className + ' watchlist-row';
    }
    
    // Remove ATM border highlight from all cells in the watchlist row (force clear)
    Array.from(row.children).forEach(cell => {
      cell.style.borderTop = '';
      cell.style.borderBottom = '';
    });
    
    // Update YES/NO buttons in place
    [5, 6].forEach(idx => {
      const marketCell = marketRow.children[idx];
      const watchCell = row.children[idx];
      if (!marketCell || !watchCell) return;
      const marketSpan = marketCell.querySelector('span');
      let askPrice = marketSpan ? marketSpan.textContent : '';
      let isActive = marketSpan ? !marketSpan.classList.contains('disabled') : false;
      let ticker = marketSpan ? marketSpan.getAttribute('data-ticker') : null;
      const strikeValue = strike;
      const side = idx === 5 ? 'yes' : 'no';
      let watchSpan = watchCell.querySelector('span');
      if (!watchSpan) {
        watchSpan = document.createElement('span');
        watchCell.appendChild(watchSpan);
      }
      updateYesNoButton(watchSpan, strikeValue, side, askPrice, isActive, ticker);
    });
  });
}

// Function to add click handlers to strike table rows
function addStrikeTableClickHandlers() {
  const strikeTable = document.getElementById('strike-table');
  if (!strikeTable) return;
  
  const rows = strikeTable.querySelectorAll('tbody tr');
  rows.forEach(row => {
    // Remove existing click handlers first
    row.removeEventListener('click', row._watchlistClickHandler);
    
    // Check if RECO is enabled - if so, don't add click handlers
    if (window.recoEnabled) {
      row.style.cursor = 'default';
      row.title = 'RECO mode - manual selection disabled';
      Array.from(row.children).forEach((cell, idx) => {
        if (idx >= 0 && idx <= 4) {
          cell.style.cursor = 'default';
          cell.title = 'RECO mode - manual selection disabled';
        } else {
          cell.style.cursor = 'default';
          cell.title = '';
        }
      });
      return; // Skip adding click handlers when RECO is enabled
    }
    
    // RECO is disabled - add normal click handlers
    row.style.cursor = '';
    row.title = '';
    Array.from(row.children).forEach((cell, idx) => {
      if (idx >= 0 && idx <= 4) {
        cell.style.cursor = 'pointer';
        cell.title = 'Click to add to watchlist';
      } else {
        cell.style.cursor = 'default';
        cell.title = '';
      }
    });
    
    const clickHandler = (event) => {
      // Only trigger if not clicking on YES or NO columns (6 or 7)
      const cell = event.target.closest('td');
      if (!cell) return;
      const cellIndex = Array.from(row.children).indexOf(cell);
      if (cellIndex === 5 || cellIndex === 6) return; // YES or NO columns
      addToWatchlist(row);
    };
    
    row._watchlistClickHandler = clickHandler;
    row.addEventListener('click', clickHandler);
  });
}

// Initialize watchlist functionality
document.addEventListener('DOMContentLoaded', () => {
  // Load watchlist from preferences on page load
  loadWatchlistFromPreferences();
  
  // Add click handlers to existing strike table rows
  addStrikeTableClickHandlers();
  
  // Also add handlers when strike table is updated
  const originalUpdateStrikeTable = window.updateStrikeTable;
  if (originalUpdateStrikeTable) {
    window.updateStrikeTable = function(...args) {
      originalUpdateStrikeTable.apply(this, args);
      setTimeout(() => {
        addStrikeTableClickHandlers();
        updateWatchlistDisplay(); // Update watchlist after strike table updates
        updateWatchlistBasedOnReco(); // Apply RECO filtering if enabled
        updateClickHandlersForReco(); // Update click handlers based on RECO state
      }, 100); // Small delay to ensure rows are rendered
    };
  }
});

// Function to apply RECO filtering criteria
function applyRecoFilter(strikeRows) {
  if (!window.recoEnabled) return []; // Return empty if RECO is off
  
  const filteredStrikes = [];
  
  strikeRows.forEach(row => {
    const cells = Array.from(row.children);
    if (cells.length < 7) return; // Need at least 7 columns
    
    // Get Adj B/M value (column 3, index 3)
    const adjBmCell = cells[3];
    const adjBmText = adjBmCell ? adjBmCell.textContent.trim() : '';
    const adjBm = parseFloat(adjBmText.replace(/[^\d.-]/g, '')) || 0;
    
    // Get YES and NO prices (columns 5 and 6, indices 5 and 6)
    const yesCell = cells[5];
    const noCell = cells[6];
    
    let yesPrice = 0;
    let noPrice = 0;
    let yesActive = false;
    let noActive = false;
    
    if (yesCell) {
      const yesSpan = yesCell.querySelector('span');
      if (yesSpan && !yesSpan.classList.contains('disabled')) {
        yesPrice = parseFloat(yesSpan.textContent) || 0;
        yesActive = true;
      }
    }
    
    if (noCell) {
      const noSpan = noCell.querySelector('span');
      if (noSpan && !noSpan.classList.contains('disabled')) {
        noPrice = parseFloat(noSpan.textContent) || 0;
        noActive = true;
      }
    }
    
    // Get the higher of the two active prices
    const activePrice = Math.max(yesActive ? yesPrice : 0, noActive ? noPrice : 0);
    
    // Apply RECO criteria: Adj B/M > 25 AND active price â‰¤ 97
    if (adjBm > 25 && activePrice <= 97 && activePrice > 0) {
      // Get strike value from first column
      const strikeCell = cells[0];
      const strikeText = strikeCell ? strikeCell.textContent.trim() : '';
      const strike = parseFloat(strikeText.replace(/[\$,]/g, '')) || 0;
      
      if (strike > 0) {
        filteredStrikes.push(strike);
      }
    }
  });
  
  console.log('RECO filter applied. Found', filteredStrikes.length, 'strikes meeting criteria');
  return filteredStrikes;
}

// Function to update watchlist based on RECO state
function updateWatchlistBasedOnReco() {
  console.log('updateWatchlistBasedOnReco called, RECO enabled:', window.recoEnabled);
  
  if (window.recoEnabled) {
    // RECO is ON - apply automatic filtering
    console.log('Applying RECO filtering...');
    const strikeTable = document.getElementById('strike-table');
    if (!strikeTable) return;
    
    const strikeRows = Array.from(strikeTable.querySelectorAll('tbody tr'));
    const filteredStrikes = applyRecoFilter(strikeRows);
    
    // Update watchlist with filtered strikes
    watchlistData = filteredStrikes;
    updateWatchlistDisplay();
    saveWatchlistToPreferences();
  } else {
    // RECO is OFF - do absolutely nothing, don't touch the watchlist
    console.log('RECO is OFF - leaving manual watchlist alone');
  }
}

// Function to enable/disable click handlers based on RECO state
function updateClickHandlersForReco() {
  // Simply call addStrikeTableClickHandlers which now handles RECO state
  addStrikeTableClickHandlers();
}

</script>

</div>

    <div class="column" id="col3" style="padding-right: 0px;">
      <div class="panel-container" style="height: 50px; min-height: 50px; max-height: 50px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
          <select id="account-selector" class="dropdown-picker">
            <option value="live">eric@ewedit.com</option>
            <option value="demo">eric@ewedit.com DEMO</option>
          </select>
          <span id="account-status" style="font-weight: bold; color: #00ff00; margin-left: 10px;"></span>
        </div>
        <div style="display: flex; flex-direction: column; align-items: flex-end;">
          <span style="font-size: 11px; color: #ccc; font-weight: normal; margin-bottom: 0px;">Balance</span>
          <span id="account-balance" style="font-weight: bold; color: white; font-size: 14px;">Loading...</span>
        </div>
      </div>
      <div class="panel-container" id="buildTrade" style="min-height: 300px;">
        <div class="panel-header">Trade Builder</div>
        <div style="font-weight: bold; margin-bottom: 6px; font-size: 0.9rem;">Position Size</div>
        <div id="positionSizeSelector" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <input type="number" id="position-size" min="1" style="width: 60px; padding: 6px; text-align: right; font-size: 1rem; border-radius: 4px; border: 1px solid #ccc;" />
          <div>
            <button class="multiplier-btn" data-multiplier="1">1x</button>
            <button class="multiplier-btn" data-multiplier="2">2x</button>
            <button class="multiplier-btn" data-multiplier="3">3x</button>
          </div>
        </div>
        <div id="position-display" style="font-size: 0.85rem; font-weight: normal; color: #ccc;">100 contracts</div>
      </div>
  <script>
    // Sync the mode picker with the global mode on load
    async function syncModePickerWithGlobal() {
        const res = await fetch("/api/get_account_mode");
        const data = await res.json();
        const modePicker = document.getElementById("accountModePicker");
        if (modePicker) {
            modePicker.value = data.mode;
        }
    }
    // Call this on load
    syncModePickerWithGlobal();

    // If the mode picker changes, update the backend global mode
    document.addEventListener('DOMContentLoaded', function() {
      const modePicker = document.getElementById("accountModePicker");
      if (modePicker) {
        modePicker.addEventListener("change", function() {
          const mode = modePicker.value;
          fetch('/api/set_account_mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode })
          }).catch(console.error);
        });
      }
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Initial load of active trades
      fetchAndRenderTrades();
      // TODO: Replace polling with real-time file change triggers or push-based updates
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      fetch('/api/get_account_mode')
        .then(res => res.json())
        .then(data => {
          const mode = data.mode;
          const selector = document.getElementById("account-selector");
          const statusEl = document.getElementById("account-status");
          selector.value = mode === 'prod' ? 'live' : 'demo';
          if (mode === 'prod') {
            statusEl.textContent = "LIVE TRADING";
            statusEl.style.color = "#00ff00";
          } else {
            statusEl.textContent = "Paper Trading";
            statusEl.style.color = "orange";
          }
          
          // Fetch and update account balance
          updateAccountBalance(mode);
        });

      document.getElementById("account-selector").addEventListener("change", () => {
        const selected = document.getElementById("account-selector").value;
        const statusEl = document.getElementById("account-status");
        const mode = selected === "live" ? "prod" : "demo";
        if (mode === "prod") {
          statusEl.textContent = "LIVE TRADING";
          statusEl.style.color = "#00ff00";
        } else {
          statusEl.textContent = "Paper Trading";
          statusEl.style.color = "orange";
        }
        fetch('/api/set_account_mode', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode })
        }).catch(console.error);
        
        // Update balance when account mode changes
        updateAccountBalance(mode);
      });
    });
    
    // Function to fetch and update account balance
    async function updateAccountBalance(mode) {
      try {
        const response = await fetch(`/api/account/balance?mode=${mode}`);
        const data = await response.json();
        const balanceEl = document.getElementById("account-balance");
        if (balanceEl) {
          const balance = data.balance || 0;
          balanceEl.textContent = `$${Number(balance).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
        }
      } catch (error) {
        console.error('Error fetching account balance:', error);
        const balanceEl = document.getElementById("account-balance");
        if (balanceEl) {
          balanceEl.textContent = "Error";
        }
      }
    }
    
    // Update balance every 30 seconds
    setInterval(() => {
      const selector = document.getElementById("account-selector");
      if (selector) {
        const mode = selector.value === "live" ? "prod" : "demo";
        updateAccountBalance(mode);
      }
    }, 30000);
  </script>
</body>
  <div id="errorTooltip" class="error-tooltip"></div>
<script>
// === Unified Preferences: AUTO STOP, Position Size, Multiplier with WebSocket sync (improved) ===
document.addEventListener('DOMContentLoaded', () => {
  const autoStopToggle = document.getElementById('autoStopToggle');
  const positionInput = document.getElementById('position-size');
  const multiplierButtons = document.querySelectorAll('.multiplier-btn');
  const recoToggle = document.getElementById('recoToggle');
  let currentMultiplier = null;
  // Remove: let ignoreWsUpdates = false; (now global)

  function updatePositionDisplay() {
    const baseValue = parseInt(positionInput.value, 10) || 0;
    const total = baseValue * (currentMultiplier || 1);
    const positionDisplay = document.getElementById('position-display');
    if (positionDisplay) {
      positionDisplay.textContent = `${total} contracts`;
    }
  }

  // Initial preferences fetch and UI setup
  fetch(window.location.origin + '/api/get_preferences')
    .then(res => res.json())
    .then(data => {
      if (autoStopToggle && data.auto_stop !== undefined) {
        autoStopToggle.checked = data.auto_stop;
        window.autoStopEnabled = data.auto_stop;
      }
      if (recoToggle && data.reco !== undefined) {
        recoToggle.checked = data.reco;
        window.recoEnabled = data.reco;
        
        // If RECO is enabled on initial load, apply filtering
        if (data.reco) {
          console.log('RECO enabled on initial load - applying automatic filtering');
          setTimeout(() => {
            updateWatchlistBasedOnReco();
            updateClickHandlersForReco(); // Disable click handlers
          }, 1000); // Delay to ensure strike table is loaded
        } else {
          // If RECO is disabled on initial load, enable click handlers
          setTimeout(() => {
            updateClickHandlersForReco(); // Enable click handlers
          }, 1000); // Delay to ensure strike table is loaded
        }
      }
      if (positionInput && data.position_size !== undefined) {
        positionInput.value = data.position_size;
      }
      if (multiplierButtons.length && data.multiplier !== undefined) {
        currentMultiplier = data.multiplier;
        multiplierButtons.forEach(btn => {
          if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      updatePositionDisplay();
      
      // Load watchlist from preferences
      if (data.watchlist !== undefined) {
        watchlistData = data.watchlist;
        // Update watchlist display after a short delay to ensure strike table is built
        setTimeout(() => {
          updateWatchlistDisplay();
        }, 500);
      }
    });

  // WebSocket setup
  const ws = new WebSocket(`ws://${window.location.host}/ws/preferences`);

  ws.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      console.log('WebSocket message received:', data);

      // === Account Mode Sync ===
      if (data.account_mode) {
        const selector = document.getElementById("account-selector");
        const statusEl = document.getElementById("account-status");
        if (selector && statusEl) {
          selector.value = data.account_mode === "prod" ? "live" : "demo";
          statusEl.textContent = data.account_mode === "prod" ? "LIVE TRADING" : "Paper Trading";
          statusEl.style.color = data.account_mode === "prod" ? "#00ff00" : "orange";
        }
      }

      // === Watchlist Sync ===
      if (data.watchlist !== undefined) {
        ignoreWsUpdates = true;
        console.log('Received watchlist update via WebSocket:', data.watchlist);
        watchlistData = data.watchlist || [];
        updateWatchlistDisplay();
        ignoreWsUpdates = false;
      }

      // Only update UI if not focused to avoid overwriting user input
      if (autoStopToggle && data.auto_stop !== undefined && document.activeElement !== autoStopToggle) {
        ignoreWsUpdates = true;
        autoStopToggle.checked = data.auto_stop;
        window.autoStopEnabled = data.auto_stop;
        ignoreWsUpdates = false;
      }

      if (recoToggle && data.reco !== undefined && document.activeElement !== recoToggle) {
        ignoreWsUpdates = true;
        console.log('Received RECO update via WebSocket:', data.reco);
        recoToggle.checked = data.reco;
        window.recoEnabled = data.reco;
        
        // If RECO is being turned ON, apply filtering immediately
        if (data.reco) {
          console.log('RECO enabled - applying automatic filtering');
          updateWatchlistBasedOnReco();
          updateClickHandlersForReco(); // Disable click handlers
        } else {
          // If RECO is being turned OFF, re-enable click handlers
          console.log('RECO disabled - re-enabling click handlers');
          updateClickHandlersForReco(); // Re-enable click handlers
        }
        
        ignoreWsUpdates = false;
      }

      if (positionInput && data.position_size !== undefined && document.activeElement !== positionInput) {
        ignoreWsUpdates = true;
        positionInput.value = data.position_size;
        ignoreWsUpdates = false;
      }

      if (multiplierButtons.length && data.multiplier !== undefined && currentMultiplier !== data.multiplier) {
        ignoreWsUpdates = true;
        currentMultiplier = data.multiplier;
        multiplierButtons.forEach(btn => {
          if (parseInt(btn.dataset.multiplier, 10) === data.multiplier) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        ignoreWsUpdates = false;
      }

      updatePositionDisplay();
    } catch (e) {
      console.error('Error parsing preferences WebSocket message:', e);
    }
  };

  // Save handlers, ignoring changes triggered by WebSocket updates
  if (autoStopToggle) {
    autoStopToggle.addEventListener('change', () => {
      if (ignoreWsUpdates) return;
      const value = autoStopToggle.checked;
      window.autoStopEnabled = value;
      fetch(window.location.origin + '/api/set_auto_stop', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      });
    });
  }

  if (recoToggle) {
    recoToggle.addEventListener('change', () => {
      if (ignoreWsUpdates) return;
      const value = recoToggle.checked;
      console.log('RECO toggle changed to:', value);
      window.recoEnabled = value;
      
      // If RECO is being turned ON, apply filtering immediately
      if (value) {
        console.log('RECO enabled - applying automatic filtering');
        updateWatchlistBasedOnReco();
        updateClickHandlersForReco(); // Disable click handlers
      } else {
        // If RECO is being turned OFF, re-enable click handlers
        console.log('RECO disabled - re-enabling click handlers');
        updateClickHandlersForReco(); // Re-enable click handlers
      }
      
      fetch(window.location.origin + '/api/set_reco', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ enabled: value })
      });
    });
  }

  if (positionInput) {
    positionInput.addEventListener('change', () => {
      if (ignoreWsUpdates) return;
      const value = parseInt(positionInput.value, 10) || 100;
      fetch(window.location.origin + '/api/set_position_size', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ position_size: value })
      });
      updatePositionDisplay();
    });
  }

  multiplierButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      if (ignoreWsUpdates) return;
      multiplierButtons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentMultiplier = parseInt(btn.dataset.multiplier, 10);
      updatePositionDisplay();
      fetch(window.location.origin + '/api/set_multiplier', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ multiplier: currentMultiplier })
      });
    });
  });

});
</script>
      <div class="panel-container" style="min-height: 319px;" id="activeTradesPanel">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
          <span>Active Trades</span>
          <label style="font-size: 12px; user-select: none; color: white; display: flex; align-items: center; gap: 6px; margin: 0;">
            AUTO STOP
            <input type="checkbox" id="autoStopToggle" />
          </label>
        </div>
        <table id="activeTradesTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th>Strike</th>
              <th>Side</th>
              <th>Buy</th>
              <th>Pos</th>
              <th>Buffer</th>
              <th>B/M</th>
              <th style="text-align: center;">Close</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <!-- Recent Trades Panel -->
      <div class="panel-container" style="min-height: 100px;" id="recentTradesPanel">
        <div class="panel-header">Recent Trades</div>
        <table id="recentTradesTable" class="panel-table" style="width: 100%; border-collapse: collapse;">
          <thead>
            <tr>
              <th>Time</th>
              <th>Contract</th>
              <th>Strike</th>
              <th>Side</th>
              <th>Buy</th>
              <th>Sell</th>
              <th>Pos</th>
              <th>Closed</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
   
  
  <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
  <script type="text/javascript">
    new TradingView.widget({
      "width": "100%",
      "height": "300",
      "symbol": "COINBASE:BTCUSD",
      "interval": "1",
      "timezone": "Etc/UTC",
      "theme": "dark",
      "style": "1",
      "locale": "en",
      "toolbar_bg": "#f1f3f6",
      "scalesProperties.textColor": "#FFFFFF",
      "backgroundColor": "#1e2733",
      "enable_publishing": false,
      "hide_top_toolbar": true,
      "hide_legend": true,
      "save_image": false,
      "disabled_features": ["volume_force_overlay", "create_volume_indicator_by_default"],
      "studies": [],
      "container_id": "tradingview_12345"
    });
  </script>

  <script>
    window.momentumData = {
      deltas: {
        '1m': null,
        '2m': null,
        '3m': null,
        '4m': null,
        '15m': null,
        '30m': null,
      },
      weightedScore: null,
    };

    function formatNumber(val, addPercent) {
      if (val === null || val === undefined || isNaN(val)) return 'â€”';
      const prefix = val >= 0 ? '+' : '';
      return prefix + (val * 100).toFixed(0) + (addPercent ? '%' : '');
    }

    // Global variable to store momentum_delta for use elsewhere
    window.momentum_delta = 0;

    function updateMomentumPanel() {
      const { deltas, weightedScore } = window.momentumData;

      // Ensure rollingScores array exists
      if (!window.momentumData.rollingScores) {
        window.momentumData.rollingScores = [];
      }

      const momentumScoreEl = document.getElementById('momentum-score-value');
      if (momentumScoreEl) {
        momentumScoreEl.textContent = formatNumber(weightedScore, false);
      }

      // After updating the display, append weightedScore to rollingScores and trim to 40
      if (typeof weightedScore === "number" && !isNaN(weightedScore)) {
        window.momentumData.rollingScores.push(weightedScore);
        if (window.momentumData.rollingScores.length > 40) {
          window.momentumData.rollingScores = window.momentumData.rollingScores.slice(-40);
        }
      }

      // --- Calculate momentum_delta using "momentum of momentum" (second derivative) method ---
      // Maintain a longer history for delta calculation
      if (!window.momentumData.momentumScoreHistory) {
        window.momentumData.momentumScoreHistory = [];
      }
      if (typeof weightedScore === "number" && !isNaN(weightedScore)) {
        window.momentumData.momentumScoreHistory.push(weightedScore);
        // Keep at most 120 points
        if (window.momentumData.momentumScoreHistory.length > 120) {
          window.momentumData.momentumScoreHistory = window.momentumData.momentumScoreHistory.slice(-120);
        }
      }
      // momentum_delta and indicator display removed from UI

      Object.entries(deltas).forEach(([key, val]) => {
        const el = document.getElementById(`delta-${key}`);
        if (el) el.textContent = formatNumber(val, false);
      });

      renderMomentumBarChart(deltas);
      drawRollingMomentumChart();
    }

    // Chart.js-based momentum bar chart (flicker-free: update data in place)
    let momentumBarChart = null;
    function renderMomentumBarChart(deltas) {
      const ctx = document.getElementById('momentumBarChartCanvas').getContext('2d');
      const keys = ['4m', '3m', '2m', '1m'];
      const values = keys.map(k => deltas[k] * 100);
      const bgColors = values.map(v => v >= 0 ? 'rgba(40,167,69,0.7)' : 'rgba(220,53,69,0.7)');

      if (!momentumBarChart) {
        // Initial render
        momentumBarChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: keys,
            datasets: [{
              data: values,
              backgroundColor: bgColors,
            }]
          },
          options: {
            responsive: true,
            animation: false,
            scales: {
              y: {
                min: -50,
                max: 50,
                ticks: { color: '#fff' },
                grid: { color: '#444' }
              },
              x: {
                ticks: { color: '#fff' },
                grid: { color: '#444' }
              }
            },
            plugins: { legend: { display: false } }
          }
        });
      } else {
        // Just update the data
        momentumBarChart.data.datasets[0].data = values;
        momentumBarChart.data.datasets[0].backgroundColor = bgColors;
        momentumBarChart.update();
      }
    }

    function fetchCore() {
      fetch('/core')
        .then(response => response.json())
        .then(data => {
          window.momentumData.deltas['1m'] = data.delta_1m;
          window.momentumData.deltas['2m'] = data.delta_2m;
          window.momentumData.deltas['3m'] = data.delta_3m;
          window.momentumData.deltas['4m'] = data.delta_4m;
          window.momentumData.deltas['15m'] = data.delta_15m;
          window.momentumData.deltas['30m'] = data.delta_30m;

          window.momentumData.weightedScore = (
            window.momentumData.deltas['1m'] * 0.3 +
            window.momentumData.deltas['2m'] * 0.25 +
            window.momentumData.deltas['3m'] * 0.2 +
            window.momentumData.deltas['4m'] * 0.15 +
            window.momentumData.deltas['15m'] * 0.05 +
            window.momentumData.deltas['30m'] * 0.05
          );

          updateMomentumPanel();
        })
        .catch(console.error);
    }

    fetchCore();
    // setInterval(fetchCore, 1000); // Replaced by staggered polling below

    // Draw rolling momentum chart in the third table
    function drawRollingMomentumChart() {
      const canvas = document.getElementById('rolling-momentum-chart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      // Margins/layout
      const margin = { top: 20, right: 20, bottom: 40, left: 40 };
      const chartWidth = width - margin.left - margin.right;
      const chartHeight = height - margin.top - margin.bottom;

      // Draw vertical axis line at 40px from the left
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(margin.left, margin.top);
      ctx.lineTo(margin.left, height - margin.bottom);
      ctx.stroke();

      // Y-axis scale: -50 (bottom) to 50 (top)
      const yMin = -50;
      const yMax = 50;
      function yForValue(v) {
        // Map v in [yMin, yMax] to [chartHeight+margin.top, margin.top]
        const y = margin.top + ((yMax - v) / (yMax - yMin)) * chartHeight;
        return y;
      }

      // Draw tick marks and labels for -50, -25, 0, 25, 50 (vertical axis)
      ctx.font = '11px monospace';
      ctx.fillStyle = '#ccc';
      ctx.textAlign = 'right';
      const ticks = [-50, -25, 0, 25, 50];
      ticks.forEach(tick => {
        const y = yForValue(tick);
        // Draw tick mark
        ctx.strokeStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(margin.left - 8, y);
        ctx.lineTo(margin.left, y);
        ctx.stroke();
        // Draw label
        ctx.fillText(tick.toString(), margin.left - 12, y + 4);
      });

      // Draw horizontal zero line
      const zeroY = yForValue(0);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(margin.left, zeroY);
      ctx.lineTo(width - margin.right, zeroY);
      ctx.stroke();

      // === Draw horizontal axis line, ticks, and labels ===
      // Axis line near bottom margin
      const axisY = height - margin.bottom + 5;
      ctx.strokeStyle = '#aaa';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(margin.left, axisY);
      ctx.lineTo(width - margin.right, axisY);
      ctx.stroke();

      // Decide number of ticks based on chart width: about 5-6
      const approxTicks = Math.max(5, Math.min(6, Math.round(chartWidth / 60)));
      const nTicks = approxTicks;
      // For minute labels, use 0 to (nTicks-1)
      ctx.font = '11px monospace';
      ctx.fillStyle = '#ccc';
      ctx.textAlign = 'center';
      const tickHeight = 5;
      const labelOffset = 15;
      const labels = ['4m', '3m', '2m', '1m', '0m'];
      for (let i = 0; i < nTicks; ++i) {
        const x = margin.left + (i * chartWidth) / (nTicks - 1);
        // Draw tick mark
        ctx.strokeStyle = '#aaa';
        ctx.beginPath();
        ctx.moveTo(x, axisY);
        ctx.lineTo(x, axisY + tickHeight);
        ctx.stroke();
        // Draw label with custom time labels
        const label = labels[i] || '';
        ctx.fillText(label, x, axisY + tickHeight + 25);
      }

      // === End horizontal axis and ticks ===

      // Plot the momentum score points scaled accordingly
      // Use history from window.momentumData.rollingScores or fallback to last 40 weightedScore values
      let points = [];
      if (window.momentumData.rollingScores && Array.isArray(window.momentumData.rollingScores)) {
        points = window.momentumData.rollingScores.slice(-40);
      } else if (typeof window.momentumData.weightedScore === 'number') {
        points = Array(40).fill(window.momentumData.weightedScore);
      }
      // Multiply all points by 100 for display in -50..50 range
      points = points.map(v => (v === null || v === undefined || isNaN(v) ? null : v * 100));
      // Do NOT reverse the points array; keep natural order (oldest to newest, left to right).
      // If not enough points, pad with nulls
      if (points.length < 2) {
        // Not enough data to plot
        return;
      }
      // X scale
      const n = points.length;
      const xStep = n > 1 ? chartWidth / (n - 1) : 0;
      // Helper to get point at index i (returns {x, y})
      function getPoint(i) {
        const v = points[i];
        return {
          x: margin.left + i * xStep,
          y: yForValue(v)
        };
      }
      // Smoothing factor (0.2-0.4 is typical)
      const smooth = 0.2;
      // Find valid indices (skip nulls/NaNs)
      let validIndices = [];
      for (let i = 0; i < n; ++i) {
        const v = points[i];
        if (v !== null && v !== undefined && !isNaN(v)) {
          validIndices.push(i);
        }
      }
      if (validIndices.length < 2) return;

      // Helper: map a value in [-40, 40] to a color gradient (red for negative, green for positive)
      function colorForValue(val) {
        // Clamp value to [-40, 40]
        val = Math.max(-40, Math.min(40, val));
        // Map negative: -40 (deep red) to 0 (light red)
        // Map positive: 0 (light green) to 40 (deep green)
        if (val < 0) {
          // Red: from #ffb3b3 (light) to #dc3545 (deep)
          // Interpolate between (255,179,179) and (220,53,69)
          const t = (val + 40) / 40; // 0 at -40, 1 at 0
          const r = Math.round(220 * (1 - t) + 255 * t);
          const g = Math.round(53 * (1 - t) + 179 * t);
          const b = Math.round(69 * (1 - t) + 179 * t);
          return `rgb(${r},${g},${b})`;
        } else {
          // Green: from #b3ffb3 (light) to #28a745 (deep)
          // Interpolate between (179,255,179) and (40,167,69)
          const t = val / 40; // 0 at 0, 1 at 40
          const r = Math.round(179 * (1 - t) + 40 * t);
          const g = Math.round(255 * (1 - t) + 167 * t);
          const b = Math.round(179 * (1 - t) + 69 * t);
          return `rgb(${r},${g},${b})`;
        }
      }

      // Draw smooth line using cubic BÃ©zier curves, segment by segment with color
      for (let j = 1; j < validIndices.length; ++j) {
        const i0 = validIndices[j - 1];
        const i1 = validIndices[j];
        const v0 = points[i0];
        const v1 = points[i1];
        // Compute average value for color mapping
        const avgVal = (v0 + v1) / 2;
        ctx.strokeStyle = colorForValue(avgVal);
        ctx.lineWidth = 2;
        ctx.beginPath();
        const p0 = getPoint(i0);
        const p1 = getPoint(i1);
        // Previous/next indices for control points
        const iPrev = validIndices[j - 2] !== undefined ? validIndices[j - 2] : i0;
        const iNext = validIndices[j + 1] !== undefined ? validIndices[j + 1] : i1;
        const pPrev = getPoint(iPrev);
        const pNext = getPoint(iNext);
        // Calculate control points
        // cp1: from p0 toward pNext
        const dx1 = (p1.x - pPrev.x) * smooth;
        const dy1 = (p1.y - pPrev.y) * smooth;
        const cp1x = p0.x + dx1;
        const cp1y = p0.y + dy1;
        // cp2: from p1 back toward pPrev
        const dx2 = (pNext.x - p0.x) * -smooth;
        const dy2 = (pNext.y - p0.y) * -smooth;
        const cp2x = p1.x + dx2;
        const cp2y = p1.y + dy2;
        ctx.moveTo(p0.x, p0.y);
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p1.x, p1.y);
        ctx.stroke();
      }
      // Optionally: draw points as small circles
      // ctx.fillStyle = '#fff';
      // for (let i = 0; i < n; ++i) {
      //   const v = points[i];
      //   if (v === null || v === undefined || isNaN(v)) continue;
      //   const x = margin.left + i * xStep;
      //   const y = yForValue(v);
      //   ctx.beginPath();
      //   ctx.arc(x, y, 2, 0, 2 * Math.PI);
      //   ctx.fill();
      // }
    }
  </script>
  <script>

    // Helper function to format numbers as $XX,XXX.XX
    function formatUSD(val) {
      if (typeof val !== "number" || isNaN(val)) return "â€”";
      return "$" + val.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    }

    // Helper: decorate change cell with color and triangle
    function decorateChange(el, val) {
      const num = parseFloat(val);
      if (isNaN(num)) {
        el.textContent = "â€”";
        el.style.backgroundColor = "";
        el.style.color = "";
        return;
      }
      const triangle = num >= 0 ? " â–²" : " â–¼";
      el.textContent = `${Math.abs(num).toFixed(2)}%${triangle}`;
      el.style.color = "#fff";
      el.style.backgroundColor = num >= 0 ? "#28a745" : "#dc3545";
      el.style.padding = "2px 6px";
      el.style.borderRadius = "4px";
      el.style.display = "inline-block";
    }

    // Fetch BTC price changes from backend API and update ticker panel
    async function fetchBTCPriceChanges() {
      try {
        const res = await fetch('/btc_price_changes');
        if (!res.ok) throw new Error('Failed to fetch BTC price changes');
        const data = await res.json();
        if ('change_1h' in data) {
          const el = document.getElementById('change-1h');
          if (el) decorateChange(el, data.change_1h);
        }
        if ('change_3h' in data) {
          const el = document.getElementById('change-3h');
          if (el) decorateChange(el, data.change_3h);
        }
        if ('change_1d' in data) {
          const el = document.getElementById('change-1d');
          if (el) decorateChange(el, data.change_1d);
        }
      } catch (error) {
        console.error('Error fetching BTC price changes:', error);
      }
    }


    // === Momentum Chart (Chart.js) ===
    let momentumChart = null;
    let momentumHistory = [];
    function renderMomentumChart(history) {
      const ctx = document.getElementById('rolling-momentum-chart').getContext('2d');
      const color = history.length < 2 || history[history.length - 1] >= history[history.length - 2] ? '#00cc00' : '#cc0000';
      if (!momentumChart) {
        momentumChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: history.map(() => ''),
            datasets: [{
              label: '',
              data: history,
              borderColor: color,
              borderWidth: 1,
              pointRadius: 0,
              tension: 0.3,
              fill: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            plugins: { legend: { display: false } },
            scales: {
              x: { display: false },
              y: {
                min: -50,
                max: 50,
                ticks: { stepSize: 25, color: '#ccc' },
                grid: { color: '#444' }
              }
            }
          }
        });
      } else {
        momentumChart.data.labels = history.map(() => '');
        momentumChart.data.datasets[0].data = history;
        momentumChart.data.datasets[0].borderColor = color;
        momentumChart.update();
      }
    }


    // === Momentum Chart Duplicate (Chart.js) ===
    // (Poll for fills/positions/settlements/balance REMOVED below)

    // === Volatility Score History, Moving Average, Delta Globals ===
    window.volScoreHistory = [];
    window.volScoreMovingAvg = 0;
    window.volScoreDelta = 0;

    function fetchOtherCoreData() {
      fetch('/core')
        .then(response => response.json())
        .then(data => {
          // BTC price
          if ('btc_price' in data) {
            const price = Number(data.btc_price);
            const el = document.getElementById('btc-price-value');
            if (el) el.textContent = formatUSD(price);
          }
          // Volatility Score/Spike (format to 2 decimals)
          let prevMovingAvg = window.volScoreMovingAvg || 0;
          if ('volScore' in data) {
            const score = Number(data.volScore);
            const el = document.getElementById('volScore');
            if (el && !isNaN(score)) {
              el.textContent = score.toFixed(2);
              // --- Update volIndicator light color based on score, with conditional animation ---
              const volLight = document.getElementById("volLight");
              if (volLight) {
                if (score < 60) {
                  volLight.style.background = "radial-gradient(circle at 30% 30%, #00cc00, #006600)";
                  volLight.style.boxShadow = "0 0 4px #00cc00";
                } else if (score < 80) {
                  volLight.style.background = "radial-gradient(circle at 30% 30%, #cccc00, #999900)";
                  volLight.style.boxShadow = "0 0 4px #cccc00";
                } else {
                  volLight.style.background = "radial-gradient(circle at 30% 30%, red, #222c3c)";
                  volLight.style.boxShadow = "0 0 10px #cc0000";
                }
              }
            }
            // --- Volatility Score History, Moving Average, Delta ---
            window.volScoreHistory.push(score);
            if (window.volScoreHistory.length > 30) {
              window.volScoreHistory = window.volScoreHistory.slice(-30);
            }
            // Moving average over last 10 points
            let ma = 0;
            if (window.volScoreHistory.length > 0) {
              const last10 = window.volScoreHistory.slice(-10);
              ma = last10.reduce((a,b) => a + b, 0) / last10.length;
            }
            // Delta: current MA - previous MA
            let prev10 = window.volScoreHistory.length > 10
              ? window.volScoreHistory.slice(-11, -1)
              : [];
            let prevMa = prev10.length > 0
              ? prev10.reduce((a,b) => a + b, 0) / prev10.length
              : ma; // fallback to current MA if not enough history
            let delta = ma - prevMa;
            window.volScoreMovingAvg = ma;
            window.volScoreDelta = delta;
            // Update spans in UI
            const maEl = document.getElementById('volMovingAvg');
            if (maEl) maEl.textContent = ma.toFixed(2);
            const deltaEl = document.getElementById('volDelta');
            if (deltaEl) deltaEl.textContent = delta.toFixed(2);
          }
          // Store volatility score in coreData for other consumers
          if (typeof window.coreData !== "object") window.coreData = {};
          window.coreData.volatility_score = data.volScore;
          if ('volSpike' in data) {
            const volSpike = Number(data.volSpike);
            const el = document.getElementById('volSpike');
            if (el && typeof volSpike === 'number' && !isNaN(volSpike)) {
              el.textContent = volSpike.toFixed(2);
            }
          }
        })
        .catch(error => {
          console.error('Live core fetch error:', error);
        });
    }

    fetchOtherCoreData();
    // setInterval(fetchOtherCoreData, 1000); // Replaced by staggered polling below
    fetchBTCPriceChanges();
    // setInterval(fetchBTCPriceChanges, 1000); // Replaced by staggered polling below

    // === POLLING REMOVALS: Fills, Positions, Settlements, Balance ===
    // The following polling code is disabled as requested:
    /*
    // setInterval(() => {
    //   fetch('/api/db/fills').then(...);
    //   fetch('/api/db/positions').then(...);
    //   fetch('/api/db/settlements').then(...);
    //   fetch('/api/account/balance').then(...);
    // }, INTERVAL);
    */
  </script>

<script>
  const container = document.getElementById('container');
  const col1 = document.getElementById('col1');
  const col2 = document.getElementById('col2');
  const col3 = document.getElementById('col3');
</script>

</script>

<script>
  // Listen for change events on the ticker-picker select and update ticker-display cell
  document.addEventListener('DOMContentLoaded', function() {
    const tickerSelect = document.getElementById('ticker-picker');
    const tickerDisplay = document.getElementById('ticker-display');
    if (tickerSelect && tickerDisplay) {
      // Set initial display to selected value
      tickerDisplay.textContent = tickerSelect.value;
      tickerSelect.addEventListener('change', function() {
        tickerDisplay.textContent = tickerSelect.value;
      });
    }
  });
</script>
</div>
</body>
<script>
// === Active Trades Panel and Trade Execution ===
const activeTradesTableBody = document.querySelector('#activeTradesTable tbody');
const recentTradesTableBody = document.querySelector('#recentTradesTable tbody');

const errorTooltip = document.getElementById('errorTooltip');

function positionErrorTooltip(mouseX, mouseY) {
  if (!errorTooltip) return;
  const left = mouseX - errorTooltip.offsetWidth - 14;
  const top  = mouseY - errorTooltip.offsetHeight / 2;
  errorTooltip.style.left = left + 'px';
  errorTooltip.style.top  = top  + 'px';
}

function showErrorTooltip(text, mouseX, mouseY) {
  if (!errorTooltip) return;
  errorTooltip.textContent = text;
  errorTooltip.style.display = 'block';
  positionErrorTooltip(mouseX, mouseY);
}

function hideErrorTooltip() {
  if (errorTooltip) errorTooltip.style.display = 'none';
}

function formatDateTime(isoString) {
  const date = new Date(isoString);
  const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
  return [date.toLocaleDateString(), time];
}

// Utility function to get selected symbol from ticker panel
function getSelectedSymbol() {
  const tickerSelect = document.getElementById('ticker-picker');
  if (tickerSelect) {
    return tickerSelect.value;
  }
  return "";
}

// Utility function to get truncated market title, e.g., "BTC 11am"
function getTruncatedMarketTitle() {
  if (window.CurrentMarketTitleRaw && typeof window.CurrentMarketTitleRaw === "string") {
    const contractMatch = window.CurrentMarketTitleRaw.match(/at\s(.+?)\s*(?:EDT|EST|PDT|PST)?\?/i);
    if (contractMatch) {
      return `BTC ${contractMatch[1].trim()}`;
    } else {
      return window.CurrentMarketTitleRaw;
    }
  }
  return 'BTC Unknown';
}

// Utility function to get current BTC ticker price from the UI
function getCurrentBTCTickerPrice() {
  const el = document.getElementById('btc-price-value');
  if (el && el.textContent) {
    // Remove $ and commas, parse as float
    const val = parseFloat(el.textContent.replace(/\$|,/g, ''));
    return isNaN(val) ? "" : val;
  }
  return "";
}

// Utility function to get current momentum score from the panel
function getCurrentMomentumScore() {
  const el = document.getElementById('momentum-score-value');
  if (el && el.textContent) {
    const val = parseFloat(el.textContent.replace(/[^\d\.\-]/g, ''));
    return isNaN(val) ? "" : val;
  }
  return "";
}

// Play a sound by type, allowing overlapping playback
function playSound(type) {
  const soundId = type === 'open' ? 'openTradeSound' : 'closeTradeSound';
  const original = document.getElementById(soundId);
  if (!original) return;

  const clone = original.cloneNode(true); // Allow overlapping playback
  clone.volume = type === 'open' ? 0.1 : 0.2; // Set volume inline
  clone.play().catch(err => console.error(`Failed to play sound clone:`, err));
}

async function showPopup(strike, side, price) {
  // Play open trade sound using overlapping playback
  playSound('open');
  // showTradeOpenedPopup();   // popup disabled for test
  // --- All other logic temporarily disabled ---
  /*
  // === Backend: Send trade open request ===
  // const res = await fetch('/trades', {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({
  //     strike,
  //     side,
  //     price,
  //     // Add other required fields here
  //   })
  // });
  // if (!res.ok) throw new Error('Failed to open trade');
  // const trade = await res.json();

  // === DB: Add to local trades state ===
  // window.trades = window.trades || [];
  // window.trades.push(trade);

  // === UI: Update active trades table ===
  // await fetchAndRenderTrades();
  // showTradeOpenedPopup();
  */
}


// === Flicker-free Active Trades Table with persistent rows and in-place updates ===
const activeTradesRowsMap = new Map();
const previousClosePrices = {}; // Keyed by trade.id

async function fetchAndRenderTrades() {
  try {
    // Fetch all trades (all statuses) from backend
    const tradesRes = await fetch('/trades', { cache: 'no-store' });
    if (!tradesRes.ok) throw new Error("Failed to fetch trades");
    let trades = await tradesRes.json();
    // Only show trades whose status is not "closed" or "expired"
    trades = trades.filter(trade =>
      trade.status !== "closed" && trade.status !== "expired"
    );

    // Fetch core data and markets snapshot concurrently
    const [coreRes, marketsRes] = await Promise.all([
      fetch('/core'),
      fetch('/kalshi_market_snapshot')
    ]);
    if (!coreRes.ok || !marketsRes.ok) throw new Error("Failed to fetch core or markets data");
    const coreData = await coreRes.json();
    const marketsData = await marketsRes.json();
    const latestKalshiMarkets = Array.isArray(marketsData.markets) ? marketsData.markets : [];

    const ttcSeconds = coreData.ttc_seconds || 1;
    const ttcMinutes = ttcSeconds / 60;

    // Build a map of trade.id to trade for quick lookup
    const tradeIdSet = new Set(trades.map(trade => trade.id));

    // Remove rows for trades that no longer exist
    for (const [tradeId, rowObj] of activeTradesRowsMap.entries()) {
      if (!tradeIdSet.has(tradeId)) {
        if (rowObj.tr && rowObj.tr.parentNode === activeTradesTableBody) {
          activeTradesTableBody.removeChild(rowObj.tr);
        }
        activeTradesRowsMap.delete(tradeId);
        delete previousClosePrices[tradeId];
      }
    }

    // --- Remove all existing spanner rows before rendering trade rows ---
    activeTradesTableBody.querySelectorAll('.spanner-row').forEach(row => row.remove());

    // --- Sort trades by strike (ascending) for correct row order ---
    trades.sort((a, b) => {
      const strikeA = parseFloat(String(a.strike).replace(/[^\d.-]/g, '')) || 0;
      const strikeB = parseFloat(String(b.strike).replace(/[^\d.-]/g, '')) || 0;
      return strikeA - strikeB;
    });

    // === Prepare to build all rows in an array ===
    const tradeRows = [];
    const currentPrice = coreData.btc_price;
    let spannerInserted = false;
    let spannerIndex = trades.length; // default to end

    // Find the correct index to insert the spanner row
    for (let i = 0; i < trades.length; i++) {
      const strike = parseFloat(String(trades[i].strike).replace(/[^\d.-]/g, '')) || 0;
      if (!spannerInserted && currentPrice < strike) {
        spannerIndex = i;
        spannerInserted = true;
        break;
      }
    }

    // Build trade rows (do not append yet)
    trades.forEach((trade, idx) => {
      // --- Remove spanner row logic from here ---
      // Re-render the row if status has changed
      const existing = activeTradesRowsMap.get(trade.id);
      if (existing && existing.status !== trade.status) {
        activeTradesTableBody.removeChild(existing.tr);
        activeTradesRowsMap.delete(trade.id);
      }
      // === PENDING/ERROR/CLOSING TRADE ROW LOGIC: merge Buffer and B/M into one cell ===
      if (["pending", "error", "closing"].includes(trade.status)) {
        let rowObj = activeTradesRowsMap.get(trade.id);
        // Choose color and label
        let bgColor, label, textColor;
        if (trade.status === "pending" || trade.status === "closing") {
          bgColor = "#3b82f6";
          label = trade.status === "pending" ? "PENDING" : "CLOSING";
          textColor = "white";
        } else if (trade.status === "error") {
          bgColor = "#ef4444";
          label = "ERROR";
          textColor = "white";
        }
        if (!rowObj) {
          const row = document.createElement("tr");
          row.style.backgroundColor = bgColor;
          row.style.color = textColor;
          // Strike
          const strikeCell = document.createElement("td");
          strikeCell.textContent = trade.strike;
          row.appendChild(strikeCell);
          // Side
          const sideCell = document.createElement("td");
          sideCell.textContent = trade.side;
          row.appendChild(sideCell);
          // Buy (price)
          const priceCell = document.createElement("td");
          priceCell.textContent = (typeof trade.buy_price === "number")
            ? trade.buy_price.toFixed(2)
            : trade.buy_price;
          row.appendChild(priceCell);
          // Position
          const posCell = document.createElement("td");
          posCell.textContent = trade.position ?? trade.quantity ?? "";
          row.appendChild(posCell);
          // Buffer and B/M merged cell
          const statusCell = document.createElement("td");
          statusCell.colSpan = 2;
          statusCell.style.textAlign = "center";
          statusCell.style.fontStyle = "italic";
          statusCell.textContent = label;
          row.appendChild(statusCell);
          // === Replacement: Close column (Cancel button for pending/error/closing trades) ===
          const closeCell = document.createElement("td");
          closeCell.style.textAlign = "center";
          // Create a fresh Cancel button styled as price-box
          const cancelSpan = document.createElement("span");
          cancelSpan.className = "price-box";
          cancelSpan.dataset.tradeId = trade.id;
          cancelSpan.dataset.action = "close";
          cancelSpan.style.cursor = "pointer";
          cancelSpan.onclick = () => cancelTrade(trade.id, trade.ticket_id);
          const innerDiv = document.createElement("div");
          innerDiv.textContent = "Cancel";
          cancelSpan.appendChild(innerDiv);
          closeCell.appendChild(cancelSpan);
          row.appendChild(closeCell);
          rowObj = { tr: row, statusCell, status: trade.status };
          activeTradesRowsMap.set(trade.id, rowObj);
        } else {
          rowObj.tr.style.backgroundColor = bgColor;
          rowObj.tr.style.color = textColor;
          rowObj.status = trade.status;
        }
        // --- Add error tooltip logic for "error" status ---
        if (trade.status === "error" && rowObj.statusCell) {
          const statusTd = rowObj.statusCell;
          statusTd.style.cursor = 'help';
          statusTd.classList.add('error-cell');
          const newStatusTd = statusTd.cloneNode(true);
          newStatusTd.textContent = statusTd.textContent;
          newStatusTd.style.cursor = 'help';
          newStatusTd.classList.add('error-cell');
          newStatusTd.addEventListener('mouseenter', async (evt) => {
            try {
              const resp = await fetch(`/api/trade_log/${trade.ticket_id}`);
              const data = await resp.json();
              if (data.status === "ok") {
                showErrorTooltip(data.log, evt.clientX, evt.clientY);
              } else {
                showErrorTooltip("Log not found", evt.clientX, evt.clientY);
              }
            } catch (e) {
              showErrorTooltip('Failed to load trade log.', evt.clientX, evt.clientY);
            }
          });
          newStatusTd.addEventListener('mousemove', (evt) => {
            positionErrorTooltip(evt.clientX, evt.clientY);
          });
          newStatusTd.addEventListener('mouseleave', hideErrorTooltip);
          rowObj.tr.replaceChild(newStatusTd, statusTd);
          rowObj.statusCell = newStatusTd;
        }
        tradeRows.push(rowObj.tr);
        return;
      }

      // === OPEN TRADE ROW LOGIC ===
      const strikeNum = parseFloat(String(trade.strike).replace(/\$|,/g, '')) || 0;
      const isYes = (trade.side || "").toUpperCase() === "Y";
      const priceVal = coreData.btc_price;
      let inTheMoney = false;
      if (isYes) {
        inTheMoney = priceVal >= strikeNum;
      } else {
        inTheMoney = priceVal <= strikeNum;
      }
      const rawBuffer = priceVal - strikeNum;
      let buffer, bm;
      if (inTheMoney) {
        buffer = Math.abs(rawBuffer);
        bm = Math.abs(rawBuffer) / ttcMinutes;
      } else {
        buffer = -Math.abs(rawBuffer);
        bm = -Math.abs(rawBuffer) / ttcMinutes;
      }
      const bufferDisplay = buffer.toLocaleString(undefined, {maximumFractionDigits: 0});
      const bmDisplay = Math.round(bm).toLocaleString();
      let rowClass = '';
      if (Math.abs(buffer) >= 300) rowClass = 'ultra-safe';
      else if (Math.abs(buffer) >= 200) rowClass = 'safe';
      else if (Math.abs(buffer) >= 100) rowClass = 'caution';
      else if (Math.abs(buffer) >= 50) rowClass = 'high-risk';
      else rowClass = 'danger-stop';
      const oppositeSide = (trade.side && trade.side.toUpperCase() === 'Y') ? 'NO' : 'YES';
      const strikeFormatted = '$' + strikeNum.toLocaleString();
      let closeButtonSpan = null;
      const strikeTableRows = document.querySelectorAll('#strike-table tbody tr');
      for (const row of strikeTableRows) {
        const firstTd = row.querySelector('td');
        if (!firstTd) continue;
        const firstTdText = firstTd.textContent.trim();
        if (firstTdText === strikeFormatted) {
          let cellIdx = oppositeSide === 'YES' ? 5 : 6;
          const tds = row.querySelectorAll('td');
          if (tds.length > cellIdx) {
            const span = tds[cellIdx].querySelector('span.price-box, span.price-box.disabled');
            if (span) closeButtonSpan = span;
          }
          break;
        }
      }
      let askPrice = parseFloat(closeButtonSpan?.textContent || 'NaN');
      let isActive = closeButtonSpan && !closeButtonSpan.classList.contains('disabled');
      let rowObj = activeTradesRowsMap.get(trade.id);
      if (!rowObj) {
        const tr = document.createElement('tr');
        tr.className = rowClass;
        const strikeTd = document.createElement('td');
        strikeTd.textContent = trade.strike;
        const sideTd = document.createElement('td');
        sideTd.textContent = trade.side;
        const priceTd = document.createElement('td');
        priceTd.textContent = trade.buy_price.toFixed(2);
        const posTd = document.createElement('td');
        posTd.textContent = trade.position;
        const bufferTd = document.createElement('td');
        bufferTd.textContent = bufferDisplay;
        const bmTd = document.createElement('td');
        bmTd.textContent = bmDisplay;
        const closeTd = document.createElement('td');
        closeTd.className = 'center';
        if (closeButtonSpan) {
          const clonedSpan = closeButtonSpan.cloneNode(true);
          clonedSpan.classList.remove('disabled');
          clonedSpan.style.opacity = '';
          clonedSpan.style.pointerEvents = '';
          clonedSpan.style.cursor = 'pointer';
          clonedSpan.dataset.tradeId = trade.id;
          clonedSpan.dataset.action = 'close';
          closeTd.appendChild(clonedSpan);
          previousClosePrices[trade.id] = askPrice;
        } else {
          closeTd.textContent = 'N/A';
          previousClosePrices[trade.id] = null;
        }
        tr.appendChild(strikeTd);
        tr.appendChild(sideTd);
        tr.appendChild(priceTd);
        tr.appendChild(posTd);
        tr.appendChild(bufferTd);
        tr.appendChild(bmTd);
        tr.appendChild(closeTd);
        rowObj = {
          tr, strikeTd, sideTd, priceTd, posTd, bufferTd, bmTd, closeTd,
          status: trade.status
        };
        activeTradesRowsMap.set(trade.id, rowObj);
      } else {
        if (rowObj.tr.className !== rowClass) rowObj.tr.className = rowClass;
        rowObj.tr.style.backgroundColor = "";
        rowObj.status = trade.status;
      }
      if (rowObj.bufferTd.textContent !== bufferDisplay) rowObj.bufferTd.textContent = bufferDisplay;
      if (rowObj.bmTd.textContent !== bmDisplay) rowObj.bmTd.textContent = bmDisplay;
      const prevAsk = previousClosePrices[trade.id];
      if (closeButtonSpan) {
        if (prevAsk !== askPrice) {
          rowObj.closeTd.innerHTML = '';
          const clonedSpan = closeButtonSpan.cloneNode(true);
          clonedSpan.classList.remove('disabled');
          clonedSpan.style.opacity = '';
          clonedSpan.style.pointerEvents = '';
          clonedSpan.style.cursor = 'pointer';
          clonedSpan.dataset.tradeId = trade.id;
          clonedSpan.dataset.action = 'close';
          rowObj.closeTd.appendChild(clonedSpan);
          previousClosePrices[trade.id] = askPrice;
        }
      } else {
        if (prevAsk !== null) {
          rowObj.closeTd.textContent = 'N/A';
          previousClosePrices[trade.id] = null;
        }
      }
      if (!rowObj.tr.parentNode) {
        // Not appending here; will append in batch below
      }
      tradeRows.push(rowObj.tr);
    });

    // Only insert the spanner row if there are open trades
    if (tradeRows.length > 0) {
      // Build the spanner row
      const spannerRow = document.createElement("tr");
      spannerRow.className = "spanner-row";
      const spannerTd = document.createElement("td");
      spannerTd.colSpan = 7;

      // --- Add arrow icons based on momentum score ---
      // Helper to get current momentum score from DOM
      function getCurrentMomentumScoreForArrow() {
        const el = document.getElementById('momentum-score-value');
        if (el && el.textContent) {
          const val = parseFloat(el.textContent.replace(/[^\d\.\-]/g, ''));
          return isNaN(val) ? 0 : val;
        }
        return 0;
      }
      let momentumScore = getCurrentMomentumScoreForArrow();
      let arrow = '';
      // SVGs for straight arrows (no margin)
      const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const svgUpDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 2l4 4M8 2l-4 4M8 14l4-4M8 14l-4-4" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const absMomentum = Math.abs(momentumScore);
      let arrowBlock = '';
      if (momentumScore === 0) {
        arrowBlock = svgUpDown;
      } else if (momentumScore > 0) {
        if (absMomentum <= 10) {
          arrowBlock = svgDown;
        } else if (absMomentum <= 20) {
          arrowBlock = svgDown + svgDown;
        } else {
          arrowBlock = svgDown + svgDown + svgDown;
        }
      } else if (momentumScore < 0) {
        if (absMomentum <= 10) {
          arrowBlock = svgUp;
        } else if (absMomentum <= 20) {
          arrowBlock = svgUp + svgUp;
        } else {
          arrowBlock = svgUp + svgUp + svgUp;
        }
      }
      spannerTd.innerHTML = `<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>Current Price: $${Math.round(currentPrice).toLocaleString()}<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>`;
      spannerRow.appendChild(spannerTd);

      // Insert the spanner row at the correct index
      tradeRows.splice(spannerIndex, 0, spannerRow);
    }

    // Clear and re-append all rows
    activeTradesTableBody.innerHTML = '';
    tradeRows.forEach(row => activeTradesTableBody.appendChild(row));
  } catch (err) {
    console.error('Error fetching trades:', err);
  }
}

// New async function to close trade by id with current time and BTC price, using sellPrice
async function closeTradeById(tradeId, sellPrice) {
  // Play close trade sound using overlapping playback
  playSound('close');
  // showTradeClosedPopup();   // popup disabled for test
  // --- All other logic temporarily disabled ---
  /*
  // === Backend: Send trade close request ===
  // const payload = {
  //   status: "closed",
  //   closed_at: new Date().toLocaleTimeString('en-US', {
  //     timeZone: 'America/New_York',
  //     hour12: false,
  //     hour: '2-digit',
  //     minute: '2-digit',
  //     second: '2-digit'
  //   }),
  //   symbol_close: getCurrentBTCTickerPrice(),
  //   sell_price: sellPrice
  // };
  // const res = await fetch(`/trades/${tradeId}`, {
  //   method: 'PUT',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify(payload)
  // });
  // if (!res.ok) throw new Error('Failed to close trade');

  // === DB/UI: Refresh tables ===
  // await fetchAndRenderTrades();
  // await fetchAndRenderRecentTrades();
  // showTradeClosedPopup();
  */
}

// === Recent Trades Panel ===
async function fetchAndRenderRecentTrades() {
  try {
    // Fetch all closed trades
    const res = await fetch('/trades?status=closed', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch recent trades");
    const trades = await res.json();
    console.log("Recent trades response:", trades);
    // Show the 5 most recently closed trades in descending order by closed_at
    const recentFive = trades
      .filter(trade => trade.closed_at)
      .sort((a, b) => new Date(b.closed_at) - new Date(a.closed_at))
      .slice(0, 5);
    recentTradesTableBody.innerHTML = '';
    recentFive.forEach(trade => {
      // Show raw time field from the database for Time column
      let timeCell = trade.time || 'â€”';
      // Raw closed time cell display
      let closedCell = trade.closed_at || 'â€”';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${timeCell}</td>
        <td>${trade.contract || ''}</td>
        <td>${trade.strike}</td>
        <td>${trade.side}</td>
        <td>${trade.buy_price.toFixed(2)}</td>
        <td>${trade.sell_price !== undefined && trade.sell_price !== null ? (trade.sell_price).toFixed(2) : 'â€”'}</td>
        <td>${trade.position}</td>
        <td>${closedCell}</td>
      `;
      recentTradesTableBody.appendChild(tr);
    });
  } catch (err) {
    console.error('Error fetching recent trades:', err);
  }
}

// === New function: Close all expired trades (set status to closed and closed_at to current time in NY) ===
async function closeExpiredTrades() {
  try {
    // Fetch all open trades
    const res = await fetch('/trades?status=open', { cache: 'no-store' });
    if (!res.ok) throw new Error("Failed to fetch open trades");
    const openTrades = await res.json();

    // Get current BTC ticker price from DOM element
    const currentPriceEl = document.getElementById('btc-price-value');
    const currentSymbolPrice = currentPriceEl ? parseFloat(currentPriceEl.textContent.replace(/\$|,/g, '')) : null;

    // Loop over each trade and send a close request
    for (const trade of openTrades) {
      const strike = parseFloat(String(trade.strike).replace(/\$|,/g, '')) || 0;
      const isYes = (trade.side || "").toUpperCase() === "Y";
      // Use inclusive logic for win condition at expiration
      const didWin = isYes ? currentSymbolPrice >= strike : currentSymbolPrice <= strike;

      const payload = {
        status: "closed",
        closed_at: new Date().toLocaleTimeString('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }),
        symbol_close: currentSymbolPrice,
        sell_price: didWin ? 1.00 : 0.00
      };

      const updateRes = await fetch(`/trades/${trade.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!updateRes.ok) {
        console.error(`Failed to close trade ${trade.id}`);
      }
    }

    await fetchAndRenderTrades();
    await fetchAndRenderRecentTrades();
  } catch (err) {
    console.error("Error in closeExpiredTrades:", err);
  }
}


document.addEventListener('DOMContentLoaded', () => {
  fetchAndRenderTrades();
  // setInterval(fetchAndRenderTrades, 1000); // Replaced by staggered polling below
  fetchAndRenderRecentTrades();
  // setInterval(fetchAndRenderRecentTrades, 1000); // Replaced by staggered polling below
  // Ensure Active Trades panel is refreshed in sync with main loop
  updateActiveTrades();
  // setInterval(updateActiveTrades, 1000); // Replaced by staggered polling below
});

// Function to refresh the Active Trades panel using up-to-date API data
async function updateActiveTrades() {
  await fetchAndRenderTrades();
}

// --- Debounce mechanism for close trade clicks ---
const lastCloseClickTimes = {};
const DEBOUNCE_DELAY_MS = 300;

// --- Delegated event handler for closing trades ---
activeTradesTableBody.addEventListener('click', (event) => {
  const target = event.target;
  if (target.classList.contains('price-box') && target.dataset.action === 'close') {
    const tradeId = target.dataset.tradeId;
    if (!tradeId) return;

    const now = Date.now();
    if (lastCloseClickTimes[tradeId] && now - lastCloseClickTimes[tradeId] < DEBOUNCE_DELAY_MS) {
      return;
    }
    lastCloseClickTimes[tradeId] = now;

    // Manual close: use ask value shown on the Close button
    const closeButton = target;
    const askText = closeButton.textContent.trim();
    const askNum = parseFloat(askText);
    let calculatedSellPrice = null;
    if (!isNaN(askNum)) {
      calculatedSellPrice = 1.0 - (askNum / 100);
    }
    if (calculatedSellPrice === null) {
      alert('Invalid ASK price for closing trade');
      return;
    }
    // Use new master closeTrade function instead of closeTradeById
    closeTrade(tradeId, calculatedSellPrice, event);
  }
});

</script>
<script>
  function showTradeOpenedPopup() {
    const popup = document.getElementById('tradePopup');
    if (!popup) return;

    popup.style.transition = 'none';
    popup.style.display = 'block';
    popup.style.opacity = '1';

    setTimeout(() => {
      popup.style.transition = 'opacity 0.5s ease';
      popup.style.opacity = '0';
      setTimeout(() => {
        popup.style.display = 'none';
      }, 500);
    }, 2000);
  }

  function showTradeClosedPopup() {
    const popup = document.getElementById('tradeClosedPopup');
    if (!popup) return;

    popup.style.transition = 'none';
    popup.style.display = 'block';
    popup.style.opacity = '1';

    setTimeout(() => {
      popup.style.transition = 'opacity 0.5s ease';
      popup.style.opacity = '0';
      setTimeout(() => {
        popup.style.display = 'none';
      }, 500);
    }, 2000);
  }
</script>
</script>
</script>

  <!-- Trade Open/Closed Popups -->
  <div id="tradePopup" class="trade-popup">Trade Opened</div>
  <div id="tradeClosedPopup" class="trade-closed-popup">Trade Closed</div>

  <!-- Preload audio for trade open/close confirmations -->
  <audio id="openTradeSound" preload="auto">
    <source src="/audio/sfx/open_trade_confirmation.wav" type="audio/wav">
  </audio>
  <audio id="closeTradeSound" preload="auto">
    <source src="/audio/sfx/close_trade_confirmation.wav" type="audio/wav">
  </audio>
  <!-- === Staggered polling loops for main panels === -->
  <script>
  // Polling refresh loops â€“ staggered to avoid main thread congestion
  function fetchAndRenderStrikeTable() {
    fetchAndUpdate();
  }

  function fetchAndRenderActiveTrades() {
    fetchAndRenderTrades();
  }

  function fetchVolatilityAndMomentum() {
    fetchOtherCoreData();
    fetchCore();
    fetchBTCPriceChanges();
  }

  setInterval(fetchAndRenderStrikeTable, 1250);   // Strike panel
  setInterval(fetchAndRenderActiveTrades, 1350);  // Active trades table
  setInterval(fetchVolatilityAndMomentum, 1450);  // Volatility/momentum panels
  </script>

  <!-- --- Add a MutationObserver to update arrows when momentum score changes --- -->
  <script>
  (function setupMomentumArrowObserver() {
    const momentumEl = document.getElementById('momentum-score-value');
    if (!momentumEl) return;
    const observer = new MutationObserver(() => {
      // Find the spanner row and update arrows
      const spannerRow = document.querySelector('#activeTradesTable tr.spanner-row');
      if (!spannerRow) return;
      const spannerTd = spannerRow.querySelector('td');
      if (!spannerTd) return;
      const val = parseFloat(momentumEl.textContent.replace(/[^\d\.\-]/g, ''));
      let arrow = '';
      // SVGs for straight arrows (no margin)
      const svgDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 14l4-4M8 14l-4-4" stroke="#45d34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const svgUp = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 14V2M8 2l4 4M8 2l-4 4" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const svgUpDown = `<svg width="16" height="16" style="vertical-align:middle;" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v12M8 2l4 4M8 2l-4 4M8 14l4-4M8 14l-4-4" stroke="#aaa" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      const absMomentum = Math.abs(val);
      let arrowBlock = '';
      if (val === 0) {
        arrowBlock = svgUpDown;
      } else if (val > 0) {
        if (absMomentum <= 10) {
          arrowBlock = svgDown;
        } else if (absMomentum <= 20) {
          arrowBlock = svgDown + svgDown;
        } else {
          arrowBlock = svgDown + svgDown + svgDown;
        }
      } else if (val < 0) {
        if (absMomentum <= 10) {
          arrowBlock = svgUp;
        } else if (absMomentum <= 20) {
          arrowBlock = svgUp + svgUp;
        } else {
          arrowBlock = svgUp + svgUp + svgUp;
        }
      }
      // Extract the price from the current text
      const match = spannerTd.textContent.match(/Current Price: \$[\d,]+/);
      const priceText = match ? match[0] : '';
      spannerTd.innerHTML = `<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>${priceText}<span style=\"margin:0 12px;display:inline-block;\">${arrowBlock}</span>`;
    });
    observer.observe(momentumEl, { childList: true, characterData: true, subtree: true });
  })();
  </script>
</html>